다형성이란?
->
객체 지향 프로그래밍의 핵심 원칙 중 하나로 여러 가지 형태를 가질 수 있는 능력을 의미합니다.



트리란?
->
트리는 데이터를 계층적으로 표현하는데 사용되는 비선형 자료구조입니다. 나무를 거꾸로 뒤집어 놓은 형태와 비슷하다고 해서 트리라고 불리며 뿌리(Root)에서 시작하여 가지(Branch)를 통해 잎(Leaf)으로 뻗어나가는 구조를 가집니다.

노드(Node): 트리를 구성하는 각 요소로 데이터와 다른 노드로의 연결 정보를 가짐
루트 노드(Root Node): 트리의 가장 꼭대기에 있는 노드로 부모 노드가 없음
부모 노드(Parent Node): 특정 노드 바로 위에 연결된 노드
자식 노드(Child Node): 특정 노드 바로 아래에 연결된 노드
형제 노드(Sibling Node): 같은 부모를 가지는 노드들
리프 노드(Leaf Node): 자식 노드가 없는 노드
간선(Edge): 노드와 노드를 연결하는 선

이진 트리(Binary Tree): 각 노드가 최대 두개의 자식 노드를 가질 수 있는 트리
이진 탐색 트리(Binary Search Tree, BST): 이진 트리의 일종으로 왼쪽 자식 노드는 부모보다 작고 오른쪽 자식 노드는 부모보다 큰 값을 가지는 특성 덕분에 검색/삽입/삭제가 효율적임
균형 트리(Balanced Tree): 트리의 높이를 균등하게 유지하여 최악의 경우 성능 저하를 막는 트리 (AVL 트리, RB 트리)

트리는 파일 시스템 구조, 데이터베이스 인덱스, XML/HTML 문서 구조, 인공지능의 의사결정 트리 등 계층적인 데이터를 효율적으로 관리하고 탐색하는데 널리 사용됩니다.


트리의 순회 방법은?
->
전위 순회(Pre-order Traversal).
방문 순서: Root -> Left -> Right
용도: 트리를 복사하거나 직렬화할 때, 디렉토리 구조를 출력할 때

중위 순회(In-order Traversal).
방문 순서: Left -> Root -> Right
용도: 이진 탐색 트리를 중위 순회하면 오름차순으로 정렬된 결과를 얻을 수 있음

후위 순회(Post-order Traversal).
방문 순서: Left -> Right -> Root
용도: 트리를 삭제하거나 메모리에서 해제할 때(자식 노드를 먼저 제거해야 부모 노드를 안전하게 제거할 수 있음), 디렉토리 공간 사용량을 계산할 때(하위 디렉토리부터 계산해야 총량을 알 수 있음)

레벨 순회(Level-order Traversal).
방문 순서: 레벨별로 왼쪽에서 오른쪽으로
용도: 트리의 각 레벨에 있는 노드들을 순서대로 처리해야 할 때, 최단 경로를 찾을 때


이진 트리란?
->
이진 트리(Binary Tree)는 트리의 한 종류로 각 노드가 최대 두개의 자식 노드를 가질 수 있는 트리를 말합니다.

종류.
정 이진 트리(Full Binary Tree): 모든 노드가 0개 또는 2개의 자식 노드를 가지는 트리
완전 이진 트리(Complete Binary Tree): 트리의 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있고 마지막 레벨에서는 노드가 왼쪽부터 오른쪽으로 순서대로 채워져 있는 트리, 배열을 이용한 힙(Heap) 구현에 적합
포화 이진 트리(Perfect Binary Tree): 정 이진 트리이면서 완전 이진 트리인 트리
편향 이진 트리(Skewed Binary Tree): 모든 노드가 한쪽으로만 자식을 가지는 트리


LCRS 트리란?
->
LCRS 트리(Left-Child Right-Sibling Tree)는 일반적인 트리(자식의 개수에 제한이 없는 트리)를 이진 트리 형태로 표현하는 효율적인 방법입니다. 각 노드는 오직 2개의 포인터만 가집니다.

노드의 특징.
데이터(Data): 해당 노드가 저장하는 실제 값
왼쪽 자식 포인터(Left Child Pointer): 이 노드의 가장 왼쪽 자식 노드를 가리킴
오른쪽 형제 포인터(Right Sibling Pointer): 이 노드의 바로 오른쪽 형제 노드를 가리킴

일반적인 트리는 각 노드가 여러 자식을 가질 수 있으므로 자식 노드를 저장하기 위해 가변적인 크기의 배열이나 리스트를 사용해야 합니다. LCRS 표현은 이 문제를 해결하기 위해 모든 자식 노드를 부모와 직접 연결하는 대신
첫번째 자식만 부모와 연결하고 나머지 자식들은 첫번째 자식의 형제 노드로 연결하는 방식
을 사용합니다.

장점.
메모리 효율성: 고정된 크기의 노드를 사용하여 자식의 개수에 관계없이 관리할 수 있음
구현의 단순성: 모든 트리를 이진 트리 형태로 변환하여 표현하므로 이진 트리에 익숙한 알고리즘과 순회 방법을 그대로 사용할 수 있음
유연성: 자식의 개수에 제한이 없는 일반적인 트리를 표현할 수 있음

단점.
특정 자식 접근의 비효율성: 특정 번호의 자식을 접근하려면 Right Sibling Pointer를 따라 순차적으로 이동해야 하므로 O(N)의 시간이 소요될 수 있음
부모 노드 접근이 어려움: LCRS 노드는 부모에 대한 포인터가 없기 때문에 부모 노드를 찾아야 하는 연산은 트리를 처음부터 탐색해야 할 수 있음(또는 설계 시 부모 포인터를 추가)

활용.
파일 시스템(디렉토리 구조), XML/HTML 파서, 씬 그래프


힙 트리란?
->
힙 트리(Heap Tree)는 이진 트리 중 완전 이진 트리 형태를 유지하면서 특정 노드와 그 자식 노드들 사이에 우선순위 관계를 만족하는 특수한 자료구조입니다. 주로 우선순위 큐를 구현하는데 사용됩니다.

속성과 관계 유형.
힙 속성: 각 노드가 자식 노드와의 특정 우선순위 관계(최대 힙, 최소 힙)을 만족해야 함
최대 힙(Max Heap): 부모 노드의 값은 항상 자식 노드의 값보다 크거나 같음
최소 힙(Min Heap): 부모 노드의 값은 항상 자식 노드의 값보다 작거나 같음

특징.
마지막 레벨을 제외하고 모든 레벨이 완전히 채워지고 마지막 레벨의 노드들이 가능한 왼쪽부터 채워져 있는 완전 이진 트리의 특징으로 인해 배열을 사용하여 구현할 수 있음

배열에서 인덱스 i의 노드에 대해.
0-indexed: 왼쪽 자식은 2 * i + 1, 오른쪽 자식은 2 * i + 2, 부모는 (i - 1) / 2
1-indexed: 왼쪽 자식은 2 * i, 오른쪽 자식은 2 * i + 1, 부모는 i / 2

삽입 연산.
새로운 요소를 힙의 마지막 위치(배열의 끝)에 추가
새로 추가된 요소가 힙 속성을 위반하는지 확인
위반 시 부모 노드와 값을 교환하면서 위로 올라감, 이 과정을 힙화(Heapify Up 또는 Up-Heap)라 하며 트리의 높이만큼 진행되므로 O(logN) 소요될

삭제 연산.
힙에서는 일반적으로 가장 우선순위가 높은 요소(루트 노드)만 삭제 가능
루트 노드를 삭제한 후 힙의 마지막 노드를 루트 위치로 가져옴
새 루트 노드가 힙 속성을 위반하는지 확인
위반 시 자식 노드와 값을 교환하며 아래로 내려감, 이 과정을 힙화(Heapify Down 또는 Down-Heap)라 함

활용.
우선순위 큐 구현: 운영체제의 작업 스케줄링, 시뮬레이션, 네트워크 라우팅 등
힙 정렬
데이터 압축(허프만 코딩): 최소 힙 사용
그래프 알고리즘: 다익스트라 알고리즘, 프림 알고리즘 등 최단 경로/최소 신장 트리를 찾는 알고리즘에서 우선순위 큐로 사용
K번째로 큰/작은 원소 찾기


이진 탐색 트리란?
->
이진 탐색 트리(Binary Search Tree, BST)는 이진 트리의 한 종류이자 특정 규칙을 추가하여 효율적인 데이터 검색/삽입/삭제를 가능하게 하는 자료구조입니다.

핵심 규칙.
모든 노드의 왼쪽 서브트리에 있는 값들은 해당 노드의 값보다 작음
모든 노드의 오른쪽 서브트리에 있는 값들은 해당 노드의 값보다 큼
중복된 값은 허용하지 않거나 특정 규칙(같은 값일 시 오른쪽 서브트리에 저장 등)에 따라 처리(일반적으로 중복 금지)

장점.
빠른 검색: 규칙에 따라 탐색 범위를 절반씩 줄여나갈 수 있어 평균적으로 O(logN)의 시간 복잡도를 가짐
빠른 삽입 및 삭제: 검색과 유사하게 과정이 O(logN)로 빠름
정렬된 데이터 유지: 중위 순회를 수행하면 트리에 저장된 모든 데이터를 오름차순으로 얻을 수 있음

단점:
균형이 맞지 않는 경우 성능 저하: 트리가 편향 이진 트리와 같은 상태인 경우 O(N)으로 트리의 장점을 잃음, 이러한 높이 불균형 문제에 대해 균형 이진 탐색 트리(Balanced Binary Search Tree)라는 개념 등장, AVL 트리와 RB 트리가 있으며 트리의 균형을 자동으로 조절하여 O(logN)의 성능을 보장

검색 연산.
찾으려는 값과 현재 노드의 값을 비교
값이 같으면 찾은 것
찾으려는 값이 현재 노드의 값보다 작으면 왼쪽, 크면 오른쪽 서브트리로 이동
더 이상 이동할 노드가 없는데 값을 못찾은 경우 해당 값은 트리에 존재하지 않음

삽입 연산.
삽입하려는 값과 현재 노드의 값을 비교
찾으려는 값이 현재 노드의 값보다 작으면 왼쪽, 크면 오른쪽 서브트리로 이동
더 이상 자식노드가 없는 위치에 도달하면 해당 위치에 새 노드를 삽입

삭제 연산.
자식 노드가 없는 경우: 노드 삭제
자식노드가 하나 있는 경우: 삭제할 노드를 자식 노드로 대체
자식 노드가 두개 있는 경우: 삭제할 노드의 오른쪽 서브트리에서 가장 작은 값을 찾거나 왼쪽 서브트리에서 가장 큰 값을 찾고 찾은 값으로 삭제할 노드를 대체하고 대체된 위치에서 해당 노드를 삭제

활용.
데이터베이스 인덱싱
맵/딕셔너리 구현
정렬 알고리즘
우선순위 큐(Heap 대신)


AVL 트리란?
->
AVL 트리는 자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)의 한 종류입니다. 이진 탐색 트리의 문제점인 트리의 불균형으로 인한 성능 저하 문제를 해결하기 위해 고안되었습니다.

균형 인수(Balance Factor): 왼쪽 서브트리의 높이 - 오른쪽 서브트리의 높이
AVL 트리는 모든 노드의 균형 인수가 -1, 0, 1 중 하나여야 한다는 규칙을 가집니다. 만약 어떤 노드의 균형 인수가 이 범위를 벗어나면 트리가 불균형 상태가 되었다고 판단하고 회전 연산을 통해 균형을 다시 맞춥니다.

검색 연산.
일반적인 이진 탐색 트리와 동일하게 동작

삽입 연산.
일반적인 이진 탐색 트리와 동일하게 동작
삽입 후 삽입된 노드의 부모 노드들을 따라 올라가면서 각 노드의 균형 인수를 업데이트
불균형이 발생하면 회전 연산을 수행하여 트리의 균형을 맞춤

삭제 연산.
일반적인 이진 탐색 트리와 동일하게 동작
삭제 후 삭제된 노드의 부모 노드들을 따라 올라가면서 각 노드의 균형 인수를 업데이트
불균형이 발생하면 회전 연산을 수행하여 트리의 균형을 맞춤

회전 연산.
AVL 트리에서 불균형이 발생했을 때 트리의 균형을 맞추는 핵심 연산입니다. 회전은 트리의 구조를 변경하지만 이진 탐색 트리의 규칙은 유지합니다. 4가지 경우가 있습니다.
LL 회전: 노드의 왼쪽 자식의 왼쪽 서브트리에 노드가 삽입되어 불균형이 발생한 경우, 오른쪽으로 한번 회전하여 균형을 맞춥니다.
RR 회전: 노드의 오른쪽 자식의 오른쪽 서브트리에 노드가 삽입되어 불균형이 발생한 경우, 왼쪽으로 한번 회전하여 균형을 맞춥니다.
LR 회전: 노드의 왼쪽 자식의 오른쪽 서브트리에 노드가 삽입되어 불균형이 발생한 경우, 왼쪽 자식에 대해 RR 회전 후 해당 노드에 대해 LL 회전을 수행합니다.
RL 회전: 노드의 오른쪽 자식의 왼쪽 서브트리에 노드가 삽입되어 불균형이 발생한 경우, 오른쪽 자식에 대해 LL 회전 후 해당 노드에 대해 RR 회전을 수행합니다.

장점.
모든 연산이 최악의 경우에도 O(logN)을 보장

단점.
균형 인수에 대한 추가적인 메모리 필요
삽입 및 삭제 시 균형 인수에 대한 추가적인 계산이 필요하여 구현이 복잡하고 연산 오버헤드가 더 큼

활용.
데이터베이스 인덱스
파일 시스템
메모리 관리


RB 트리란?
->
AVL 트리와 마찬가지로 자가 균형 이진 탐색 트리(Self-Balancing Binary Search Tree)의 한 종류입니다. AVL 트리가 노드의 높이 차이(균형 인수)를 엄격하게 관리하는 반면 RB 트리는 노드의 색깔을 사용하여 균형을 유지합니다. 색깔 규칙들을 통해 트리의 높이가 항상 O(logN)으로 유지되도록 보장합니다.

규칙.
모든 노드는 빨간색 또는 검은색
루트 노드는 항상 검은색
모든 리프 노드(nullptr 노드)는 검은색 (실제 데이터를 저장하지 않는 가상의 노드를 의미, 트리의 끝을 나타냄)
빨간색 노드의 자식은 모두 검은색이어야 함
어떤 리프 노드에서든 루트 노드까지 가는 경로에 만나는 검은색 노드의 수가 같아야 함

삽입 연산.
삽입되는 노드의 색은 무조건 빨간색
삽입 시 빨간색 노드가 연속될 경우 재조정 (규칙 4 위반)

삭제 연산.
빨간색 노드의 경우 삭제하면 됨
검정색인 경우 삭제된 노드의 자리를 대체하는 노드를 검정색으로 변경
대체하는 노드가 검정색인 경우 더블 블랙 노드라고 하며 추가 작업 진행

장점.
모든 연산에서 최악의 경우에도 O(logN) 보장

단점.
AVL 트리에 비해 구현이 복잡 (더블 블랙 노드의 처리과정)

활용.
연관 배열, 맵 구현
우선순위 큐
데이터베이스 인덱스
운영체제 스케줄러



해시 테이블이란?
->
해시 테이블은 키와 값을 연결하여 데이터를 저장하는 자료구조입니다. 키를 이용해 값을 바로 찾아낼 수 있게 해주기 때문에 데이터의 검색/삽입/삭제가 매우 빠르게 이루어지는 것이 특징입니다.

해시 테이블의 핵심은 해시 함수입니다. 해시 함수는 키를 입력받아 해시 코드를 생성하고 이 해시 코드를 배열의 인덱스처럼 사용하여 데이터를 저장하거나 가져옵니다.
해싱(Hashing): 키를 해시 함수에 넣어 해시 코드를 얻는 과정
버킷(Bucket): 해시 테이블에서 데이터를 저장하는 공간으로 해시 코드를 통해 접근
충돌(Collision): 서로 다른 키가 같은 해시 코드를 생성하여 같은 버킷에 저장되려 할 때 발생하는 문제

충돌 해결방법.
체이닝(Chaining): 한 버킷에 여러 데이터를 연결 리스트 등으로 연결하여 저장하는 방식
개방 주소법(Open Addressing): 충돌이 발생하면 다른 비어있는 버킷을 찾아 데이터를 저장하는 방식 (선형 탐사, 이차 탐사, 이중 해싱)

해시 테이블은 데이터베이스 인덱싱, 캐시 구현, 집합(Set) 구현, 딕셔너리/맵 구현 등 빠른 데이터 검색이 필요한 모든 곳에서 핵심적으로 사용됩니다. 평균적으로 O(1)의 시간 복잡도로 데이터를 처리할 수 있어 매우 효율적입니다.



그래프란?
->
그래프는 노드(정점, Vertex)와 이 노드를 연결하는 간선(Edge)들로 구성된 자료구조입니다. 실제 세상의 복잡한 관계를 표현하는데 매우 유용합니다.
정점(Vertex/Node): 데이터가 있는 지점
간선(Edge): 정점들을 연결하는 선으로 두 정점 간의 관계를 나타냄
차수(Degree): 한 정점에 연결된 간선의 수
가중치(Weight): 간선에 부여된 값(두 정점 사이의 거리, 통신 비용 등)

그래프의 종류.
방향 그래프(Directed Graph): 간선에 방향이 있어 한쪽으로만 이동할 수 있는 그래프
무방향 그래프(Undirected Graph): 간선에 방향이 없어 양쪽으로 이동할 수 있는 그래프
가중치 그래프(Weighted Graph): 간선에 가중치가 부여된 그래프

그래프 탐색 알고리즘.
너비 우선 탐색(Breadth-First Search, BFS): 시작 정점에서 가까운 정점부터 탐색하는 방법으로 최단 경로를 찾는데 유용
깊이 우선 탐색(Depth-First Search, DFS): 시작 정점에서 최대한 깊게 탐색한 후 더 이상 갈 곳이 없으면 되돌아오는 방법으로 모든 경로를 탐색하거나 사이클을 찾는데 유용

그래프는 소셜 네트워크 연결 관계, 지도 앱의 경로 탐색, 대중교통 노선, 컴퓨터 네트워크 연결, 추천 시스템 등 다양한 분야에서 복잡한 연결 관계를 모델링하고 분석하는데 필수적입니다.