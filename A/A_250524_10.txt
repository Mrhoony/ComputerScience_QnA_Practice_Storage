std::vector 컨테이너에서 push_back() 또는 erase() 작업 시 이터레이터(Iterator) 무효화(Invalidation)가 언제 발생하며, 코딩 시 이를 어떻게 고려해야 하는지 설명하시오.
->
이터레이터 무효화는 컨테이너에 대한 특정 작업으로 인해 기존에 얻어 놓았던 이터레이터나 포인터, 참조가 더 이상 유효하지 않게 되는 현상을 말합니다.
push_back은 std::vector의 용량이 부족하여 새로운 원소를 추가할 공간이 없을 때 더 큰 메모리 블록을 새로 할당하고 기존 원소들을 새 메모리 블록으로 복사합니다. 이 과정에서 새로운 메모리 공간으로의 재할당이 발생하면 모든 기존 이터레이터, 포인터, 참조가 무효화됩니다.
erase는 std::vector에서 특정 원소를 제거합니다. 원소가 제거되면 제거된 원소 뒤의 모든 원소들이 당겨져서 메모리 공간을 메웁니다. 삭제된 원소 앞의 이터레이터들은 유효하나 삭제된 원소의 이터레이터와 그 이후의 모든 이터레이터는 무효화됩니다.
코딩 시 고려사항으로 루프 내에서 삽입/삭제를 지양하고 필요한 경우라도 무효화된 이터레이터를 사용하지 않도록 주의해야 합니다.

std::set과 std::unordered_set의 내부 구현 방식과 각각의 평균적인 탐색/삽입/삭제 시간 복잡도, 그리고 어떤 상황에 더 적합한지 비교하시오.
->
std::set은 균형 이진 탐색 트리, 일반적으로 RB트리로 구현됩니다. 요소들은 삽입될 때마다 정렬된 상태를 유지하도록 트리에 삽입됩니다. 삽입/삭제/탐색 시 O(logN)의 시간 복잡도를 가집니다. 정렬된 데이터가 필요하고 메모리 오버헤드를 감수하고 안정적인 성능이 중요하며 키에 대한 순서가 정의될 수 있을 때 적합합니다.
std::unordered_set은 해시 테이블로 구현됩니다. 키의 해시 값에 따라 버킷에 저장됩니다. 충돌이 발생하면 같은 버킷 내에서 연결 리스트 등으로 관리됩니다. 삽입/삭제/탐색은 O(1)의 시간 복잡도를 가집니다. 최악의 경우 O(N)의 시간 복잡도가 발생할 수 있습니다. 최대 성능이 필요하고 데이터의 정렬이 중요하지 않으며 적절한 해시 함수가 제공되고 == 연산이 정의될 수 있을 때 적합합니다.

C++에서 가상 함수(Virtual Function)의 공변 반환 타입(Covariant Return Types)은 무엇이며, 어떤 조건(예: 포인터 또는 참조 타입)에서 허용되는지 설명하시오.
->
일반적으로 오버라이드되는 가상함수는 기반 클래스의 가상함수와 동일한 반환 타입을 가져야 합니다. 그러나 공변 반환 타입은 이러한 규칙의 예외로 파생 클래스에서 가상 함수를 오버라이드 할 때 반환 타입이 기반 클래스 함수의 반환 타입과 다르더라도 허용되는 경우를 말합니다. 이때 파생 클래스의 반환 타입은 기반 클래스 함수의 반환 타입보다 더 구체적인 타입이어야 합니다.
포인터 또는 참조 타입이어야 하고 파생 클래스의 반환 타입은 기반 클래스의 반환 타입으로부터 파생된 타입이어야 하며 클래스의 타입이 일치하고 const/volatile 한정자가 일치해야야 공변 변환 타입이 허용됩니다.

3D 그래픽스에서 씬 그래프(Scene Graph)는 무엇이며, 복잡한 3D 오브젝트들의 계층적 변환(Hierarchical Transformation) 및 관리에 어떻게 사용되는지 설명하시오.
->
씬 그래프는 3D 그래픽스 애플리케이션에서 씬 내의 모든 오브젝트와 그들 사이의 관계를 계층적 트리 구조로 3D 씬의 복잡성을 관리하고 오브젝트 간의 계층적 관계와 변환을 효율적으로 처리하여 렌더링 효율성을 높이고 개발자가 씬을 쉽게 조작할 수 있도록 돕는 기본적인 데이터 구조입니다.

온라인 게임에서 네트워크 지연(Latency)을 보상하기 위한 기법 중 클라이언트 예측(Client-side Prediction)과 서버 롤백(Server Rollback)의 개념을 간략히 설명하고, 각각의 주요 장단점을 비교하시오.
->
클라이언트 예측은 서버의 응답을 기다리지 않고 즉시 입력의 결과를 로컬에서 예측하여 화면에 반영하는 기법입니다. 즉각적인 반응성과 부드러운 플레이 경험을 확보할 수 있지만 클라이언트의 예측이 실제 서버와 다를 경우 동기화되는 과정에서 캐릭터가 덜덜 떨리는 불쾌한 현상과 치팅이 발생할 수 있습니다.
서버 롤백은 즉발형 공격에 사용되며 공격 데이터를 받으면 서버의 게임 월드를 해당 클라이언트가 공격한 과거의 시간으로 일시적으로 롤백하여 공격을 재시뮬레이션하여 히트 여부를 판정합니다. 정확한 히트 판정을 확보할 수 있지만 피격자에게 불쾌감을 제공할 수 있습니다.

컴퓨터 운영체제에서 프로세스가 가질 수 있는 주요 상태(예: New, Ready, Running, Waiting, Terminated)들을 설명하고, 각 상태 전이가 발생하는 대표적인 상황을 간략히 설명하시오.
->
New는 프로세스가 막 생성되어 메모리에 로드되고 필요한 데이터 구조가 초기화되는 상태입니다. 초기화가 완료되면 Ready 상태로 전이됩니다.
Ready는 프로세스가 CPU를 할당받을 준비가 되어 있는 상태로 Ready Queue에서 대기합니다. 스케줄러가 Ready Queue에서 프로세스를 선택하여 CPU를 할당하면 Running 상태로 전이되고 인터럽트나 타임 슬라이스의 종료, 선점으로 인해 Running에서 Ready 상태로 전이됩니다.
Running은 프로세스가 CPU를 할당받아 명령어를 실행하고 있는 상태입니다. 작업을 요청하거나 특정 이벤트를 기다려야 할 때 스스로 CPU를 반납하고 Waiting 상태로 전이되고 프로세스가 할당된 모든 작업을 완료하거나 오류가 발생하여 비정상 종료되는 경우 Terminated 상태로 전이됩니다.
Waiting은 프로세스가 특정 이벤트를 대기하고 있는 상태입니다. 이벤트가 발생하면 Ready 상태로 전이됩니다.
Terminated는 프로세스가 실행을 완료하거나 강제 종료되어 모든 자원을 회수당하고 PCB가 제거된 비활성 상태입니다.

암호학적 해시 함수(Cryptographic Hash Function)와 일반적인 해시 테이블(Hash Table)에 사용되는 해시 함수의 주요 차이점(예: 충돌 저항성, 비가역성)을 설명하시오.
->
해시 함수는 임의의 길이의 데이터를 고정된 길이의 해시값으로 변환하는 함수입니다. 그러나 그 목적과 요구사항에 따라 암호학적 해시함수와 일반 해시 테이블용 해시함수는 큰 차이를 보입니다.
암호학적 해시함수는 데이터의 무결성 확인, 전자서명, 비밀번호 저장 등 보안 관련 용도로 사용됩니다. 주어진 해시값을 만족하는 입력값을 찾는 것이 계산적으로 불가능한 단방향 함수로 전상 저항성, 다른 입력값을 찾는 것이 계산적으로 불가능한 제2 전상 저항성, 서로 다른 두개의 입력값을 찾는 것이 계산적으로 불가능한 충돌 저항성, 빠른 계산, 예측 불가능성의 특징을 가집니다.
일반적인 해시 테이블의 해시 함수는 데이터를 효율적으로 저장하고 검색하기 위해 사용됩니다. 빠른 계산과 균일한 분포, 충돌 최소화, 비가역성 불필요의 특징을 가집니다.

언리얼 엔진에서 3D 위젯(Widget Component)은 무엇이며, 월드 공간에 UI를 배치하고 캐릭터나 카메라를 통해 해당 UI와 상호작용하는 데 어떻게 사용되는지 설명하시오.
->
3D 위젯은 UMG로 생성된 2D UI 위젯을 3D 월드 공간에 배치하고 렌더링할 수 있도록 해주는 컴포넌트입니다. 이는 플레이어의 HUD와 같이 2D 스크린에 오버레이되는 UI와 달리 게임 월드 내부에 존재하는 오브젝트처럼 보이도록 UI를 만들 때 사용됩니다.
월드 공간에 배치할 경우 액터에 WidgetComponent를 추가하고 UserWidget을 지정합니다. 렌더링 모드를 설정하고 Transform을 알맞게 조정해줍니다. 캐릭터나 카메라를 통해 키보드, 마우스, 게임패드, 가상 마우스 또는 레이캐스트 상호작용을 제공할 수 있습니다.

언리얼 엔진의 네트워크 복제(Replication) 과정에서 DOREPLIFETIME 매크로의 역할과, COND_ 접두사가 붙는 복제 조건자(Replication Condition, 예: COND_OwnerOnly, COND_SkipOwner)들이 무엇을 의미하며 왜 필요한지 설명하시오.
->
DOREPLIFETIME 매크로는 AActor 또는 UActorComponent의 클래스 내에서 어떤 UPROPERTY 변수를 네트워크를 통해 복제할 것인지 언리얼 엔진의 리플렉션 시스템에 등록하는 역할을 합니다.
COND_ 접두사가 붙는 복제 조건자들은 DOREPLIFETIME 매크로에서 추가 인자로 사용되어 복제될 변수가 어떤 조건에서 복제될지 제어할 수 있게 해줍니다. 대역폭 최적화 및 정보 은닉/보안, 게임 로직 제어를 위해 필요합니다.
COND_None은 기본값으로 항상 모든 관련 클라이언트에게 복제합니다.
COND_InitialOnly는 초기값만 복제 후 더이상 복제하지 않습니다.
COND_OwnerOnly는 해당 변수가 속한 액터의 소유자에게만 복제합니다.
SimulatedOnly나 AutonomousOnly와 같이 프록시 기반 복제도 가능하며 COND_Custom으로 직접 구현하여 제어할 수도 있습니다.

언리얼 엔진의 Game Features 플러그인(Plugin)은 무엇이며, 모듈식 게임 개발(Modular Game Development)과 코드/콘텐츠의 독립적인 배포 및 활성화에 어떤 이점을 제공하는지 설명하시오.
->
게임 피처 플러그인은 게임 컨텐츠와 코드의 모듈화 및 동적 로딩을 위한 강력한 시스템입니다. 게임의 특정 기능이나 컨텐츠 팩을 독립적인 단위로 분리, 개발 배포, 그리고 런타임에 활성화/비활성화할 수 있도록 설계되어 기능별 분리, 개발팀 간 독립성, 코드 종속성을 관리할 수 있어 독립적인 개발 및 관리가 가능해지고 DLC나 스트리밍 다운로드를 통해 유연한 배포 및 업데이트가 가능하며 런타임 동적 활성화 및 비활성화로 불필요한 리소스 로딩을 방지하고 버그가 발생할 경우 격리할 수 있는 이점을 제공합니다.
