C++20에 도입된 std::source_location은 무엇이며, 로깅(Logging)이나 디버깅 목적으로 현재 코드의 파일명, 라인 번호, 함수명 등을 얻는 데 어떻게 사용될 수 있는지 설명하시오.
->
클래스로 컴파일 시점에 현재 코드의 위치 정보를 캡처할 수 있도록 설계되었습니다. 런타임에 이 정보를 요청하는 함수를 호출하면 컴파일러가 해당 코드 위치 정보를 자동으로 채워 넣어 std::source_location 객체를 생성합니다.
자동화된 로그, 디버깅 어설션, 에로 보고 등의 목적으로 활용됩니다.
개발자가 수동으로 __FILE__, __LINE__, __FUNCTION__ 등 매크로를 일일이 타이핑할 필요 없이 안전하고 표준적인 방법으로 코드 위치 정보를 얻을 수 있습니다.

C++에서 std::chrono 라이브러리를 사용하여 코드 실행 시간이나 경과 시간을 측정하는 기본적인 방법과 다양한 시간 단위(예: std::milliseconds, std::nanoseconds)를 다루는 방법을 설명하시오.
->
std::chrono::high_resolution_clock::now()를 호출하여 시작 시간을 기록합니다.
측정하고자 하는 코드 블록을 실행합니다.
코드 블록 실행 후 다시 std::chrono::high_resolution_clock::now()를 호출하여 종료 시간을 기록합니다.
시작 시간과 종료 시간의 차이를 계산하여 std::chrono::duration 객체를 얻습니다.
std::chrono::duration_cast를 사용하여 원하는 시간 단위로 변환하고 값을 추출합니다.

std::atomic 변수 사용 시 std::memory_order_relaxed는 어떤 메모리 순서 보장(ordering guarantee)을 제공하며, 언제 이 순서가 적합하며 주의할 점은 무엇인지 설명하시오.
->
std::memory_order_relaxed는 std::atomic 연산 중 가장 약한 메모리 순서 보장을 제공합니다. 이는 단일 std::atomic 연산 자체의 원자성만 보장하며 다른 std::atomic 연산이나 일반 메모리 접근에 대한 어떤 순서 보장도 제공하지 않습니다. 컴파일러나 CPU는 memory_order_relaxed로 표시된 원자적 연산을 다른 메모리 접근과 자유롭게 재배열할 수 있습니다. 참조 카운팅, 통계 수집 등에 적합합니다.
대부분의 다중 스레드 동기화 시나리오에서는 memory_order_acquire, memory_order_release, memory_order_seq_cst와 같은 더 강력한 순서 보장이 필요합니다.
만약 relaxed 순서로 인해 원자적 연산과 비원자적 연산 또는 다른 원자적 연산 간의 예상치 못한 재배열이 발생하면 논리적 오류나 데이터 경쟁이 발생할 수 있습니다.
relaxed는 주로 성능 최적화를 위해 사용되지만 정확한 동기화 모델을 깊이 이해하지 않고 사용하면 디버깅하기 매우 어려운 버그를 유발할 수 있습니다.



3D 그래픽스에서 안티 에일리어싱(Anti-aliasing) 기법 중 MSAA(Multisample Anti-Aliasing)와 TAA(Temporal Anti-Aliasing)의 기본적인 원리와 각각의 장단점을 비교하시오.
->
안티 에일리어싱은 3D 그래픽스에서 오브젝트의 경계선이나 텍스처의 세부 표현에서 발생하는 계단 현상을 줄여 이미지를 부드럽게 만드는 기술입니다.
MSAA는 각 픽셀 내에서 여러개의 샘플을 취하여 색상과 깊이 정보를 저장합니다. 렌더링 시 픽셀의 각 샘플이 오브젝트 경계에 걸쳐 있으면 해당 샘플들의 색상을 평균하여 최종 픽셀 색상을 결정합니다. 깊이와 스텐실 버퍼는 각 샘플마다 저장되지만 픽셀 쉐이더는 픽셀당 한번만 실행됩니다.
정적 이미지에서 매우 깨끗하고 선명한 경계선을 제공합니다. 움직임이 없는 장면에 특히 효과적입니다. 구현이 비교적 간단합니다. 성능 오버헤드가 있고 쉐이더 내에서 발생하는 에일리어싱(투명한 텍스처, 알파 테스트된 지오메트리 등)은 해결하지 못하며 텍스처의 세부 사항이 에일리어싱을 적용하지 않아 텍스처가 흐릿해 보일 수 있습니다.
TAA는 여러 프레임에 걸쳐 렌더링된 이미지를 시각적으로 재투영하고 블렌딩하여 에일리어싱을 줄입니다. 매 프레임마다 카메라를 미세하게 흔들거나 이전 프레임의 렌더링 결과와 현재 프레임의 결과를 혼합하여 최종 이미지를 만듭니다. 지오메트리 에일리어싱, 쉐이더 에일리어싱, 투명 텍스처, 서브픽셀 에일리어싱 등 대부분의 에일리어싱 문제를 해결합니다. MSAA에 비해 픽셀당 계산 비용이 성능 효율적입니다. 빠른 움직임이 있는 오브젝트나 카메라 움직임 시 잔상이 남는 현상(고스팅 현상), 전반적으로 이미지가 약간 흐릿해 보임(텍스처 블러링), MSAA보다 구현이 복잡하고 모션 벡터 생성이 필요합니다.
MSAA는 공간적 접근, TAA는 시간적 접근입니다. TAA가 더 보편적으로 사용되고 MSAA는 주로 성능 여유가 있는 정적인 장면이나 특수 효과에 사용됩니다.

온라인 게임에서 "클라이언트 측 예측(Client-Side Prediction)"과 "서버 보정(Server Reconciliation)"은 무엇이며, 네트워크 지연(Latency) 환경에서 플레이어 입력의 반응성과 게임 상태의 정확성을 개선하는 데 어떻게 함께 작동하는지 설명하시오.
->
네트워크 지연 환경은 온라인 게임에서 클라이언트의 입력이 서버에 도달하고 서버의 응답이 클라이언트에 돌아오는데 걸리는 시간 지연을 의미합니다. 이 지연은 플레이어 경험을 저해하는 주된 원인입니다.
클라이언트 예측은 클라이언트가 플레이어의 입력을 즉시 적용될 것이라고 가정하고 서버의 응답을 기다리지 않고 자신의 게임 상태를 미리 업데이트하여 렌더링하는 기술입니다. 네트워크 지연에도 부룩하고 플레이어 입력에 대한 즉각적인 반응성을 제공하여 부드러운 플레이 경험을 제공합니다.
서버 보정은 클라이언트의 예측 결과와 서버의 최종적이고 권위 있는(Authoritative) 게임 상태를 비교하여 클라이언트의 상태를 보정하거나 동기화하는 과정입니다. 서버는 클라이언트의 입력으로 인해 발생한 자신의 계산 결과를 클라이언트에게 전송하고 클라이언트는 이 결과를 받아 자신의 예측이 틀렸다면 상태를 수정합니다. 서버가 게임의 최종 권한을 가지므로 게임 상태의 정확성과 공정성을 보장합니다. 클라이언트의 예측 오류나 치트 시도를 서버가 감지하고 수정할 수 있습니다.
두 기술이 함께 작동하여 네트워크 지연이 높은 환경에서도 플레이어에게는 즉각적인 반응성을 제공하면서 서버가 최종 권한을 가지므로 치트 방지 및 게임 상태의 일관성을 유지할 수 있습니다.
클라이언트: 플레이어 입력 발생 시 즉시 자신의 게임 상태를 예측하고 렌더링합니다. 동시에 해당 입력을 서버로 보냅니다.
서버: 클라이언트의 입력을 받아 실제 게임 로직을 실행하고 변경된 게임 상태를 클라이언트에게 복제합니다.
클라이언트: 서버로부터 업데이트된 게임 상태를 수신합니다. 자신이 예측했던 상태와 서버가 보내준 실제 상태를 비교합니다.
클라이언트 보정: 만약 예측이 틀렸다면 클라이언트는 서버의 정확한 상태로 자신의 게임 상태를 되돌리고 그 시점부터 지금까지의 모든 입력들을 다시 재생하여 상태를 재계산합니다. 이 과정에서 약간의 시각적 덜컥임이 발생할 수 있지만 이는 정확성을 유지하기 위함입니다.

CPU에서 TLB(Translation Lookaside Buffer)는 무엇이며, 가상 메모리 주소 변환 과정에서 TLB 히트(Hit)와 TLB 미스(Miss)가 시스템 성능에 어떤 영향을 미치는지 설명하시오.
->
TLB는 CPU 내부에 있는 작은 캐시 메모리로 가상 메모리 주소를 물리 메모리 주소로 변환하는데 필요한 페이지 테이블 엔트리의 최근 사용 내역을 저장합니다. TLB는 가상 메모리 시스템의 핵심 최적화 요소로 TLB 히트율을 높이는 것이 시스템 성능에 매우 중요합니다.
CPU가 어떤 가상 메모리 주소에 접근하려고 합니다.
먼저 TLB에서 해당 가상 주소에 대한 물리 주소 매핑 정보(PTE)를 찾아봅니다.
TLB 히트인 경우 매우 빠르게 주소 변환이 완료됩니다.
TLB 미스인 경우 CPU는 메인 메모리에 있는 페이지 테이블을 직접 참조해야 합니다. 이 과정은 여러 단계의 메모리 접근을 수반하며 디스크 I/O가 발생할 수도 있어 큰 시간 지연이 발생하고 전반적인 시스템 성능이 크게 저하됩니다.



언리얼 엔진에서 FName, FString, FText 세 가지 문자열 타입의 주된 차이점과 각각의 메모리 특성 및 사용 목적(예: 에셋 이름, 동적 문자열, UI 텍스트)을 설명하시오.
->
FName은 불변의 문자열 방식입니다. 생성되면 변경할 수 없으며 내부적으로 문자열 테이블에 저장되고 해시 값으로 관리됩니다. 동일한 FName은 메모리에서 단 하나의 인스턴스만 존재합니다. 효율적인 메모리 사용과 빠른 비교 속도를 가집니다. 에셋 이름, 소켓 이름, 본 이름, 노드 이름, 데이터 테이블의 행 이름, 프로퍼티 이름 등 게임 내에서 변경되지 않고 고유한 식별자로 사용될 때 주로 사용됩니다.
FString은 가변 문자열입니다. 동적으로 문자열을 생성, 수정, 연결할 수 있습니다. std::string과 유사한 기능을 제공합니다. 동적으로 메모리를 할당하고 해제하므로 FName보다 메모리 오버헤드가 크고 문자열 연산 시 추가 비용이 발생할 수 있습니다. 동적으로 변경될 수 있는 모든 문자열 데이터에 사용됩니다.
FText는 지역화(Localization) 가능한 문자열입니다. 게임 내 UI 텍스트나 사용자에게 표시되는 모든 문자열에 사용되며 런타임에 게임 언어 설정에 따라 자동으로 다른 언어로 표시될 수 있습니다. FText는 지역화된 문자열의 원본 문자열, 네임스페이스, 키 정보를 포함합니다. FString과 유사하게 동적 할당되지만 지역화 데이터를 위한 추가적인 오버헤드를 가집니다. FText 객체 자체는 가볍지만 실제 지역화된 문자열 데이터는 매핑 테이블에 저장됩니다. UI, HUD, 툴팁, 메뉴 텍스트 등 플레이어에게 직접 표시되는 문자열에 사용됩니다.

언리얼 엔진 애니메이션 시스템에서 "동기화 그룹(Sync Group)"은 무엇이며, 여러 캐릭터의 애니메이션(예: 협동 동작, 연출 시퀀스)을 정교하게 동기화하고 블렌딩하는 데 어떻게 사용될 수 있는지 설명하시오.
->
여러 애니메이션 재생을 특정 기준에 맞춰 동기화하여 독립적으로 재생되던 애니메이션들이 마치 하나의 큰 애니메이션처럼 보이도록 하는 UE 애니메이션 시스템의 기능입니다. 협동 동작, 연출 시퀀스, 블렌딩 등 여러 캐릭터/애니메이션 정교환 동기화 및 블렌딩에 활용됩니다.

언리얼 엔진 AI 시스템의 "AI Perception" 컴포넌트에서 커스텀 센스(Custom Sense)를 구현하는 기본적인 방법과 이를 통해 게임에 특화된 인지(예: 특정 오브젝트의 사운드 감지, 특수 효과 시각 감지)를 추가하는 방법을 설명하시오.
->
AIPerception 컴포넌트는 UE AI 시스템에서 AI가 환경을 인지하고 정보를 수집하는데 사용되는 컴포넌트입니다. 시각, 청각, 냄새, 손상 등 다양한 내장 센스를 제공합니다.
UAISense를 상속받는 새로운 C++ 클래스를 생성합니다.
새로 만든 센스 클래스에서 AI가 인지해야 할 정보를 정의하고 해당 정보를 전달할 FAISenseEvent 파생 구조체를 정의합니다.
OnRegister 또는 OnTick 함수 등에서 게임 로직에 따라 AAIController의 UGenericTeamAgentComponent에서 RegisterPerceptionSource() 또는 ReportEvent() 함수를 호출하여 센스 이벤트를 발생시킵니다. 이 이벤트는 AIPerception 시스템으로 전달됩니다.
OnPerceptionUpdated 델리게이트를 통해 센스 이벤트를 받아 처리하는 로직을 구현합니다.

언리얼 엔진 네트워크 복제에서 DOREPLIFETIME_ACTIVE_OVERRIDE 매크로는 무엇이며, 액터의 특정 상태(예: 활성화 여부, 시야 내 존재 여부)에 따라 프로퍼티 복제 여부를 동적으로 제어하고 네트워크 대역폭을 최적화하는 데 어떻게 사용되는지 설명하시오.
->
UE 네트워크 복제 시스템에서 특정 UProperty의 복제 여부를 런타임에 동적으로 제어할 수 있도록 해주는 매크로입니다. DOREPLIFETIME이 항상 복제할 프로퍼티를 등록한다면 이 매크로는 특정 조건에 따라 복제할지 말지를 결정할 수 있게 합니다. 이 매크로는 DOREPLIFETIME과 함께 bool 타입의 Condition 파라미터를 추가로 받습니다. 플레이어의 인벤토리 내에 있는 아이템 중 현재 장착되어 활성화된 아이템의 프로퍼티만 복제하고 비활성화된 아이템의 프로퍼티는 복제하지 않도록 하는 등의 경우에 활용될 수 있습니다. 네트워크 대역폭을 최적화하고 유연한 복제 제어를 제공합니다.
