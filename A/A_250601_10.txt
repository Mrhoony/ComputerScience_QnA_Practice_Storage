C++에서 가상 함수(Virtual Function)는 무엇이며, 객체 지향 프로그래밍의 어떤 핵심 원리(예: 다형성)를 구현하는 데 사용되는지 설명하시오.
->
virtual 키워드로 선언된 함수입니다. 파생 클래스에서 이 함수를 재정의(override)할 수 있습니다. 런타임에 객체의 실제 타입에 따라 호출될 함수가 결정되도록 하여 기본 클래스 포인터/참조를 통해 파생 클래스 객체를 조작할 때 해당 파생 클래스의 재정의된 함수가 호출되도록 합니다. 이를 통해 코드의 유연성, 확장성을 높입니다.

C++ 컴파일러는 가상 함수를 내부적으로 어떻게 구현하는지, 특히 가상 함수 테이블(V-Table)과 가상 함수 포인터(V-Ptr)의 역할을 중심으로 설명하시오.
->
V-Table은 가상 함수를 하나라도 가진 클래스(또는 그 파생 클래스)에 대해 컴파일러가 생성하는 함수 포인터들의 배열입니다. 이 테이블에는 해당 클래스의 가상 함수들의 실제 주소(재정의된 경우 파생 클래스 함수의 주소)가 저장됩니다.
V-Ptr은 가상 함수를 가진 클래스의 객체 내부에서 추가되는 숨겨진 포인터입니다. 이 포인터는 해당 객체의 클래스에 해당하는 V-Table을 가리킵니다.
가상 함수 호출 시 V-Ptr을 통해 V-Table에 접근하고 V-Table 내의 특정 오프셋에 있는 함수 포인터를 찾아 해당 함수를 호출합니다.

파생 클래스에서 기본 클래스의 가상 함수를 재정의(Override)할 때 override 키워드를 사용하는 주된 목적은 무엇이며, 이 키워드를 생략했을 때 발생할 수 있는 잠재적인 문제점을 설명하시오.
->
파생 클래스에서 기본 클래스의 가상 함수를 정확히 재정의했음을 컴파일러에게 명시적으로 알리는 역할을 합니다.
override 키워드 없이 재정의하려던 함수 이름에 오타가 있거나 파라미터 목록이 기본 클래스 함수와 정확히 일치하지 않을 경우 컴파일러는 이를 재정의가 아닌 새로운 함수로 간주합니다. 이 경우 다형성이 작동하지 않아 기본 클래스 포인터/참조로 호출 시 의도와 다르게 기본 클래스 함수가 호출되는 심각한 논리적 오류가 발생할 수 있습니다. override는 이러한 실수를 컴파일 시점에 즉시 잡아줍니다.

순수 가상 함수(Pure Virtual Function)는 무엇이며, 이러한 함수를 포함하는 추상 클래스(Abstract Class)의 특징과 인스턴스화 가능 여부에 대해 설명하시오.
->
= 0을 붙여 선언된 가상 함수입니다. 해당 함수에 대한 구현을 기본 클래스에서는 제공하지 않으며 파생 클래스에서 반드시 재정의해야 함을 강제합니다.
추상 클래스는 순수 가상 함수를 하나라도 포함하는 클래스입니다. 이 클래스는 불완전한 클래스이므로 직접 객체를 생성할 수 없습니다. 반드시 모든 순수 가상 함수를 재정의한 파생 클래스만 객체를 생성할 수 있습니다.

다형적(Polymorphic) 클래스 계층 구조에서 기본 클래스의 소멸자(Destructor)를 virtual로 선언하는 것이 왜 매우 중요한지 설명하고, 만약 virtual로 선언하지 않았을 때 발생할 수 있는 문제를 코드 예시와 함께 설명하시오.
->
기본 클래스 포인터를 통해 파생 클래스 객체를 delete할 때 파생 클래스의 소멸자가 올바르게 호출되도록 보장하기 위함입니다.
virtual이 아닌 경우에 부분 소멸이 발생할 수 있습니다. 파생 클래스에서 할당된 메모리나 리소스가 해제되지 않아 메모리 누수나 미정의 동작을 유발합니다. virtual 소멸자는 런타임에 실제 객체의 타입(파생 클래스) 소멸자를 찾아 호출하도록 보장합니다.

생성자(Constructor)와 소멸자(Destructor) 내에서 가상 함수를 호출할 수 있는지 설명하고, 만약 가능하다면 어떤 동작을 하며, 그 결과가 다형성과 관련하여 왜 주의해야 하는지 설명하시오.
->
가능하지만 다형성 관점에서 매우 주의해야 합니다.
객체가 아직 완전히 생성되지 않은 상태이므로 생성자 내에서 가상 함수를 호출하면 해당 생성자가 속한 클래스의 버전만 호출됩니다. 파생 클래스의 재정의된 버전은 호출되지 않습니다.
소멸자 내에서 가상 함수를 호출하면 해당 소멸자가 속한 클래스의 버전만 호출됩니다. 파생 클래스의 소멸자가 이미 호출되어 파생 클래스 부분이 소멸된 상태이므로 더 이상 파생 클래스의 재정의된 함수를 호출할 수 없습니다.
생성/소멸 단계에서는 객체가 해당 클래스 타입의 불변식을 만족하지 못할 수 있고 아직 초기화되지 않은 파생 클래스의 멤버에 접근하려는 시도가 발생할 수 있어 안전하지 않으므로 일반적으로 생성자/소멸자 내에서 가상 함수 호출은 피해야 합니다.

가상 함수의 공변 반환 타입(Covariant Return Types)은 무엇이며, C++에서 기본 클래스의 가상 함수를 재정의할 때 어떤 조건 하에서만 허용되는지 간단한 예시와 함께 설명하시오.
->
기본 클래스의 가상 함수를 재정의할 때 재정의된 파생 클래스 함수의 반환 타입이 기본 클래스 함수의 반환타입의 파생 타입이 될 수 있도록 허용하는 C++ 기능입니다.
반환 타입이 포인터 또는 참조여야하고 재정의된 함수의 반환 타입은 기본 함수 반환 타입의 파생 클래스여야하며 두 함수의 파라미터 목록은 정확히 일치해야 합니다.

가상 함수 호출은 비가상 함수(non-virtual function) 호출에 비해 어떤 성능적 오버헤드를 가지는지 설명하고, 이러한 오버헤드가 발생하는 주된 원인을 (예: V-Table 룩업, 캐시 효율성) 설명하시오.
->
비가상 함수 호출에 비해 약간의 성능 오버헤드가 있습니다.
V-Table 룩업이라는 가상 함수 호출이 V-Ptr을 통해 V-Table에 접근하고 특정 오프셋에서 함수 포인터를 찾는 간접 호출 과정이 필요합니다. 비가상 함수는 컴파일 시점에 호출할 함수 주소가 결정됩니다.
캐시 효율성이 저하되는데 V-Table 룩업은 메모리에 흩어져 있는 V-Table에 접근해야 하므로 캐시 미스 발생 가능성이 높습니다. 또한 컴파일러가 호출 대상을 미리 알 수 없어 인라이닝과 같은 강력한 최적화를 수행하기 어렵습니다.
예측 실패를 동반할 수 있는데 현대 CPU의 분기 예측 최적화에 불리할 수 있습니다. 간접 호출은 다음에 실행될 코드를 예측하기 어렵기 떄문입니다.
현대 컴파일러와 CPU는 이러한 오버헤드를 최소화하기 위한 다양한 최적화(예: 데가상화)를 수행하며 대부분의 경우 이 오버헤드는 미미하여 다형성의 이점에 비하면 감수할 만합니다.

기본 클래스 포인터를 통해 파생 클래스 객체를 참조할 때, 가상 함수가 아닌 비가상 함수(non-virtual function)를 호출하면 어떤 일이 발생하는지 ("함수 숨김" 개념과 함께) 설명하시오.
->
파생 클래스에 기본 클래스와 동일한 이름의 비가상 함수가 있지만 파라미터나 반환 타입이 다르거나 override, virtual 키워드가 없는 경우 함수 숨김이 발생합니다.
파생 클래스의 함수는 기본 클래스의 동일한 이름의 함수를 숨깁니다. 기본 클래스 포인터/참조를 통해 호출하면 항상 기본 클래스의 함수가 호출되며 런타임 다형성이 작동하지 않습니다.
파생 클래스 객체를 직접 통해 호출하거나 파생 클래스 포인터/참조를 통해서만 파생 클래스의 숨겨진 함수에 접근할 수 있습니다.

final 키워드는 가상 함수와 클래스에 각각 어떤 용도로 사용되며, 상속 계층 구조에서 특정 함수의 재정의 또는 클래스의 상속을 제한하는 데 어떻게 활용되는지 설명하시오.
->
가상 함수 선언/정의에 접미사로 붙여 해당 함수가 더 이상 파생 클래스에서 재정의될 수 없도록 제한합니다. 특정 가상 함수의 최종 구현을 강제하고 라이브러리 개발 시 특정 기능의 변경을 막아 안정성을 확보하거나 의도치 않은 재정의로 인한 버그를 방지합니다.
클래스에 사용할 경우 해당 클래스가 더 이상 파생될 수 없도록 제한합니다. 클래스 계층 구조의 끝을 명시하고 특정 클래스가 최종적인 구현임을 나타냅니다. 또한 불필요한 상속을 막아 클래스 설계의 의도를 명확히 하고 경우에 따라 컴파일러 최적화에 도움을 줄 수 있습니다.
