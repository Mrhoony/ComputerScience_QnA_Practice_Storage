C++에서 std::lock_guard와 std::unique_lock의 차이점을 설명하고, 각각 어떤 상황(예: 스코프 기반 락, 조건 변수와 함께 사용)에 더 적합한지 설명하시오.
->
std::lock_guard는 스코프 기반 락(RAII)을 위한 간단한 뮤택스 래퍼입니다. 생성 시 뮤텍스를 잠그고 소멸 시 자동으로 뮤텍스를 해제합니다. 사용이 간편하고 오버헤드가 적습니다. 뮤텍스의 잠금 및 해제 시점이 스코프의 시작과 끝에 명확하게 일치하고 중간에 락을 해제하거나 소유권을 이전할 필요가 없는 경우 적합합니다.
std::unique_lock은 lock_guard보다 더 유연한 뮤텍스 래퍼입니다. 락의 소유권을 이전하거나 락을 수동으로 해제하고 다시 잠글 수 있으며 비블로킹 락(try_lock)이나 시간 제한 락(timed_lock) 등 다양한 기능을 제공합니다. std::condition_variable::wait() 함수는 std::unique_lock을 인자로 받아 특정 조건이 만족될 때까지 락을 자동으로 해제하고 대기했다가 깨어나면 다시 락을 얻는 방식으로 작동합니다. 스코프 내에서 락을 일시적으로 해제하거나 여러 뮤텍스를 동시에 잠글 때, 락 획득 실패 시 다른 작업을 수행해야 할 때 적합합니다.

C++에서 복사 생성자(Copy Constructor)와 이동 생성자(Move Constructor)가 각각 호출되는 전형적인 시나리오를 설명하시오.
->
복사 생성자는 기존 객체와 동일한 내용을 가진 새로운 객체를 생성하고 싶을 때 호출됩니다. 값으로 객체를 전달/반환하거나 명시적 복사와 컨테이너 저장 시 호출됩니다.
이동 생성자는 임시 객체의 자원을 훔쳐와서 새로운 객체를 효율적으로 초기화하고 싶을 때 호출됩니다. 원본 객체는 유효하지만 상태가 변경될 수 있습니다. 값으로 임시 객체 반환, std::move 사용, 컨테이너에 emplace_back()으로 인자 전달 시 호출됩니다.

템플릿 함수에서 완벽한 전달(Perfect Forwarding)을 위해 std::forward가 사용되는 이유와 그 동작 방식(즉, 인자의 값 범주 유지)을 설명하시오.
->
완벽한 전달은 템플릿 함수가 인자를 다른 함수로 전달할 때 원본 인자의 값 범주와 const/volatile 한정자를 그대로 유지하여 전달하는 것을 의미합니다.
일반적인 참조 전달은 인자의 값 범주 정보를 잃습니다. 특히 rvalue 참조로 인자를 받더라도 함수 내부에서는 해당 인자가 lvalue로 취급됩니다. std::forward는 타입 추론 규칙과 결합하여 인자가 lvalue로 전달되었으면 lvalue 참조로 rvalue로 전달되었으면 rvalue 참조로 정확하게 전달될 수 있도록 합니다. 이를 통해 원본 객체의 복사 또는 이동을 정확하게 제어할 수 있습니다.

3D 그래픽스에서 뎁스 버퍼(Depth Buffer)의 역할은 무엇이며, Z-파이팅(Z-Fighting) 현상이 발생하는 주된 원인과 이를 해결하기 위한 일반적인 방법(예: 뎁스 오프셋)을 설명하시오.
->
뎁스 버퍼는 3D 장면의 각 픽셀에 대해 깊이를 저장하는 버퍼입니다. 렌더링 시 새로운 픽셀을 그릴 때 해당 픽셀의 깊이가 뎁스 버퍼에 저장된 값보다 작으면 픽셀을 그리고 뎁스 버퍼를 업데이트합니다. 이를 통해 오브젝트의 올바른 가시성을 결정합니다.
Z-파이팅 현상은 두개 이상의 오브젝트가 매우 가깝게 위치하거나 동일한 평면에 놓여 있을 때 발생합니다. 부동 소수점 정밀도 한계로 인해 GPU가 어떤 오브젝트가 더 가까운지 정확히 판단하지 못하고 렌더링 시점에 두 오브젝트가 번갈아가며 깜빡이는 현상입니다.
뎁스 오프셋은 두 오브젝트 중 하나를 미세하게 카메라에서 멀리 밀어내는 효과를 줍니다. 렌더링 파이프라인에서 픽셀의 깊이 값에 작은 값을 더하거나 빼서 뎁스 버퍼에 쓰기 전에 깊이를 조절합니다. 모델링 단계에서 너무 겹치거나 너무 가까운 오브젝트를 피하고 충분한 간격을 두는 것이 가장 근본적인 해결책입니다. 16비트보다 24비트 또는 32비트 뎁스 버퍼를 사용하여 깊이 값의 정밀도를 높입니다.

온라인 게임 개발에서 "스레드 풀(Thread Pool)"의 개념은 무엇이며, 동시성 작업(Concurrent Tasks)을 효율적으로 관리하고 스레드 생성/소멸 오버헤드를 줄이는 데 어떤 이점을 제공하는지 설명하시오.
->
스레드 풀은 미리 생성된 작업자 스레드들의 집합을 의미합니다. 동시성으로 처리해야 할 작업이 발생하면 새로운 스레드를 생성하는 대신 스레드 풀에 있는 유휴 스레드를 재사용하여 작업을 할당하고 실행합니다.
스레드를 생성하고 파괴하는 과정은 상당한 시스템 자원과 시간을 소모합니다. 스레드 풀은 이 오버헤드를 줄여 전반적인 성능을 향상시킵니다. 미리 정해진 수의 스레드만 유지하므로 시스템의 CPU 코어 수에 맞게 스레드 수를 제한하여 과도한 컨텍스트 스위칭을 방지하고 자원 고갈을 막습니다. 작업 큐를 통해 작업을 관리하고 스레드에 분배하므로 복잡한 동시성 작업을 체계적으로 처리할 수 있습니다.

네트워크 보안에서 사용자 인증(Authentication)과 권한 부여(Authorization)는 어떤 차이를 가지며, 각각 어떤 목적을 가지는지 설명하시오.
->
사용자 인증은 사용자가 누구인지를 확인하는 과정입니다. 시스템에 접근하려는 주체의 신원을 검증합니다. 올바른 사용자만이 시스템에 접근할 수 있도록 보장하고 위조된 신분으로 인한 불법적인 접근을 방지합니다. 로그인 시 아이디/비밀번호 입력, 생체 인식, OTP 등이 사용자 인증에 해당합니다.
권한 부여는 인증된 사용자가 무엇을 할 수 있는지를 결정하는 과정입니다. 특정 리소스나 기능에 대해 사용자가 어떤 종류의 접근을 가질 수 있는지 허용 여부를 결정합니다. 인증된 사용자가 자신의 권한 범위 내에서만 작업을 수행하도록 제한하여 데이터 무결성과 보안을 유지합니다. 일반 사용자는 게시글 읽기/쓰기만 가능, 관리자는 게시글 삭제 권한을 가짐, 게임에서 특정 레벨의 플레이어만 특정 지역에 접근 가능 등이 권한 부여에 해당합니다.

언리얼 엔진 AI 시스템에서 비헤이비어 트리(Behavior Tree)의 Task, Service, Decorator 간의 상호작용과 각 요소가 비헤이비어 트리 실행 흐름 및 AI의 의사 결정에 어떻게 영향을 미치는지 설명하시오.
->
BehaviorTree는 AI의 의사 결정과 행동을 계층적이고 시각적으로 표현하는 트리 구조입니다.
Task는 BehaviorTree의 가장 말단 노드입니다. AI가 실제로 수행하는 단일 행동을 정의합니다. Task가 성공/실패를 반환하면 트리는 상위 노드로 결과를 전달합니다. Service는 트리의 특정 분기 또는 노드에 주기적으로 붙어서 실행되는 노드입니다. 주로 Blackboard에 정보를 업데이트하거나 주변 환경을 감지하는 등 지속적인 감시 또는 데이터 업데이트 역할을 합니다. Service의 결과가 트리의 흐름에 직접적인 영향을 주지는 않지만 Task나 Decorator가 사용할 정보를 제공합니다. Decorator는 Task나 다른 복합 노드에 붙어서 해당 노드의 실행 조건을 제어하는 노드입니다. 조건이 참이면 노드를 실행하고 거짓이면 노드를 스킵하거나 실패로 간주합니다. Decorator는 AI의 의사 결정 로직에 직접적인 영향을 미칩니다.
BehaviorTree는 Root부터 시작하여 조건을 만족하는 분기를 따라 Task를 실행하고 Service는 백그라운드에서 지속적으로 정보를 제공하여 AI가 복잡하고 동적인 환경에서 상황에 맞게 의사결정하고 행동하도록 합니다.

언리얼 엔진에서 내비게이션 메시(Navigation Mesh, NavMesh)는 어떻게 생성되며, 런타임에 동적으로 변경되거나 파괴 가능한 환경(예: 파괴 가능한 벽)에서는 어떻게 NavMesh를 업데이트하고 AI가 경로를 재계산하도록 할 수 있는지 설명하시오.
->
UE는 레벨의 지오메트리를 기반으로 AI가 이동할 수 있는 영역을 나타내는 3D 네비게이션 메시를 자동으로 생성합니다. 에디터에서 Build Paths를 통해 생성하거나 런타임에 동적으로 생성할 수도 있습니다. NavMeshBoundsVolume을 레벨에 배치하여 NavMesh를 생성할 영역을 지정합니다.
OnNavigationBoundsAdded(), OnNavigationBoundsRemoved(), AddDynamicObstacle(), UpdateNavdata(), RebuildAll(), FindPathToLocationSynchronously(), RequestPath()와 같은 함수를 호출하여 변경사항을 네비게이션 시스템에 알리고 움직이는 오브젝트를 판별하며 NavMesh를 재빌드하고 새로운 환경에 맞춰 경로를 재계산하도록 요청할 수 있습니다.

언리얼 엔진의 Gameplay Tags는 무엇이며, 액터나 에셋을 분류하고, 특정 상태를 표현하며, 필터링하는 데 어떻게 사용될 수 있는지 구체적인 예시와 함께 설명하시오.
->
UE에서 계층적이고 확장 가능한 문자열 태그 시스템입니다. FGameplayTag라는 구조체를 사용하여 정의되며 GameplayTagContainer에 여러 태그를 저장할 수 있습니다.
액터/에셋 분류, 특정 상태 표현, 필터링 등에 사용되며 문자열 기반의 유연한 태그 시스템을 제공하여 Enum이나 하드코딩된 문자열 대신 디자이너 친화적이고 확장 가능한 데이터 기반 시스템을 구축할 수 있게 합니다.

언리얼 엔진 5(UE5)의 "Game Feature Plugins"는 무엇이며, 모듈식 게임 개발(Modular Game Development)과 게임 콘텐츠를 유연하게 관리하고 배포하는 데 어떤 이점을 제공하는지 설명하시오.
->
UE5에 도입된 모듈식 게임 개발을 위한 플러그인 시스템입니다. 게임의 특정 기능이나 컨텐츠 세트를 독립적인 GameFeature Plugin으로 패키징하고 관리할 수 있게 합니다. 이 플러그인들은 런타임에 동적으로 로드 및 언로드될 수 있습니다.
게임 전체를 하나의 거대한 프로젝트로 만드는 대신 각 기능을 독립적인 단위로 개발하고 테스트할 수 있습니다. 대규모 팀 작업 시 협업 효율성을 높입니다. 게임 전체를 재배포하지 않고도 특정 게임 기능 플러그인만 업데이트하거나 새로운 컨텐츠를 DLC 형태로 추가할 수 있습니다. 특정 기능이 필요없는 빌드에서는 해당 플러그인을 제외하여 빌드 크기를 줄일 수 있습니다. 필요할 때만 플러그인을 로드하고 사용하지 않을 때는 언로드하여 메모리 사용량을 최적화할 수 있습니다. 각 플러그인이 다른 플러그인에 의존성을 가질 수 있도록 지원하여 복잡한 프로젝트 구조를 효율적으로 관리합니다.
(모듈식 게임 개발, 컨텐츠 관리 및 배포 유연성, 부분 업데이트/DLC, 게임 빌드 크기 최적화, 런타임 로딩/언로딩, 플러그인 간 의존성 관리)