C++에서 함수 포인터(Function Pointer)와 std::function의 차이점을 설명하고, std::function 사용 시 장점에 대해 설명하시오.
->
함수 포인터는 특정 함수 시그니처를 가진 함수의 메모리 주소를 저장하는 포인터입니다. 저장할 수 있는 대상이 함수로 제한됩니다. 람다 함수나 함수 객체는 직접 저장할 수 없습니다(캡처가 없는 람다 예외).
std::function은 functional 헤더에 정의된 클래스 템플릿으로 호출 가능한 모든 객체를 저장할 수 있는 래퍼입니다. 함수 포인터 뿐만 아니라 함수 객체, 캡처가 있는 람다 함수, std::bind의 결과 등을 저장할 수 있습니다. std::function 객체는 일반 함수처럼 () 연산자로 호출할 수 있는 통일된 인터페이스를 제공합니다.
std::function 사용시 다양한 호출 가능 객체의 저장이 가능하고 컴파일 시점에 타입 오류를 확인할 수 있고 캡처가 있는 람다나 함수 객체의 내부 상태를 함께 저장할 수 있습니다.

C++17에 도입된 std::optional, std::variant, std::any 중 std::optional의 사용 목적과 이점을 설명하시오.
->
std::optional은 <optional> 헤더에 정의된 클래스 템플릿입니다. 있거나 없거나 할 수 있는 불분명한 값을 안전하고 명시적으로 표현하기 위해 사용합니다. 지정된 타입의 값을 가질 수도 있고 아무런 값도 가지지 않은 empty 상태일 수도 있습니다.
함수의 반환 값이 유효한 값을 찾지 못하거나 함수 인자가 선택적임을 표현할 경우, 특정 상황에서만 값이 존재하는 멤버 변수의 표현이나 nullptr이나 특별한 센티넬 값(-1, "" 등)을 사용하여 값이 없음을 표현하는 방식을 대체합니다.
코드의 의도를 명확하게 하고 가독성을 높이며 타입 안전성이 높고 std::unique_ptr 등으로 선택적 객체를 표현하는 것 보다 오버헤드가 적습니다.

C++에서 placement new 연산자는 언제, 왜 사용하며 일반 new와 어떤 차이가 있는지 설명하시오.
->
placement new 연산자는 미리 확보된 메모리 공간에 객체를 생성하는 연산자입니다. new (pointer) Type(arg) 형태로 사용하며 메모리 할당을 직접 수행하지 않습니다.
일반 new는 운영체제로부터 동적 메모리를 할당받아 메모리에 객체의 생성자를 호출하여 객체를 생성합니다. placement new는 메모리 할당 단계를 건너뛰고 이미 준비된 특정 메모리 주소(pointer)에 객체의 생성자만 호출하여 객체를 생성합니다.
커스텀 메모리 관리가 필요한 경우, 메모리의 할당/해제와 객체의 생성/소멸을 분리해야 할 경우, 이미 존재하는 메모리에 객체를 생성해야 할 경우에 사용합니다. 메모리 블록이 해제되더라도 소멸자가 자동으로 호출되지 않아 명시적으로 소멸자를 호출해야 합니다.

void* ptr1 = new(sizeof(int));
int* ptr2 = new(ptr1) int(10);

C++에서 식별자(Identifier)의 내부 연결(Internal Linkage)과 외부 연결(External Linkage)의 차이점을 설명하시오.
->
C++ 프로그램은 하나 이상의 소스 파일로 구성되며 각 소스 파일은 컴파일되어 독립적인 번역 단위(Translation Unit)를 형성합니다. 링크 과정에서 이러한 번역 단위들이 합쳐져 최종 실행 파일이 됩니다. 연결은 한 번역 단위에서 선언된 이름(식별자)이 다른 번역 단위에서 동일한 엔티티(변수, 함수 등)를 참조할 수 있는지 여부를 결정합니다.
내부 연결은 식별자가 선언된 번역 단위 내부에서만 유효하며 접근할 수 있습니다. 다른 번역 단위에서 동일한 이름의 다른 엔티티를 선언할 수 있고 이들은 서로 다른 별개의 엔티티로 취급됩니다. 전역 또는 네임스페이스에서 static 키워드로 선언된 변수 및 함수, const 키워드로 선언된 전역/네임스페이스 범위 변수(extern 사용하지 않은)가 내부 연결을 가집니다. 특정 소스 파일 내부에서만 사용되는 변수나 함수를 외부에서 접근하거나 충돌하는 것을 방지하여 캡슐화를 유지하고 이름 충돌을 피합니다.
외부 연결은 식별자가 선언된 번역 단위를 넘어 프로그램 전체에서 유효하며 다른 번역 단위에서도 접근할 수 있습니다. 프로그램 전체에 해당 이름은 하나의 동일한 엔티티를 나타냅니다. static 키워드 없이 선언된 전역 또는 네임스페이스 범위 변수, 함수 선언 및 정의가 기본적으로 외부 연결을 가집니다. 여러 소스 파일에 걸쳐 함수를 호출하거나 전역 변수를 공유하는 등 번역 단위 간에 엔티티를 공유해야 할 때 사용됩니다.

C++의 ODR(One Definition Rule)이란 무엇이며, 이를 위반했을 때 발생할 수 있는 문제점을 설명하시오.
->
ODR은 프로그램에서 사용되는 각 변수, 함수, 클래스, 열거형, 템플릿 등은 프로그램 전체에 걸쳐 정확히 하나의 정의를 가져야 한다는 규칙입니다. 이를 위반하고 여러 번역 단위에서 정의가 발견되면 Multiple Definition Error, 링커 오류가 발생합니다.

C++ 스마트 포인터(예: std::unique_ptr, std::shared_ptr)에 커스텀 삭제자(Custom Deleter)를 사용하는 방법과 목적을 설명하시오.
->
스마트 포인터가 관리하는 객체나 자원을 해제할 때 기본 delete나 delete[] 연산자 대신 사용자가 정의한 특정 함수나 함수 객체를 실행하고자 할 때 필요합니다. new를 통해 할당되지 않은 자원의 관리가 필요한 경우, delete 외에 추가적인 작업이 필요한 경우 정의하여 사용합니다.
struct나 class에 operator()를 구현하여 스마트 포인터 생성 시 템플릿 인자로 삭제자 타입을 명시합니다. 

C++ <chrono> 라이브러리를 사용하여 시간 측정이나 시간 관련 연산을 수행하는 기본적인 방법에 대해 설명하시오.
->
std::chrono::system_clock: 시스템의 실시간 시계입니다.
std::chrono::steady_clock: 단조 증가하는 시계로 간격 측정에 적합합니다.
std::chrono::high_resolution_clock: 가장 높은 정밀도의 시계입니다. 성능 측정에 적합합니다.
std::chrono::seconds, std::chrono::milliseconds 등 시간의 기간에 대해 미리 정의된 타입들이 있습니다.
std::chrono::time_point<Clock, Duration>의 형태로 특정 시간으로부터 특정 기간만큼 지난 시점을 나타냅니다.

정렬 알고리즘의 안정성(Stability)이란 무엇이며, 안정적인 정렬 알고리즘(예: Merge Sort)과 불안정한 정렬 알고리즘(예: Quick Sort)의 차이를 설명하시오.
->
안정성이란 정렬 알고리즘이 값이 동일한 요소들의 원래 순서를 유지하는지 여부를 사타내는 속성입니다. 입력 리스트에 값이 같은 두 요소 A, B에 대해 원래 리스트에서 A가 B보다 앞에 있었다면 안정적인 정렬 알고리즘으로 정렬한 후에도 A는 B보다 앞에 위치하게 됩니다. 불안정한 정렬 알고리즘은 값이 같은 요소들의 원래 순서를 보장하지 않습니다.
안정적인 정렬 알고리즘에는 병합, 삽입, 버블, 계수, 기수 정렬이 있습니다. 값이 같은 요소들의 상대적인 순서를 유지해줍니다.
불안정한 정렬 알고리즘에는 퀵, 선택, 힙 정렬이 있습니다. 값이 같은 요소들의 순서가 섞일 수 있습니다.
동일한 값을 가진 요소들의 부가적인 정보가 중요한 경우 안정적인 정렬이 요구될 수 있습니다.

게임 클라이언트가 서버와 통신할 때, NAT(Network Address Translation)나 방화벽이 어떤 문제를 유발할 수 있으며, 이를 해결하기 위한 일반적인 방법에는 무엇이 있는지 간략히 설명하시오.
->
대부분의 가정이나 사무실은 사설 IP 주소 대역을 사용합니다. NAT 장치(=공유기)를 통해 하나의 공용 IP 주소로 인터넷에 접속합니다. NAT은 외부에서 내부 사설 IP 주소로 직접 연결하는 것을 기본적으로 차단합니다. 이 경우 서버에서 클라이언트와 통신하고자 할 때 통신이 막히는 경우가 발생할 수 있습니다. 특정 포트를 통한 외부 트래픽을 허용하는 포트 포워딩, 클라이언트가 포트 포워딩 설정을 자동으로 요청하는 UPnP 프로토콜, UDP 통신에서 P2P 연결 시도할 때 사용되는 기술인 홀 펀칭, 데이터 릴레이를 위한 서버 운용, 80, 443 등 표준 포트를 사용함으로서 방화벽 통과를 시도할 수 있습니다.

웹 통신에 주로 사용되는 HTTP 프로토콜과 게임에서 자주 사용되는 소켓(Socket) 통신(TCP/UDP)의 차이점을 설명하고, 게임에서 소켓 통신이 더 적합한 이유를 설명하시오.
->
HTTP는 애플리케이션 계층 프로토콜로 웹 브라우저와 웹 서버 간의 통신을 위해 설계되었습니다. TCP 위에서 동작하며 기본적으로 Request-Response 모델을 따릅니다. 각 요청을 독립적으로 처리되며 상태 정보를 유지하기 어렵습니다.
소켓 통신(TCP/UDP)은 전송 계층 프로토콜을 사용하여 두 끝점 간 직접적인 데이터 통신 경로(소켓)을 제공합니다. TCP는 연결 지향, 신뢰성, 순서보장, 데이터 손실이나 중복 없이 순서대로 전달됩니다. UDP는 비연결 지향, 비신뢰성, 순서 보장 없음으로 빠르고 오버헤드가 적지만 데이터가 유실되거나 순서가 바뀔 수 있습니다.
네트워크 기반 게임에서는 실시간성 및 낮은 지연을 확보해야 하는데 HTTP 통신으로는 실시간 응답 처리나 낮은 지연을 유지하는 것이 어렵습니다. 소켓 통신을 선택하면 데이터의 성격에 따라 신뢰성이 필요한 경우 TCP, 빠른 응답이 필요한 경우 UDP로 선택하여 통신할 수 있습니다. 일반적으로 게임은 서버와 클라이언트 간에 지속적인 상태를 유지하는 형태를 요구하며 이를 구현하기 위해서는 HTTP보다 소켓 통신이 더 적합한 선택입니다.

파일 시스템의 기본적인 구조(예: 디렉터리, 파일, i-node 또는 MFT)에 대해 간략히 설명하시오.
->
파일 시스템은 저장 장치에 데이터를 효율적으로 저장, 구성, 관리, 검색할 수 있도록 하는 운영체제의 핵심 구성 요소입니다.
파일은 데이터를 저장하는 가장 기본적인 단위입니다.
디렉터리/폴더는 파일이나 다른 디렉터리를 그룹화하여 관리하는 컨테이너입니다. 트리 형태의 계층 구조를 이루어 파일들을 그룹화합니다.
+
i-node: 유닉스 기반
MFT: Win NTFS

3D 그래픽스에서 밉맵(Mipmaps)과 텍스처 필터링(예: Linear, Trilinear, Anisotropic)이 필요한 이유와 각각의 역할을 설명하시오.
->
밉맵은 원본 텍스처의 해상도를 절반씩 줄여가며 미리 여러 단계의 저해상도 텍스처 복사본을 생성해둔 집합입니다. 각 단계를 Mip Level이라고 불리며 Level 0은 원본 텍스처입니다. 3D공간에서 멀리있는 오브젝트를 렌더링할 때 화면 상 적은 수의 픽셀에 고해상도 텍스처를 매핑해야 합니다. 이는 매우 비효율적이며 계단 현상과 지글거림, 깜빡임을 발생하기도 합니다. 따라서 렌더링 파이프라인은 오브젝트와 카메라 거리에 따라 적절한 Mip Level의 텍스처를 자동으로 선택하여 사용합니다.
텍스처 필터링은 3D 오브젝트의 텍스처를 렌더링할 때 텍스처 픽셀과 화면 픽셀이 1:1로 정확히 대응되지 않는 경우 주변의 여러 픽셀 정보를 혼합하여 화면 픽셀의 최종 색상을 결정하는 기법입니다. 텍스처 픽셀과 픽셀이 1:1 매핑되지 않는 문제를 해결하여 텍스처를 부드럽고 자연스럽게 보이도록 합니다.

3D 그래픽스 렌더링에서 기본적인 조명 모델(예: Ambient, Diffuse)의 개념을 설명하시오.
->
Ambient: 광원의 방향이나 표면의 방향과 상관없이 모든 표면을 균일하게 비추는 간접적인 빛(간접광)을 시뮬레이션합니다.
Diffuse: 광원이 표면에 부딪혔을 때 모든 방향으로 고르게 산란되는 빛(난반사광)을 시뮬레이션합니다. 표면의 재질이 무광택일 때 관찰되며 빛의 방향과 표면의 노멀벡터 간의 각도에 의해 밝기가 결정됩니다. 램버트 모델이 대표적인 디퓨즈 조명 모델입니다. 오브젝트의 형태(굴곡)를 드러내는 데 중요한 역할을 합니다. 빛의 방향에 따라 표면의 밝기가 달라지므로 3D 오브젝트의 입체감을 부여합니다.

언리얼 엔진 AI 시스템의 EQS(Environment Query System)는 무엇이며, AI 에이전트가 환경 정보를 바탕으로 의사결정하는 데 어떻게 활용되는지 설명하시오.
->
EQS는 언리얼 엔진 AI가 게임 월드의 환경을 쿼리하여 특정 상황에서 AI에게 가장 유리하거나 적합한 위치, 대상, 리소스 등을 찾는 데 사용하는 시스템입니다.
쿼리 에셋을 생성하고 환경에서 찾고자 하는 포인트를 생성하는 제너레이터와 포인트를 평가하는 테스트를 추가합니다. BehaviorTree나 AI Controller 등 실행 주체에서 RunEQSQuery 함수를 호출하여 생성된 EnvQuery 에셋을 실행하면 쿼리된 포인트 목록을 결과로 반환합니다. 쿼리 결과를 통해 얻은 포인트를 이용하여 다음 행동을 결정하게 됩니다.

언리얼 엔진 애니메이션 시스템에서 Anim Notify는 무엇이며, 애니메이션 재생 중 특정 시점에 이벤트를 발생시키는 데 어떻게 사용되는지 설명하시오.
->
Anim Notify는 애니메이션 몽타주 에셋의 타임라인에 추가할 수 있는 이벤트입니다. 애니메이션 재생 중 Notify를 실행할 특정 지점에 해당하는 타임라인에 적절한 Anim Notify를 배치하고 애니메이션 블루프린트에서 해당 애님 노티파이의 호출을 감지하여 로직을 실행합니다. 

언리얼 엔진 스켈레탈 메시(Skeletal Mesh)에서 소켓(Socket)은 무엇이며, 어떤 목적으로 사용되는지 실무적인 예시(예: 무기 장착, 이펙트 부착)를 들어 설명하시오.
->
소켓은 스켈레톤 구조체에서 특정 본에 부탁되는 이름이 부여된 변환 지점입니다. 무기를 장착하거나 이펙트의 생성 위치를 결정하는 등 스켈레탈 메시의 특정 부위에 다른 액터나 컴포넌트를 쉽게 부착할 수 있는 커넥팅 포인트 역할을 합니다.

언리얼 엔진 피직스 시스템에서 물리 컨스트레인트(Physics Constraint)는 무엇이며, 오브젝트 간의 물리적 관계(예: 관절, 스프링)를 모델링하는 데 어떻게 사용되는지 설명하시오.
->
물리 컨스트레인트란 두 개의 물리 시뮬레이션 컴포넌트 사이에 물리적인 제약 조건이나 연결 관계를 정의하는 오브젝트입니다. 여러 물리 시뮬레이션 오브젝트를 물리적으로 연결하고 관계를 정의할 때 사용됩니다. UPhysicsConstraintComponent 컴포넌트로 표현됩니다.
캐릭터의 뼈대 물리 시뮬레이션 시 각 뼈 사이에 물리 컨스트레인트를 사용하여 힌지, 구, 원기둥 등의 관절을 모델링하여 뼈들이 특정 범위 내에서만 회전하거나 이동하도록 제한합니다. 차량 서스펜션과 같이 두 오브젝트 사이에 탄성 연결을 모델링하거나 오브젝트를 특정 위치로 끌어당기는 힘을 구현할 때 컨스트레인트의 Spring 설정을 사용하고 특정 속도로 회전시키고 싶을 때 컨스트레인트의 Drive 설정을 사용합니다.

언리얼 엔진의 물리 엔진인 Chaos와 기존 PhysX의 차이점에 대해 아는 대로 간략히 설명하시오.
->
PhysX는 Nvidia에서 제공하는 물리엔진으로 오래되고 안정성을 확보한 물리 엔진입니다. 리기드바디 물리, 콜리전 감지, 조인트, 차량 물리, 천 시뮬레이션 등의 기능을 제공하며 UE4에서 기본으로 사용되었습니다.
Chaos는 UE5에 맞춰 개발된 새로운 고성능 물리 엔진입니다. 멀티스레딩 및 GPU 가속을 적극적으로 활용하며 대규모 파괴, 유체, 천 시뮬레이션 등에서 뛰어난 성능과 기능을 제공합니다. UE5의 기본 물리 엔진이며 기존에 PhysX에서 제공하는 기능을 대체하거나 통합하고 있습니다. 멀티코어 및 GPU 활용에 강점을 가지고 있으며 UE5 개발에서는 Chaos를 사용하는 것이 권장됩니다.

언리얼 엔진 블루프린트 개발 시 C++로 작성하는 블루프린트 함수 라이브러리(Blueprint Function Library)와 블루프린트 매크로 라이브러리(Blueprint Macro Library)의 차이점을 설명하시오.
->
블루프린트 함수 라이브러리는 C++ 클래스로 작성되며 C++ 코드로 구현된 정적 함수들의 모음입니다. C++로 구현된 재사용 가능한 기능을 블루프린트에 노출할 때 사용합니다.
블루프린트 매크로 라이브러리는 언리얼 에디터 내에서 블루프린트 그래프 형태로 작성되는 에셋입니다. 자주 사용되는 블루프린트 노드 패턴이나 흐름을 재사용 가능한 단위로 만들 때 사용합니다.

언리얼 엔진에서 플랫폼(PC, Console, Mobile 등)별 코드를 분기 처리하기 위한 방법(예: #if PLATFORM_WINDOWS)과 관리 방법에 대해 설명하시오.
->
각 플랫폼에 따라 특정 전처리기 매크로를 정의합니다. 이러한 매크로를 #if, #elif, #else, #endif와 같은 전처리기 지시문을 이용해 PLATFORM_WINDOWS, PLATFORM_ANDROID 등의 매크로와 조합해 플랫폼별 코드를 조건부로 컴파일하도록 지시할 수 있습니다. build.cs에서 플랫폼별로 소스 파일 그룹을 컴파일 대상에 포함하거나 제외하여 관리할 수 있습니다.