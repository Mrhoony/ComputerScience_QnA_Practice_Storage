언리얼 엔진 리플렉션 시스템의 목적과 필요성: 언리얼 엔진에서 리플렉션(Reflection) 시스템이 필요한 주된 이유는 무엇이며, 이 시스템이 없었다면 구현하기 어려웠을 언리얼 엔진의 핵심 기능들(예: 블루프린트, 가비지 컬렉션, 에디터의 세부 정보 패널, 직렬화)을 설명하시오.
->
리플렉션 시스템은 런타임에 프로그램의 구조(클래스, 멤버 변수/함수 등)에 대한 메타데이터를 질의하고 조작할 수 있게 하는 기능입니다. C++ 자체는 기본적으로 리플렉션을 지원하지 않지만 UE는 자체적인 시스템을 구축하여 이를 가능하게 합니다.

필요성.
C++은 기본적으로 컴파일 시점에 모든 타입 정보가 결정되고 런타임에는 이 정보를 직접적으로 질의하거나 조작하는 매커니즘을 제공하지 않습니다. 하지만 게임 엔진은 에디터, 스크립팅, 직렬화, 네트워크 등 런타임에 코드의 구조를 알아야 하거나 동적으로 상호작용해야 하는 수많은 기능을 필요로 합니다. 리플렉션 시스템은 이러한 C++의 한계를 극복하고 동적인 기능들을 구현할 수 있는 기반을 제공합니다.

리플렉션 시스템을 이용한 UE 기능들.
블루프린트: 블루프린트는 C++ 클래스와 함수를 비주얼 스크립팅 언어로 노출하고 상호작용할 수 있게 합니다. 리플렉션 시스템은 C++ 클래스의 구조(멤버 변수, 함수 시그니처, 접근자)를 런타임에 파악하여 이를 블루프린트 노드로 변환하고 블루프린트에서 C++ 함수를 호출하거나 C++ 변수에 접근할 수 있도록 바인딩합니다. 리플렉션 없이는 C++ 코드를 블루프린트에서 사용할 수 없습니다.

가비지 컬렉션: UE의 GC 시스템은 UObject 포인터들을 자동으로 추적하여 더 이상 참조되지 않는 객체의 메모리를 해제합니다. 리플렉션 시스템은 UPROPERTY() 매크로를 통해 선언된 UObject 포인터 멤버 변수의 존재를 GC에게 알려주어 GC가 참조 그래프를 올바르게 탐색하고 강한 참조를 유지해야 할 객체를 식별할 수 있도록 합니다.

에디터 내 디테일 패널: UE 에디터에서 액터나 컴포넌트를 선택하면 디테일 패널에 해당 객체의 모든 UPROPERTY() 변수들이 자동으로 표시되고 수정 가능하게 됩니다. 이는 리플렉션 시스템이 런타임에 객체의 타입 정보와 멤버 변수들을 모두 파악하고 있기 때문에 가능한 기능입니다. 개발자가 일일이 UI 코드를 작성할 필요 없이 데이터 기반으로 패널이 자동 생성됩니다.

직렬화: 게임의 상태를 저장하거나 로드할 때 또는 에디터에서 에셋을 저장할 때 UObject의 모든 UPROPERTY() 변수들의 값을 파일로 읽고 써야 합니다. 리플렉션 시스템은 어떤 변수를 직렬화해야 하는지 그 변수의 타입은 무엇인지 등의 메타데이터를 제공하여 이 과정을 자동화합니다.

네트워크 복제: 멀티플레이어 게임에서 서버와 클라이언트 간에 UObject의 상태를 동기화해야 합니다. 리플렉션 시스템은 복제되어야 할 변수들을 식별하고 해당 변수들의 변경 사항만을 효율적으로 패킷으로 만들어 전송하고 수신 측에서 업데이트할 수 있도록 지원합니다.


리플렉션 시스템의 작동 방식 (UHT의 역할): 언리얼 엔진에서 UCLASS(), UPROPERTY(), UFUNCTION()와 같은 특수 매크로들이 어떻게 C++ 코드를 리플렉션 시스템에 노출시키는지 설명하시오. 특히 **UHT(Unreal Header Tool)**가 이 과정에서 어떤 핵심적인 역할을 수행하는지 설명하시오.
->
UE에서 UCLASS(), UPROPERTY(), UFUNCTION()과 같은 특수 매크로들은 C++ 코드를 리플렉션 시스템에 노출시키는 핵심적인 역할을 수행하며 이 과정에서 UHT(Unreal Header Tool)가 핵심적인 역할을 합니다.

UCLASS(), UPROPERTY(), UFUNCTION() 매크로의 역할.
이 매크로들은 C++ 표준 문법에는 없는 UE만의 확장 문법입니다. UHT가 파싱하고 코드 생성에 사용할 특별한 지시자입니다. 개발자가 이 매크로들을 C++ 클래스, 멤버 변수, 함수 앞에 붙이면 UHT는 이를 읽고 해당 코드 요소가 리플렉션 시스템에 노출되어야 한다는 것을 인지합니다.

UHT(Unreal Header Tool)의 역할.
헤더 파일 파싱: 빌드 과정의 초기에 UHT는 프로젝트의 모든 언리얼 엔딘 C++ 헤더 파일을 스캔하고 파싱합니다.

리플렉션 메타데이터 추출: UHT는 UCLASS(), UPROPERTY(), UFUNCTION() 등의 매크로를 찾아내고 이 매크로에 지정된 파라미터(BlueprintCallable, EditAnywhere, Replicated 등)를 포함하여 해당 C++ 코드 요소에 대한 모든 관련 메타데이터를 추출합니다.

코드 생성: 추출된 메타데이터를 바탕으로 UHT는 새로운 C++ 코드(*.generated.h, *.gen.cpp)를 자동으로 생성합니다. 이 생성된 코드에는 다음과 같은 내용이 포함됩니다.
UClass 인스턴스 초기화 코드: 각 UObject 클래스에 대한 UClass 인스턴스(UObject 클래스의 메타데이터를 담는 객체)를 생성하고 초기화하는 코드
FProperty 및 UFunction 인스턴스 생성 코드: UPROPERTY()로 선언된 각 멤버 변수에 대한 FProperty 파생 클래스(FIntProperty, FStrProperty 등) 인스턴스와 UFUNCTION()으로 선언된 각 함수에 대한 UFunction 인스턴스를 생성하고 초기화 하는 코드, 이 인스턴스들은 해당 변수/함수의 타입, 이름, 접근자, 메타데이터 등을 담고 있습니다.
리플렉션 시스템 등록 코드: 생성된 UClass, FProperty, UFunction 인스턴스들을 언리얼 엔진의 전역 리플렉션 맵에 등록하는 코드
헬퍼 함수: 블루프린트 바인딩, 직렬화, 복제 등을 위한 내부 헬퍼 함수들

컴파일: UHT가 생성한 C++ 코드들은 개발자가 작성한 원본 C++ 코드와 함께 표준 C++ 컴파일러(MSVC, Clang)에 의해 컴파일되어 최종 실행 파일에 포함됩니다.

결론.
UHT는 개발자가 UClass() 등의 매크로를 사용하여 선언적인 방식으로 리플렉션을 정의하면 이를 바탕으로 실제 런타임에 필요한 리플렉션 데이터를 구축하는 코드를 자동으로 생성해주는 전처리기 및 코드 생성기 역할을 수행합니다.


런타임 리플렉션 객체 활용: 런타임에 클래스, 프로퍼티, 함수에 대한 메타데이터를 제공하는 UClass, FProperty (또는 파생 클래스인 FIntProperty, FStrProperty 등), UFunction과 같은 리플렉션 객체들의 역할은 무엇이며, 이들을 통해 어떤 정보를 얻고 동적으로 제어할 수 있는지 설명하시오.
->
런타임에 클래스, 프로퍼티, 함수에 대한 메타데이터를 제공하는 UClass, FProperty, UFunction과 같은 리플렉션 객체들은 UE의 동적인 기능 구현의 핵심입니다.

UClass.
역할: UClass는 UObject 파생 C++ 클래스 자체의 런타임 메타데이터를 표현하는 UObject입니다. 모든 UObject 인스턴스는 자신이 속한 UClass 인스턴스에 대한 포인터를 가집니다. (MyObject->GetInstance())
제공 정보: 클래스 이름, 부모 클래스, 모든 멤버 변수, 모든 멤버 함수, 클래스에 적용된 메타데이터 태그, 생성자 정보 등을 포함합니다.
동적 제어..
타입 검사: MyObject->IsA(UMyClass::StaticClass())와 같이 런타임에 객체의 타입 계층 구조를 검사할 수 있습니다.
객체 생성: NewObject<UMyObject>(Outer, UMyObject::StaticClass())와 같이 UClass를 사용하여 런타임에 UObject 인스턴스를 동적으로 생성할 수 있습니다.
자식 클래스 순회: UClass의 모든 자식 클래스들을 런타임에 찾아낼 수 있습니다. (에디터 툴, 게임 데이터 관리)

FProperty.
역할: FProperty는 UObject 클래스의 멤버 변수에 대한 런타임 메타데이터를 표현하는 추상 기본 클래스입니다. 각 구체적인 타입에 따라 Int, Float, Str, Object, Struct 등으로 파생됩니다.
제공 정보: 프로퍼티 이름, 타입, 오프셋, 접근 권한, 메타데이터(BluprintReadOnly, EdiyAnywhere 등) 등을 포함합니다.
동적 제어..
값 읽기/쓰기: FProperty::GetValue_InContainer, SetValue_InContainer와 같은 함수를 이용하여 UObject 인스턴스에서 해당 프로퍼티의 값을 동적으로 읽거나 쓸 수 있습니다. 이는 에디터의 디테일 패널이 작동하는 핵심 원리입니다.
데이터 직렬화/역직렬화: 리플렉션 시스템은 FProperty 정보를 사용하여 해당 프로퍼티의 값을 파일에서 읽거나 파일에 쓸 수 있습니다.
복제: 네트워크 복제 시 FProperty 정보를 바탕으로 어떤 변수가 복제되어야 하는지 그 값을 어떻게 패킷으로 만들고 다시 복원해야 하는지 결정합니다.

UFunction.
역할: UFunction은 UObject 클래스의 멤버 함수에 대한 런타임 메타데이터를 표현하는 UObject입니다.
제공 정보: 함수 이름, 파라미터 목록, 반환 타입, 함수에 적용된 메타데이터(BlueprintCallable, Exec 등), 접근 권한 등을 포함합니다.
동적 제어..
함수 호출: UFunction::Invoke()나 ProcessEvent() 같은 함수를 사용하여 런타임에 UObject 인스턴스의 특정 함수를 동적으로 호출할 수 있습니다. 이는 블루프린트가 C++ 함수를 호출하는 방식의 기반입니다.
RPC 호출: 네트워크 RPC에서 UFunction 정보를 사용하여 함수 호출을 원격으로 전송하고 실행합니다.


리플렉션 시스템의 실제 활용 사례: 리플렉션 시스템이 게임의 로딩 및 저장(Serialization), 네트워크 복제(Replication), 에디터의 세부 정보 패널(Details Panel) 자동 생성 및 커스터마이징, 블루프린트 노출 등 다양한 언리얼 엔진의 핵심 기능에서 어떻게 구체적으로 활용되는지 주요 사례를 들어 설명하시오.
->
리플렉션 시스템은 UE의 거의 모든 핵심 기능에 깊이 관여하고 있습니다.

게임 로딩 및 저장.
플레이어 세이브 파일이나 에디터에서 에셋을 저장할 때, UE는 해당 UObject나 UClass 정보를 통해 어떤 UPROPERTY() 멤버 변수들을 저장해야 하는지 자동으로 파악합니다.
각 FProperty 객체는 해당 변수의 타입 정보와 메모리 오프셋을 가지고 있어 파일에서 데이터를 읽어와 정확한 메모리 위치에 쓰거나 메모리에서 값을 읽어와 파일로 쓸 수 있게 합니다.

네트워크 복제.
멀티플레이어 게임에서 서버와 클라이언트 간에 AActor나 UActorComponent의 상태를 동기화할 때, UPROPERTY(Replicated)나 UPROPERTY(ReplicatedUsing=Function)로 선언된 변수들이 복제의 대상이 됩니다.
리플렉션 시스템은 이러한 복제 플래그가 붙은 변수들을 식별하고 해당 변수들의 변경 사항만을 효율적으로 추적하여 네트워크 패킷으로 만들고 수신 측에서 UClass 및 FProperty 정보를 사용하여 올바른 메모리 위치에 값을 업데이트합니다.
UFUNCTION(Server)나 UFUNCTION(Client)와 같은 RPC도 UFunction 정보를 통해 원격 호출을 가능하게 합니다.

에디터의 디테일 패널 생성 및 커스터마이징.
개발자가 UCLASS()나 UPROPERTY() 매크로에 EditAnywhere, BlueprintReadOnly, Category 등 에디터 관련 메타데이터를 추가하면 UE 에디터의 디테일 패널은 자동으로 해당 변수를 UI에 표시하고 편집 가능하게 만듭니다.
리플렉션 시스템은 UClass의 모든 FProperty를 순회하며 이 메타데이터를 읽어들여 복잡한 UI 코드 작성 없이도 데이터 기반으로 에디터 UI를 동적으로 생성합니다.

블루프린트 노출.
UFUNCTION(BlueprintCallable): C++ 함수를 블루프린트에서 호출 가능한 노드로 노출합니다. 리플렉션 시스템은 함수의 파라미터와 반환 타입 정보를 블루프린트에 제공하여 올바른 노드 인터페이스를 생성합니다.
UPROPERTY(BlueprintReadWrite): C++ 멤버 변수를 블루프린트에서 읽고 쓸 수 있는 변수로 노출합니다.
UCLASS(Blueprintable: C++ 클래스를 블루프린트에서 상속받아 새로운 블루프린트 클래스를 만들 수 있게 합니다.)

콘솔 명령어 및 Exec 함수.
UFUNCTION(Exec)로 선언된 함수는 런타임에서 콘솔에서 직접 호출할 수 있습니다. 리플렉션 시스템은 이러한 함수들을 식별하고 입력된 문자열을 파라미터 타입에 맞게 파싱하여 함수를 호출합니다.


리플렉션 시스템의 오버헤드와 설계 고려 사항: 언리얼 엔진의 리플렉션 시스템이 제공하는 강력한 기능에도 불구하고 발생할 수 있는 잠재적인 런타임 오버헤드(예: 초기화 시간, 메모리 사용량)는 무엇이며, 따라서 모든 C++ 클래스를 UObject로 만들지 않고 일반 C++ 클래스를 사용하는 상황과 이유에 대해 설명하시오.
->
UE의 리플렉션 시스템은 강력하지만 기능을 위해 런타임 오버헤드가 발생합니다.

초기화 시간: UE가 시작될 때 모든 UObject 클래스에 대한 UClass 인스턴스와 그 내부의 FProperty, UFunction 인스턴스들이 생성되고 전역 맵에 등록되어야 합니다. 프로젝트에 UObject 클래스가 많을수록 초기화 시간은 늘어납니다.
메모리 사용량: 모든 리플렉션 메타데이터는 런타임에 메모리에 상주해야 합니다. 추가적인 메타데이터는 상당한 양의 메모리를 차지할 수 있습니다.
런타임 간접성: 리플렉션 시스템을 통해 프로퍼티에 접근하거나 함수를 호출하는 것은 직접적인 C++ 멤버 접근이나 함수 호출보다 약간의 런타임 오버헤드를 가집니다. 이는 추가적인 포인터 역참조나 가상 함수 호출을 수반할 수 있기 때문입니다.

모든 C++ 클래스를 UObject로 만들지 않고 일반 C++ 클래스를 사용하는 상황과 이유.
위에 언급된 오버헤드 때문에 UE 개발에서는 모든 C++ 클래스를 무분별하게 UObject로 만들지 않고 필요에 따라 일반 C++ 클래스를 사용하는 것이 중요합니다.

성능에 민감한 데이터 구조: 매우 자주 생성되고 파괴되거나 성능에 결정적인 영향을 미치는 데이터 구조는 UObject 대신 일반 C++ struct나 class로 만드는 것이 좋습니다. UObject의 GC 오버헤드, 리플렉션 메타데이터 메모리, 생성/소멸 비용을 피할 수 있습니다.
GC의 관리 대상이 될 필요가 없는 객체: 생명 주기가 명확하고 개발자가 직접 delete나 스마트 포인터로 관리할 수 있는 객체는 UObject로 만들 필요가 없습니다. (파일 스트림 핸들러, 네트워크 소켓 래퍼, 유틸리티 클래스 등)
리플렉션 기능이 필요 없는 객체: 블루프린트에 노출되거나 에디터에서 편집되거나 직렬화/복제되거나 GC의 추적이 필요없는 순수한 C++ 로직을 담는 클래스는 UObject로 만들 이유가 없습니다.
컨테이너 내부 데이터: TArray, TMap 등의 언리얼 컨테이너 내부에 저장되는 원시 데이터 타입이나 간단한 FVector, FRotator같은 언리얼 엔진 구조체는 UObject가 아닙니다. 이들은 UObject의 오버헤드 없이 효율적으로 저장되고 관리됩니다.
외부 라이브러리와의 상호작용: OpenGL, DirectX, 물리 엔진 라이브러리 등 외부 C++ 라이브러리의 객체를 래핑하거나 직접 사용할 때는 해당 라이브러리의 클래스를 UObject로 만들지 않고 일반 C++ 클래스로 처리하는 것이 일반적입니다.

결론.
UObject는 UE의 강력한 기능을 활용하기 위한 필수적인 기반이지만 그에 따른 오버헤드도 존재합니다. 따라서 성능, 메모리 사용량, 그리고 필요한 기능에 대한 신중한 고려를 통해 UObject와 일반 C++ 클래스를 적절히 혼용하여 사용하는 것이 효율적인 UE 개발의 핵심 설계 원칙입니다.