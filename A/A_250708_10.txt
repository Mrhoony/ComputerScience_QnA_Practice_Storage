서브시스템의 초기화 순서 문제나 의존성 문제에 대한 해결 방법은?
->
UE에서 서브시스템을 사용할 때 여러 서브시스템 간의 초기화 순서나 의존성 문제가 발생할 수 있음. 한 서브시스템이 아직 준비되지 않은 다른 서브시스템의 기능을 호출하려 할 때 널포인터 접근, 크래시, 언디파인드비헤이비어 등이 발생할 수 있음

초기화 시점 조정 및 지연 접근.
서브시스템이 다른 서브시스템을 접근하는 시점을 모든 필수 서브시스템이 확실히 초기화를 완료한 이후로 미루는 것
즉시 접근 피하기: 서브시스템의 Initialize() 함수 내부에서 다른 서브시스템의 기능을 직접 호출 금지, 해당 Initialize() 함수는 해당 서브시스템의 자체 초기화만 담당하도록 할 것
다른 안전한 라이프사이클 함수 사용: 게임인스턴스 서브시스템은 UGameInstance::Init()에서 SubsystemCollection.Initialize(this);이 완료된 후 서브시스템 간의 연산을 실행(Super, 델리게이트 이용), 월드 서브시스템은 PostInitialize() 오버라이드 등 추가적인 경로 활용

의존성 주입.
직접 탐색 방지: 서브시스템이 필요한 의존성을 직접 GetSubsystem<>()으로 찾아오는 대신 외부에서 필요한 의존성을 파라미터로 주입받도록 설계
세터 주입: 서브시스템에 SetDependency(USubsystem* InSubsystem)과 같은 메서드를 만들어 의존성 연결
인터페이스 기반: 구체적인 클래스 대신 인터페이스 타입으로 의존성을 주입받음

설계 재고 및 책임 분리.
지속적으로 동일한 문제 발생 시 책임을 세분화하고 단일 책임 원칙을 적용, 아키텍처 재설계 및 도입


Soft Reference와 Hard Reference란?
->
참조는 에셋이나 객체를 가리키는 방식입니다. 메모리 로딩에 미치는 영향에 따라 하드 레퍼런스와 소프트 레퍼런스로 나뉩니다.

Hard Reference.
개념: 일반적인 형태의 참조로 UPROPERTY 매크로로 선언된 UObject* 포인터가 대표적입니다.
로딩 방식: 하드 참조된 에셋은 참조하는 에셋이 메모리에 로드될 때 무조건 함께 로드됩니다. A 에셋이 B 에셋을 하드 참조하고 있다면 A가 로드되는 순간 B도 강제로 로드되어 메모리에 상주하게 됩니다.
장점: 참조된 에셋에 즉시 접근할 수 있어 런타임 성능이 좋고 널포인터가 될 걱정 없이 사용 가능합니다.
단점: 불필요한 에셋까지 한꺼번에 로드되어 메모리 사용량이 증가합니다. 순환 참조가 발생하면 모두 메모리에서 내려오지 못할 수 있습니다.
사용 예: 스켈레탈 메쉬가 스켈레톤 에셋을 참조하는 경우 등

Soft Reference.
개념: TSoftObjetPtr<T> 또는 TSoftClassPtr<T>와 같은 스마트 포인터 타입으로 선언된 참조입니다. 에셋의 경로만 가지고 있으며 에셋 자체를 직접적으로 로드하지 않습니다.
로딩 방식: 소프트 참조된 에셋은 참조하는 에셋이 로드될 때 자동으로 함께 로드되지 않습니다. 필요할 때 소프트 레퍼런스 스마트 포인터의 LoadSynchronous()를 호출하여 에셋을 메모리에 로드한 뒤 사용
장점: 메모리 사용량 최적화
단점: 에셋 사용 전 로딩 여부 확인 필요
사용 예: 여러 캐릭터의 고유한 UI를 지닌 통합 UMG 내에서 각 캐릭터의 고유 UI 에셋들


AssetManager에 보면 Asset의 우선순위라는게 있는데 이게 뭐고 어떤 역할을 하는지?
->
개념: AssetManager를 통해 에셋을 로드할 때 각 에셋이나 에셋 묶음에 정수형 우선순위 값을 부여할 수 있습니다. 이 값은 해당 에셋들이 다른 에셋들보다 얼마나 빨리 또는 얼마나 중요한 시점에 로드되어야 하는지를 엔진에 알려줍니다.

역할.
로딩 순서 제어: AssetManager는 지정된 우선순위가 높은 에셋을 낮은 에셋보다 먼저 로드하려고 시도합니다. 이는 특히 게임 플레이에 필수적인 에셋이 먼저 로드되고 배경 에셋이나 특정 상황에서만 필요한 에셋들이 나중에 로드되도록 할 때 유용합니다.
리소스 관리 최적화: 게임 시작 시 로드되는 에셋의 양을 최소화하고 필요한 시점에 적절한 우선순위로 에셋을 스트리밍하여 로딩 스파이크를 줄이고 부드러운 게임 플레이 경험을 제공합니다.
리소스 밸런싱: 개발자는 에셋의 중요도와 사용 빈도에 따라 우선순위를 할당하여 제한된 메모리나 I/O 대역폭 내에서 가장 효율적인 로딩 전략을 수립할 수 있습니다.
청크(Chunk) 로딩: 패키징 시 데이터를 청크로 분리할 때도 이 우선순위 정보를 활용하여 특정 청크를 우선적으로 다운로드하거나 로드하도록 설정할 수 있습니다.


프로그레스바 UMG에서 모양을 프로그래밍으로 커스터마이징 하는 방법은?
->
모양을 프로그래밍으로 커스터마이징하는 방법은 주로 슬레이트(Slate) 스타일 시스템을 조작하는 것입니다. UProgressBar의 모양은 FSlateBrush 구조체로 정의된 스타일(Style)에 의해 결정됩니다.


리플리케이션 시스템이란?
->
UE의 네트워크 멀티플레이어 게임에서 여러 클라이언트 간에 게임 상태를 동기화하는 핵심 매커니즘입니다. 서버-클라이언트 모델에서 서버가 게임의 진실된 상태를 소유하고 클라이언트들에게 이 상태를 복제하여 동기화합니다.

주요 목표.
상태 동기화, 이벤트 전달, 대역폭 최적화

작동 방식.
권한(Authority): UE의 네트워크 모델은 기본적으로 서버가 권한을 가집니다. 서버의 액터가 오리지널이고 클라이언트들은 서버 액터의 복제본을 가집니다.
UPROPERTY 복제: UPROPERTY 매크로에 Replicated나 ReplicatedUsing 같은 지정자를 붙여 어떤 변수를 복제할지 명시합니다. 엔진은 이 정보를 바탕으로 해당 변수가 변경되었을 때만 자동으로 복제합니다.
RPC: UFUNCTION 매크로에 Server, Client, NetMulticast와 같은 지정자를 붙여 특정 함수가 네트워크를 통해 호출되도록 만듭니다.


RPC와 리플리케이션의 차이는?
->
리플리케이션.
상태를 처리
많은 변수가 리플리케이트 되더라도 주기마다 모아서 한번에 처리 (1번의 네트워크 연산)
기본 제공되는 기능으로 클라 -> 서버는 불가

RPC.
이벤트를 처리
호출되는 RPC마다 즉시 처리, 1틱 내 10번씩 RPC를 호출하는 경우 10번이 각각 처리 (10번의 네트워크 연산)
Server RPC를 통해 클라 -> 서버 가능
RPC 호출 시 액터롤에 유의해야 함


모든 변수는 UPROPERTY 매크로를 붙여서 복제가 가능한지? 복제에 조건이 있는 변수 타입에는 무엇이 있는지? 복제가 안되는 변수가 있는지?
->
모든 변수에 UPROPERTY 매크로를 붙여도 복제가 가능한 것은 아님, 조건 충족 필요

조건.
UPROPERTY 매크로 + Replicated, ReplicatedUsing 지정자
Authority 소유권
UObject 파생 클래스의 멤버

복제에 추가적인 조건이 있는 변수 타입.
UObject* 포인터: 담긴 UObject 자체가 복제 가능한 상태여야 함, 서버와 클라이언트 모두에 유효한 객체여야 함, 위반 시 nullptr가 될 수 있음
TArray: 복제 가능하지만 배열 내부의 요소가 변경될 때마다 전체 배열이 복제되는 것이 아니라 NetSerialize 함수를 오버라이드하여 별도의 복제 방식을 구현하거나 배열 요소의 변경을 감지하고 RepNotify 함수를 사용하는 등 추가적인 고려가 필요할 수 있습니다.
TMap, TSet: UPROPERTY 로 복제되지 않습니다.
USTRUCT: USTRUCT 매크로로 선언된 구조체 내 UPROPERTY 변수들은 복제 가능합니다. 구조체 자체가 직접 Replicated 되는 것이 아닌 구조체를 포함하는 상위 UObject의 UPROPERTY가 복제될 때 구조체 전체가 복제됩니다.

복제가 안되는 변수.
TWeakObjectPtr: 에셋을 직접 로드하지 않으므로 대상이 아님
const: 변경될 수 없으므로 복제 대상이 아님
static: 인스턴스에 속하지 않고 클래스에 속하므로 대상이 아님


USTRUCT 내의 변수에 UPROPERTY를 붙이지 않으면 해당 USTRUCT는 복제가 되는지?
->
USTRUCT는 해당 구조체를 지닌 상위 UObject의 Replicated 여부에 따라 복제됨, USTRUCT가 복제될 때 내부의 변수는 UPROPERTY 여부에 따라 복제를 결정함


배열과 연결 리스트의 차이는?
->
배열.
메모리 저장: 연속적인 메모리 공간에 저장
데이터 접근: 인덱스를 통해 O(1) 시간에 즉시 접근
삽입/삭제: 중간 삽입/삭제 시 데이터 이동 필요(O(N))
메모리 오버헤드: 데이터 자체 외에 거의 없음
크기 조절: 고정 크기 도는 동적 할당
장점: 빠른 무작위 접근, 캐시 효율성 높음
단점: 느린 삽입/삭제, 크기 변경 비효율적

연결 리스트:
메모리 저장: 비연속적인 메모리 공간에 저장
데이터 접근: 순차 탐색 필요(O(N))
삽입/삭제: 노드의 포인터만 변경(O(1))
메모리 오버헤드: 데이터 외에도 이전, 다음 노드를 가리키는 포인터 추가
크기 조절: 동적 크기 조절 자유로움
장점: 빠른 삽입/삭제, 유연한 크기 조절
단점: 느린 무작위 접근, 추가적인 포인터 오버헤드, 캐시 효율성 낮음


연결 리스트를 정렬할 때 적절한 정렬은?
->
핵심: in-place sort는 연결 리스트 자료구조에서 정렬에 적합하지 않음, 연속된 메모리 공간에서 요소들을 교환하거나 재배치하는 정렬이기 때문

적절한 정렬: 병합 정렬
분할이 끝난 후 정복 과정에서 정렬이 진행되는데 not-in-place sort이기 때문에 정복 과정에서 배열, 연결 리스트 모두 사용 가능함, 연결 리스트 입장에서 효율적인 시간 복잡도를 챙길 수 있는 가장 적합한 정렬

+힙 정렬은 왜 적절하지 않은가?
트리는 리스트를 이용해 노드 단위로 구성하는 것은 맞지만 정렬에 있어 각 노드의 순서가 교체되어야 할 경우 포인터 처리가 복잡하고 어려움, 힙 정렬은 완전 이진 트리에서의 정렬인데 완전 이진 트리는 배열로 표현이 가능하기 때문에 인덱스 기반의 위치 이동이 용이함, 따라서 힙 정렬은 연결 리스트에 적합하지 않고 배열에 적합한 정렬