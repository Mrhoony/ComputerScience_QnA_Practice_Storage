CDO란?
->
CDO는 Class Default Object의 약자입니다. UE는 C++ 기반이지만 자체적인 리플렉션 시스템을 구축하여 C++ 클래스의 메타데이터를 런타임에 활용합니다. CDO는 리플렉션 시스템의 중요한 부분입니다.

핵심.
클래스의 유일한 인스턴스: UE에서 UObject를 상속받는 모든 클래스는 엔진 시작 시(또는 클래스가 로드될 때) 단 하나의 CDO 인스턴스를 가집니다. 이 CDO는 해당 클래스의 템플릿 또는 원형 역할을 합니다.
기본값 저장: CDO는 해당 클래스가 가질 수 있는 모든 속성(Property)의 기본값을 저장합니다. UPROPERTY로 선언된 변수들의 기본값, 컴포넌트들의 기본 설정 등이 CDO에 저장됩니다.
인스턴스 생성의 원형: 게임 플레이 중에 새로운 객체(인스턴스)를 생성할 때 이 CDO에 저장된 기본값을 복사하여 새로운 객체를 초기화합니다. CDO는 new 연산자로 생성되는 일반 C++ 객체와 달리 언리얼 엔진의 SpawnActor, NewObject 등의 함수를 통해 생성되는 객체들의 원본 청사진 역할을 합니다.
에디터 설정의 기반: 언리얼 에디터에서 블루프린트나 C++ 클래스의 속성을 변경하면 이는 사실 해당 클래스의 CDO 값을 변경하는 것입니다. 에디터는 CDO를 통해 클래스의 기본값을 시각적으로 표시하고 수정할 수 있도록 합니다.

장점.
메모리 효율성: 모든 인스턴스가 동일한 기본값을 가질 필요가 없습니다. CDO에 기본값을 저장하고 인스턴스는 CDO와 다른 값만 따로 저장함으로서 메모리 사용을 최적화할 수 있습니다.
빠른 인스턴스 생성: 새로운 객체 생성 시 CDO에서 기본값을 빠르게 복사하여 초기화할 수 있습니다.
에디터와의 연동: 에디터에서 클래스의 기본값을 편리하게 설정하고 관리할 수 있도록 합니다. 블루프린트에서 부모 클래스의 기본값을 오버라이드하는 것도 CDO와 관련이 깊습니다.
직렬화 및 로딩: CDO는 클래스의 기본 상태를 직렬화하여 저장하고 로드하는데 사용됩니다.
템플릿화된 접근: 게임 로직에서 특정 클래스의 CDO에 접근하여 해당 클래스의 기본 속성을 확인하거나 특정 작업을 수행할 수 있습니다. UClass::GetDefaultObject() 함수를 통해 CDO에 접근할 수 있습니다.


언리얼 엔진에서 CDO(Class Default Object)는 무엇이며, 어떤 역할을 하는지 설명해주세요.
->
UObject 시스템에서 모든 UObject 기반 클래스가 가지는 유일한 기본 객체 인스턴스, UPROPERTY로 선언된 모든 속성(변수)의 초기 기본값을 저장

역할.
클래스의 템플릿/원형: 새로운 객체 인스턴스를 생성할 때 CDO에 저장된 기본값들을 복사하여 해당 인스턴스를 초기화하는 원형(Prototype) 역할
기본값 저장소: 리플렉션 시스템을 통해 클래스에 정의된 모든 속성들의 UPROPERTY 초기값이나 블루프린트에서 설정된 기본값들을 CDO가 가짐
에디터 설정 기반: UE 에디터에서 C++ 클래스나 블루프린트의 디테일 패널에서 기본 속성 값을 변경할 때 실제로 변경되는 것은 해당 클래스의 CDO 값


왜 언리얼 엔진은 CDO라는 개념을 사용하는 걸까요? CDO의 주요 이점은 무엇입니까?
->
메모리 효율성
빠른 객체 생성/초기화
에디터 연동
일관된 기본값 관리
런타임에 클래스 메타데이터 접근


CDO와 일반적인 런타임 객체(인스턴스)의 가장 큰 차이점은 무엇인가요?
->
CDO.
생성 시점: 클래스가 로드될 때 엔진에 의해 자동으로 단 한번만 생성
개수: 클래스당 하나
역할: 클래스의 기본값 템플릿/원형, 에디터에서 기본 설정 대상
상태 변화: 런타임 중 직접적인 변경 지양
생명 주기: 런타임 종료 시까지

일반 객체.
생성 시점: SpawnActor, NewObject 등의 함수 호출 시 필요에 따라 생성
개수: 클래스당 여러개
역할: 게임 플레이에서 실제로 사용되며 동작하는 개별 객체
상태 변화: 런타임 중에 상태가 지속적으로 변경
생명 주기: 생성부터 파괴까지 게임 로직에 따라 관리


언리얼 에디터에서 블루프린트나 C++ 클래스의 기본값을 변경할 때, 내부적으로 어떤 객체의 값이 수정되는 것인지 설명해주세요.
->
UE 에디터의 디테일 패널에서 블루프린트나 C++ 클래스의 기본값을 변경할 때 내부적으로는 해당 클래스의 CDO의 값이 수정됩니다. 에디터는 사용자가 클래스에 대한 설정을 변경할 때 해당 클래스의 CDO에 접근하여 그 값을 업데이트합니다. 이렇게 변경된 CDO의 값은 에디터가 저장될 때 직렬화되어 바이너리 파일로 저장됩니다. 나중에 게임이 로드되거나 새로운 인스턴스가 생성될 때 UE는 저장된 CDO의 값을 읽어와 기본값으로 사용하게 됩니다.


C++ 코드로 특정 클래스의 CDO에 접근해야 할 때, 어떤 함수를 사용하며, 주로 어떤 상황에서 CDO에 직접 접근하나요?
->
C++ 코드로 특정 클래스의 CDO에 접근할 때는 주로 UClass 클래스의 스태틱 함수인 GetDefaultObject<>() 템플릿 함수를 이용합니다.

주로 CDO에 직접 접근하는 상황.
클래스 레벨의 기본 속성 조회: 특정 클래스의 인스턴스를 생성하지 않고도 그 클래스의 기본 속성값을 조회하고 싶을 때
에디터 툴 개발: 에디터 확장 시 특정 클래스의 기본값을 프로그래밍 방식으로 조작하거나 분석할 때
팩토리/생성 로직: 객체를 생성하기 전에 해당 클래스의 CDO를 참조하여 특정 조건을 확인하거나 생성될 객체의 기본 상태를 미리 파악할 때


CDO에 저장된 값과 런타임에 생성된 인스턴스에 저장된 값이 서로 다른 경우, 언리얼 엔진은 이 두 값을 어떻게 관리하나요?
->
UE는 CDO의 값과 런타임에 생성된 인스턴스의 값을 Delta Serialization이라는 방식으로 관리

초기화: 런타임에 새로운 인스턴스가 생성될 때 이 인스턴스의 모든 속성은 해당 클래스의 CDO에 저장된 기본값으로 초기화
오버라이드: 이후 개발자나 게임 로직에 의해 특정 인스턴스의 속성 값이 CDO의 기본값과 다르게 변경될 수 있음
Delta Serialization: UE는 이 인스턴스를 저장할 때 CDO의 값과 다른 오버라이드된 값만 파일에 저장, CDO와 동일한 값은 저장하지 않음
로징 시: 다시 이 인스턴스를 로드할 때 먼저 해당 클래스의 CDO로부터 기본값을 가져와 인스턴스를 초기화한 다음 저장된 오버라이드된 값들을 읽어와서 기본값을 덮어씌움


CDO를 통해 클래스의 기본값을 설정하는 것과, 런타임에 생성된 인스턴스에서 값을 변경하는 것의 차이점과 그 의미는 무엇인가요?
->
CDO를 통해 클래스의 기본값을 설정.
영향 범위: 해당 클래스에 기반한 모든 새로운 인스턴스에 적용
지속성: UAsset에 저장되므로 영구적으로 유지
의미: 클래스의 기본 상태를 정의

런타임에 생성된 인스턴스에서 값을 변경.
영향 범위: 해당 특정 인스턴스에만 적용
지속성: 런타임 세션 동안 유지
의미: 게임 내 오브젝트의 현재 상태를 나타냄


CDO의 개념이 언리얼 엔진의 리플렉션 시스템 및 직렬화(Serialization)와 어떻게 연관되어 있는지 설명해주세요.
->
리플렉션 시스템과의 연관성.
UE의 리플렉션 시스템은 C++ 코드의 클래스, 속성, 함수에 대한 메타데이터를 런타임에 접근하고 조작할 수 있도록 지원
CDO는 리플렉션 시스템에 의해 생성되고 관리, 클래스 로드 시 리플렉션 메타데이터를 사용하여 해당 클래스의 CDO를 생성하고 모든 UPROPERTY 초기값을 채움
CDO를 통해 런타임에 UClass 객체로부터 특정 속성의 기본값을 조회, 함수를 호출

직렬화와의 연관성.
CDO는 클래스의 기본 직렬화 데이터를 나타냄, 에디터에서 클래스의 기본값을 변경하고 저장하면 이 CDO의 상태가 uasset 파일에 직렬화되어 저장됨
새로운 인스턴스를 저장할 때 UE는 인스턴스의 속성 값을 CDO의 속성 값과 비교하여 CDo와 다른 값만 직렬화, 파일 크기를 줄이고 로딩 시간 최적화
인스턴스를 로드할 때는 먼저 CDO를 기반으로 기본값을 설정한 후 저장된 오버라이드 값을 적용하여 최종 상태를 복원


특정 컴포넌트(예: UStaticMeshComponent)를 C++ 클래스의 생성자에서 CreateDefaultSubobject를 통해 생성하고 기본 설정을 해주는 것이 CDO와 어떤 관련이 있나요?
->
CreateDefaultSubobject 함수는 UE에서 클래스의 CDO 내부에 서브 객체의 기본 인스턴스를 생성하고 설정하는데 사용
클래스의 생성자에서 CreateDefaultSubobject를 호출하면 이 코드는 해당 클래스의 CDO가 생성될 때 실행됨
CreateDefaultSubobject로 생성된 컴포넌트는 해당 클래스의 CDO의 일부가 됨, 이 컴포넌트의 모든 속성값은 클래스의 기본 컴포넌트 설정으로 CDO 내부에 저장됨
해당 C++ 클래스를 기반으로 새로운 인스턴스가 생성될 때 UE는 이 액터의 CDO에 있는 컴포넌트의 기본값들을 복사하여 새로운 액터 인스턴스 내부에 해당 컴포넌트를 생성하고 초기화함


CDO를 사용하면서 발생할 수 있는 잠재적인 문제점이나 오해의 소지는 무엇이 있을까요?
->
런타임 중 CDO 상태 직접 변경의 위험성.
CDO는 클래스의 기본값을 저장하는 템플릿, 런타임 중에 CDO의 UPROPERTY 값을 직접 변경하는 것은 모든 인스턴스에 영향을 미칠 수 있는 전역적인 상태 변경으로 이어질 수 있음
CDO가 마치 싱글톤처럼 사용될 수 있다고 오해하여 런타임에 전역 설정 저장소로 사용하려는 경우 이는 CDO의 본래 목적이 아니며 인스턴스의 오버라이드 로직과 충돌하거나 문제 발생 가능
CDO는 기본적으로 읽기 전용으로 사용

CDO의 참조 문제.
CDO는 UObject의 한 종류이므로 GC의 대상이 될 수 있음, 하지만 클래스가 언로드되지 않는 한 CDO는 메모리에 계속 남아있음
CDO 내부에 다른 UObject 인스턴스를 직접 생성하여 저장하려 할 때 해당 인스턴스의 라이프사이클 관리나 참조 문제가 발생할 수 있음, CreateDefaultSubobject를 통한 컴포넌트 생성은 적절하지만 일반적인 NewObject를 통한 런타임 객체 생성 후 CDO에 저장하는 것은 지양해야 함

디버깅의 복잡성.
CDO의 값을 변경했는데 기대와 다르게 인스턴스에 반영되지 않거나 다른 인스턴스에도 원치않는 변경이 발생할 때 디버깅이 복잡해질 수 있음, CDO의 개념과 Delta Serialization 방식에 대한 정확한 이해 필요

GC와의 상호작용 오해.
CDO는 GC의 루트로 간주되므로 CDO가 참조하는 모든 객체는 GC에 의해 정리되지 않음, 불필요한 객체가 CDO에 계속 참조되면 메모리 누수처럼 작용할 수 있음