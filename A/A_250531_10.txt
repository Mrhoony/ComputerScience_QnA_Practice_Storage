C++20에 도입된 std::jthread는 무엇이며, 기존 std::thread와 비교했을 때 어떤 장점(예: 스코프 기반 자동 join, 협력적 중단 기능)을 가지는지 설명하시오.
->
std::jthread는 객체가 스코프를 벗어나면 자동으로 join()을 호출하여 스레드가 안전하게 종료되도록 보장하고 std::stop_token을 내부에 가지고 있어 request_stop()을 통해 스레드에 중단을 요청하고 스레드 내부에서 stop_requested()를 확인하여 협력적으로 작업을 중단할 수 있도록 지원합니다.

static_cast와 dynamic_cast는 각각 어떤 경우에 캐스팅이 실패할 수 있으며, 실패했을 때 반환하는 값이나 발생하는 예외 처리 방식에 대해 설명하시오.
->
static_cast는 컴파일 타임에 실패를 알 수 있습니다. 실패했을 때 특정 값을 반환하거나 예외를 발생시키지 않습니다.
dynamic_cast는 포인터 캐스팅 실패 시 nullptr, 레퍼런스 캐스팅 실패 시 std::bad_cast 예외를 발생시킵니다.

C++17에 도입된 if constexpr 문은 무엇이며, 템플릿 메타 프로그래밍에서 컴파일 타임 조건부 코드 생성을 통해 어떤 이점을 제공하는지 설명하시오.
->
일반 if문과 달리 조건식이 컴파일 타임에 평가되며 조건이 true인 브랜치만 컴파일되고 false인 브랜치는 컴파일 시점에 완전히 버려집니다.
SFINAE나 템플릿 특수화의 복잡성을 줄여 가독성을 높이고 생성되는 바이너리 크기를 줄여 컴파일 오류를 방지합니다.



3D 그래픽스에서 전역 조명(Global Illumination, GI)을 구현하는 기본적인 개념(예: 라이트맵(Lightmap), 스크린 스페이스 GI)과 각각의 장단점에 대해 간략히 설명하시오.
->
빛이 오브젝트에 반사되어 다른 오브젝트를 간접적으로 비추는 간접광을 시뮬레이션하여 더 사실적인 조명을 구현하는 기술입니다.
라이트맵은 렌더링 전에 미리 계산된 간접광 정보를 텍스처에 구워 오브젝트에 적용하는 방식으로 런타임 성능 오버헤드가 매우 낮고 고품질 간접광을 제공합니다. 정적인 장면에만 적합하며 동적인 오브젝트에는 반응하지 않습니다.
SSGI는 현재 화면에 보이는 정보(깊이, 노멀, 색상 버퍼)만을 사용하여 실시간으로 간접광을 추정하는 기법입니다. 실시간 동적인 조명 변화에 반응할 수 있지만 화면에 보이지 않는 오브젝트의 GI는 계산할 수 없고 시각적 아티팩트가 발생할 수 있습니다.

네트워크 게임에서 "지터(Jitter)"란 무엇이며, 플레이어 경험(예: 캐릭터 움직임의 불규칙성)에 미치는 영향과 이를 완화하기 위한 일반적인 방법(예: 지터 버퍼 사용)에 대해 설명하시오.
->
패킷의 도착 지연시간이 불규칙하게 변동하는 현상입니다. 캐릭터가 부자연스럽게 끊기거나 순간이동하는 것처럼 보이거나 움직임이 뚝뚝 끊기는 현상을 유발하고 플레이어 입력이 게임에 반영되는 시점이 불규칙해지며 게임 상태가 제대로 동기화되지 않아 플레이어 간 불일치가 발생할 수 있습니다.
지터 버퍼를 사용하여 정해진 간격으로 패킷을 처리하여 지터를 평탄화하거나 타임스탬프 기반 동기화를 이용하여 완화할 수 있습니다.

해시 테이블(Hash Table)에서 충돌(Collision)이 발생했을 때 이를 해결하기 위한 두 가지 주요 방법(체이닝(Chaining), 개방 주소법(Open Addressing))을 설명하고, 각각의 특징을 비교하시오.
->
서로 다른 키가 해시함수를 통해 동일한 버킷 인덱스로 매핑될 때 발생하는 현상입니다.
체이닝은 각 버킷을 연결리스트로 구성합니다. 충돌이 발생하면 해당 버킷의 연결 리스트에 새로운 키-값 쌍을 저장합니다.
개방 주소법은 충돌이 발생하면 해시 테이블 내의 다른 빈 버킷을 찾아 데이터를 저장합니다. 빈 버킷을 찾는 방식에는 선형 탐사, 이차 탐사, 이중 해싱 등이 있습니다.



언리얼 엔진에서 TWeakObjectPtr는 무엇이며, UObject 포인터를 사용할 때 TSharedPtr나 원시 포인터 대신 TWeakObjectPtr를 사용하는 것이 안전한 이유(예: 가비지 컬렉션 안전성)를 설명하시오.
->
약한 참조 스마트 포인터로 UObject 인스턴스에 대한 약한 참조를 저장하며 해당 UObject가 가비지 컬렉터에 의해 메모리에서 해제되어도 자동으로 nullptr로 설정됩니다.
가비지 컬렉션에 영향을 주지 않고 자동으로 nullptr이 되어 댕글링 포인터를 방지하고 순환 참조를 방지합니다. 다른 UObject에 대한 참조가 생명주기를 연장시키지 않아야 할 경우에 사용합니다.

언리얼 엔진 애니메이션 시스템에서 "동기화 마커(Sync Marker)"는 무엇이며, 여러 애니메이션 클립 또는 캐릭터 간의 특정 시점(예: 발걸음 소리 재생, 무기 교체)을 동기화하는 데 어떻게 사용되는지 설명하시오.
->
특정 프레임 또는 시점에 이름을 붙여 표시하는 마커입니다. 여러 애니메이션 클립 간에 정확한 타이밍으로 이벤트를 동기화하거나 애니메이션 전환 시점에 특정 이벤트가 발생하도록 하는 데 사용됩니다. 마커에 맞춰 발소리 사운드를 재생하거나 무기 교체 마커에 맞춰 실제 무기 모델을 캐릭터 모델에 부착하도록 동기화하는데 사용됩니다.

언리얼 엔진에서 RPC(Remote Procedure Call)를 선언할 때 WithValidation 키워드를 추가하는 목적은 무엇이며, 서버 측에서 RPC 유효성 검사가 실패했을 때(예: 클라이언트 치트 의심) 어떤 일이 발생하는지 설명하시오.
->
해당 RPC가 호출될 때 서버 측에서 클라이언트가 보낸 데이터의 유효성을 검사하는 추가적인 함수를 자동 생성하도록 지시합니다. 이는 클라이언트의 치트 행위나 악의적인 데이터 조작을 방지하기 위함입니다. _Validate 함수에서 false를 반환하는 등의 유효성 검사가 실패하면 서버는 해당 클라이언트의 RPC 호출을 무시하고 처리하지 않습니다. 네트워크 연결에서 추방하고 연결을 끊을 수도 있습니다.

언리얼 엔진에서 C++ 코드로 작성된 델리게이트(Delegate)를 블루프린트에서 호출하거나 바인딩할 수 있도록 노출시키기 위한 방법(예: DECLARE_DYNAMIC_MULTICAST_DELEGATE 매크로 사용)을 설명하시오.
->
델리게이트 매크로 중 DYNAMIC 키워드가 포함된 매크로를 사용하여 델리게이트 타입을 선언합니다. 해당 키워드는 블루프린트에서 바인딩 가능하도록 만들어줍니다. 작성된 델리게이트 타입을 이용하여 델리게이트 변수를 만들고 UPROPERTY(BlueprintAssignable)을 추가하여 블루프린트에서 노출되어 바인딩할 수 있도록 정의합니다.
