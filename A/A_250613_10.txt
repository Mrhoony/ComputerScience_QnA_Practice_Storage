C++에서 std::async, std::future, std::promise는 무엇이며, 다중 스레드 환경에서 비동기적으로 작업을 실행하고 결과를 안전하게 주고받는 데 어떻게 활용되는지 설명하시오.
->
std::async는 함수를 비동기적으로 실행하고 그 결과를 std::future 객체로 반환받는 템플릿 함수입니다. 내부적으로 스레드풀을 사용하거나 새 스레드를 생성하여 작업을 실행합니다.
std::future는 비동기적으로 실행된 작업의 결과를 받을 수 있는 미래의 결과를 나타내는 객체입니다. get() 메소드를 통해 결과가 준비될 때까지 대기하고 결과를 얻거나 wait() 메소드를 통해 결과가 준비될 때까지 대기만 할 수 있습니다. std::future는 std::promise나 std::async로부터 결과를 받습니다.
std::promise는 비동기적으로 실행되는 작업이 미래의 결과를 제공할 것이라는 약속을 나타내는 객체입니다. set_valve()를 통해 값을 설정하거나 set_exception()을 통해 예외를 설정할 수 있습니다. std::promise는 std::future와 연관되어 있어 std::promise에 값을 설정하면 std::future를 통해 그 값을 얻을 수 있습니다.
std::async를 사용하여 시간이 오래 걸리는 계산이나 I/O 작업을 메인 스레드와 분리하여 백그라운드에서 실행합니다. std::promise를 사용하여 한 스레드에서 계산된 결과를 다른 스레드로 안전하게 전달합니다. std::future는 결과가 준비될 때까지 자동으로 대기하므로 명시적인 뮤텍스나 조건 변수 없이도 스레드 간 동기화된 결과 전달이 가능합니다. std::future::get()이나 wait()을 통해 비동기 작업의 완료를 기다림으로서 필요한 시점에 작업의 결과에 접근하고 스레드를 동기화할 수 있습니다.

std::atomic 변수 사용 시 std::memory_order_seq_cst는 어떤 메모리 순서 보장을 제공하며, 이것이 가장 강력한 순서 보장인 이유와 다른 메모리 순서(relaxed, acquire, release)와의 차이점을 설명하시오.
->
std::memory_order_seq_cst는 std::atomic 연산 중 가장 강력한 메모리 순서 보장을 제공합니다. 모든 seq_cst 원자적 연산은 모든 스레드에서 동일한 순서로 관찰합니다. 이는 seq_cst 원자적 연산의 상위에 있는 모든 메모리 연산이 해당 seq_cst 연산보다 먼저 발생했음을 보장하고 하위에 있는 모든 메모리 연산이 해당 seq_cst 연산보다 나중에 발생했음을 보장합니다. 또한 다른 모든 스레드에서 수행되는 seq_cst 연산들 간에 전역적인 단일 순서가 존재합니다.
memory_order_seq_cst는 모든 스레드가 동일한 순서로 메모리 변경 사항을 합의하도록 강제합니다. 이는 직관적인 순차적 실행 모델과 가장 유사하여 개발자가 이해하고 사용하기 가장 쉽습니다. 이를 위해 컴파일러와 CPU는 필요한 경우 메모리 펜스 또는 barrier 명령어를 삽입하여 메모리 접근 재배열을 엄격하게 제한합니다.
relaxed는 단일 연산의 원자성만 보장하며 순서 보장은 전혀 없습니다. 다른 연산과 자유롭게 재배열될 수 있습니다.
acquire 연산은 그 이전에 다른 스레드의 release 연산으로 쓰인 모든 메모리 연산이 acquire 연산 이후로 재배열되지 않도록 보장합니다. release 연산은 그 이전에 수행된 모든 메모리 연산이 release 연산 이후로 재배열되지 않도록 보장하며 다른 스레드의 acquire 연산에 의해 관찰됩니다. 이들은 특정 지점에서만 순서를 보장하며 전체적인 전역 순서는 보장하지 않습니다.
seq_cst는 acquire와 release의 모든 보장을 포함하며 추가적으로 모든 seq_cst 연산 간의 전역 순서를 보장하여 가장 높은 비용을 가집니다.

C++의 **가변 템플릿(Variadic Templates)**은 무엇이며, **매개변수 팩(parameter pack)**을 사용하여 타입 안전하게 임의 개수의 인자를 처리하는 방법을 간단한 예시와 함께 설명하시오.
->
가변 템플릿은 임의 개수의 타입과 인자를 받아들일 수 있는 템플릿입니다. 템플릿 매개변수 목록에 ...을 사용하여 매개변수 팩을 선언합니다.
매개변수 팩은 임의 개수의 템플릿 매개변수 또는 함수 인자들을 나타내는 집합입니다.
typename... Args은 타입 매개변수 팩이고 Args... args은 함수 인자 팩입니다.
template<typename T, typename... Args>
void print(T firstArg, Args... remainingArgs) {
    std::cout << firstArg << " ";
    print(remainingArgs...); // 나머지 매개변수 팩에 대해 재귀 호출
}
printf와 같은 가변 인자 함수와 달리 타입 안전성을 보장하며 컴파일 시점에 타입 검사가 이루어지므로 런타임 오류 가능성을 줄입니다.



3D 그래픽스에서 렌더 패스(Render Pass) 개념은 무엇이며, 다중 패스 렌더링(Multi-pass Rendering)이 어떤 상황(예: 후처리 효과, 그림자)에서 사용되는지 설명하시오.
->
렌더 패스는 3D 그래픽스 렌더링 파이프라인에서 하나의 특정 목적을 가진 렌더링 작업 단위를 의미합니다. 각 패스는 특정 타입의 정보를 렌더 타겟에 출력합니다.
멀티 패스 렌더링은 단일 렌더링 작업으로 복잡한 시각적 효과를 구현하기 어려울 때 여러 렌더 패스를 순차적으로 수행하여 최종 이미지를 합성하는 기법입니다. 각 패스는 이전 패스의 결과물을 입력으로 사용하여 점진적으로 원하는 효과를 만들어냅니다.
후처리 효과, 그림자, 디퍼드 렌더링, 반사(리플렉션) 등에 활용됩니다.

네트워크 게임에서 **패킷 손실(Packet Loss)**이 발생했을 때, 이를 감지하고 복구하기 위한 두 가지 주요 메커니즘(예: ARQ - 재전송 요청, FEC - 전방 오류 수정)에 대해 설명하시오.
->
패킷 손실은 네트워크를 통해 데이터 패킷이 전송되는 과정에서 어떤 이유로 인해 도착지에 전달되지 못하고 유실되는 현상입니다.
ARQ(재전송 요청)는 송신자가 패킷을 보낸 후 수신자로부터 해당 패킷이 잘 도착했다는 확인 응답(ACK)을 기다립니다. 만약 일정 시간(타임아웃) 내에 ACK를 받지 못하면 송신자는 해당 패킷이 손실되었다고 판단하고 패킷을 재전송합니다. 각 패킷에는 순서 번호(Sequence Number)가 부여되어 수신자가 중복이나 순서 뒤바뀜을 감지할 수 있습니다.
FEC(전방 오류 수정)은 송신자가 원본 데이터와 함께 일정량의 중복된 또는 오류 수정 코드(Parity Data)를 함께 전송합니다. 수신자는 이 중복 데이터를 사용하여 손실된 패킷을 재전송 요청 없이 스스로 복구할 수 있습니다.

운영체제에서 데드락(Deadlock) 발생을 위한 네 가지 필요조건(상호 배제, 점유와 대기, 비선점, 순환 대기)을 설명하고, 각각을 방지하기 위한 방법을 간략히 제시하시오.
->
데드락은 다중 프로세스(또는 스레드) 환경에서 두 개 이상의 프로세스가 서로 상대방이 점유하고 있는 자원을 기다리면서 영원히 대기 상태에 빠지는 현상입니다.
상호 배제, 점유와 대기, 비선점, 순환 대기 4가지 조건이 충족되면 데드락이 발생합니다.
상호 배제는 자원이 한번에 하나의 프로세스(또는 스레드)만 사용 가능해야 합니다. 즉 공유 자원에 대한 독점적인 접근이 필요합니다.
점유와 대기는 자원을 하나 이상 점유하고 있는 프로세스가 다른 프로세스가 점유한 자원을 추가로 얻기 위해 대기해야 합니다.
비선점은 프로세스가 점유하고 있는 자원은 해당 프로세스가 스스로 자원을 해제할 때까지 강제로 빼앗을 수 없습니다.
순환대기는 데드락에 관련된 프로세스들이 자원 대기 그래프에서 순환 형태를 이루어야 합니다. 즉 P1은 P2를 기다리고 P2는 P3의 자원을 기다리며 Pn은 P1의 자원을 기다리는 식입니다.



언리얼 엔진 5(UE5)의 Lumen과 Nanite 기술이 기존 렌더링 파이프라인의 어떤 한계를 극복하고, 각각 어떤 종류의 씬(Scene) 구성에서 혁신적인 이점을 제공하는지 설명하시오.
->
기존의 실시간 전역 조명은 주로 스크린 스페이스 기반이거나 베이킹 방식으로 동적인 광원 변화나 지오메트리 변화에 유연하게 대응하지 못했습니다. 또한 고품질 간접 조명은 성능 비용이 매우 컸습니다.
Lumen을 사용함으로서 완전 동적인 전역 조명, 아티스트 워크플로우 간소화, 영화 같은 비주얼의 이점을 활용할 수 있게 되었습니다.
기존 엔진은 수억 개 이상의 폴리곤을 가진 고도로 상세한 모델을 실시간으로 렌더링하는데 한계가 있었습니다. 아티스트는 수동으로 LOD를 생성하고 최적화해야 했으며 이는 엄청난 시간과 노력이 필요했습니다.
Nanite를 사용함으로서 가상화된 지오메트리, 무제한에 가까운 지오메트리 디테일, 성능 최적화의 이점을 활용할 수 있게 되었습니다.

언리얼 엔진에서 **블루프린트 인터페이스(Blueprint Interface)**는 무엇이며, C++ 클래스에 어떻게 구현하고, 이를 통해 서로 다른 C++ 또는 블루프린트 클래스 간에 느슨하게 결합된 통신을 어떻게 달성할 수 있는지 설명하시오.
->
블루프린트 인터페이스는 UE의 계약 또는 프로토콜을 정의하는 에셋입니다. 함수 선언만을 포함하며 실제 구현은 포함하지 않습니다. 특정 기능을 제공해야 하는 클래스가 이 인터페이스를 구현하도록 강제합니다.
UInterface를 상속받는 C++ 클래스를 생성합니다. 이 클래스는 실제 코드를 가지지 않고 순수 가상 함수와 유사하게 UFUNCTION(BlueprintCallable, BlueprintNativeEvent) 등으로 인터페이스 함수를 선언합니다. 인터페이스를 구현할 UCLASS()에 public IMyInterface를 상속받고 인터페이스 함수의 _Implementation 버전을 오버라이드하여 실제 로직을 구현합니다.
블루프린트 인터페이스를 사용하면 특정 클래스 타입에 직접적으로 의존하지 않고도 해당 클래스가 특정 기능을 수행할 수 있는지 검사하고 호출할 수 있습니다.

언리얼 엔진의 UFUNCTION에 사용되는 BlueprintCallable, BlueprintPure, Server, Client, NetMulticast와 같은 함수 지정자(Function Specifiers)들의 역할과 각각의 사용 목적을 설명하시오.
->
BlueprintCallable은 함수가 블루프린트에서 호출될 수 있도록 노출시킵니다.
BlueprintPure는 함수가 블루프린트에서 호출될 수 있으며 순수 함수로 동작하도록 노출시킵니다. 실행핀이 필요하지 않습니다.
Server는 함수가 서버에서만 실행되어야 하는 RPC 함수임을 지정합니다.
Client는 함수가 클라이언트에서만 실행되어야 하는 RPC 함수임을 지정합니다.
NetMulticast는 함수가 서버와 모든 클라이언트에서 동시에 실행되어야 하는 RPC 함수임을 지정합니다. 서버에서 이 함수를 호출하면 서버 자신과 연결된 모든 클라이언트에서 해당 함수가 실행됩니다.

언리얼 엔진에서 **애셋 참조(Asset Reference)**를 **하드 참조(Hard Reference)**와 **소프트 참조(Soft Reference)**로 구분하는 주된 이유는 무엇이며, 각각의 장단점과 어떤 상황에 적합한지 설명하시오.
->
UE는 메모리 관리 및 로딩 효율성을 위해 에셋 참조를 두가지 방식으로 나눕니다. 에셋 로딩은 비동기적이며 메모리에는 필요한 에셋만 로드되어야 하기 때문입니다.
하드 레퍼런스는 UPROPERTY() 매크로로 선언된 UObject* 포인터나 TSubclassOf<UObject>와 같이 특정 에셋 타입으로 직접 선언된 참조입니다. 이 참조를 가진 객체가 로드될 때 참조하는 에셋도 자동으로 메모리에 로드됩니다. 개발자가 명시적으로 로딩 코드를 작성할 필요가 없습니다.
소프트 레퍼런스는 TSoftObjectPtr<UObject> 또는 TSoftClassPtr<UObject>와 같이 에셋의 경로를 문자열 형태로 저장하는 참조입니다. 참조하는 에셋을 자동으로 로드하지 않습니다.