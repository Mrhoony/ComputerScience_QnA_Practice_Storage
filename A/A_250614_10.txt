C++17에 도입된 std::optional과 std::variant는 무엇이며, 각각 Nullable 타입이나 이종(heterogeneous) 타입 집합을 안전하게 다루는 데 어떻게 활용될 수 있는지 설명하시오.
->
std::optional은 값이 있을 수도 있고 없을 수도 있다는 개념을 안전하게 표현하기 위한 타입입니다. 단일 값의 존재 여부를 나타냅니다. 포인터의 nullptr 사용을 대체하여 함수의 반환값이 성공적으로 계산되었는지 여부를 명확하고 타입 안전하게 나타냅니다.
std::variant는 이종 타입 집합 중 정확히 한가지 타입의 값을 저장할 수 있는 union-like 타입입니다. 서로 관련없는 타입들 중 하나만 될 수 있는 데이터를 표현할 때(다형성 대체) 유용합니다. 네트워크 메세지나 이벤트 처리 시 메세지의 타입이 여러가지 중 하나일 때 std::variant로 메세지를 표현(메세지 파싱)하고 std::visit을 사용하여 타입 안전하게 처리할 수 있습니다.

C++에서 **사용자 정의 리터럴(User-defined Literals)**은 무엇이며, 어떤 상황에서 코드의 가독성과 타입 안전성을 높이는 데 사용될 수 있는지 간단한 예시와 함께 설명하시오.
->
개발자가 자신만의 접미사를 사용하여 빌트인 타입의 리터럴을 확장하거나 새로운 리터럴을 정의할 수 있게 해줍니다. 물리량이나 시간 등의 단위를 코드에 직접 명시하여 가독성을 높이고 타입 오류를 방지합니다.
long double operator"" _km(long double km) { return km * 1000.0; }
double distance = 10.5_km;  // 10.5 -> 10500로 변환

C++의 SFINAE (Substitution Failure Is Not An Error) 원칙은 무엇이며, 템플릿 메타 프로그래밍에서 특정 타입에 대한 오버로드(Overload)를 선택적으로 활성화하거나 비활성화하는 데 어떻게 사용되는지 설명하시오.
->
SFINAE 정의는 치환 실패는 오류가 아니다(Substitution Failure Is Not An Error)의 약자입니다. C++ 템플릿 컴파일 과정에서 템플릿 인자 치환 중 발생한 오류는 즉시 컴파일 오유로 처리되는 대신 해당 오버로드 또는 템플릿 인스턴스화를 후보군에서 제외하고 다른 유효한 오버로드를 찾도록 시도하는 컴파일러의 동작 원리입니다.
템플릿 메타 프로그래밍에서 SFINAE은 주로 std::enable_if와 같은 트레이트와 함께 사용되어 특정 타입에 따라 템플릿 함수의 오버로딩이나 클래스 템플릿의 특수화를 조건부로 활성화/비활성화하는데 활용됩니다.
// 정수형 타입 T만 이 함수를 사용할 수 있도록 함
template <typename T>
typename std::enable_if<std::is_integral<T>::value, void>::type
process(T value) {
    std::cout << "Processing integral: " << value << std::endl;
}
// void process(int i);    // 컴파일 가능
// void process("hello");  // 컴파일 오류 (적합한 오버로드가 없음, SFINAE)



3D 그래픽스에서 **노멀 맵(Normal Map)**은 무엇이며, 실제 지오메트리 변경 없이 오브젝트의 디테일을 향상시키는 데 어떻게 사용되는지, 그리고 탄젠트 공간(Tangent Space)의 중요성에 대해 설명하시오.
->
노멀맵은 3D 모델의 표면 법선 벡터 정보를 픽셀 단위로 저장한 텍스처입니다. 각 픽셀의 RGB값은 법선 벡터의 X, Y, Z 성분에 대응되며 주로 파란색 계열로 나타납니다. (Z축이 위로 향하는 경우가 많기 때문) 노멀맵은 실제 지오메트리의 변화 없이 오브젝트 표면의 미세한 요철과 디테일을 시뮬레이션하여 시각적으로만 디테일이 추가된 것처럼 보이게 합니다. 렌더링 시 픽셀 쉐이더에서 노멀맵의 값을 읽어와 해당 픽셀의 법선 벡터를 변경합니다. 그러면 이 변경된 법선 벡터를 사용하여 빛 계산이 이루어지므로 빛이 표면에 부딪히는 각도가 미세하게 달라져 마치 요철이 있는 것처럼 그림자와 하이라이트가 생겨납니다. 이를 통해 적은 폴리곤으로도 매우 높은 디테일을 가진 것처럼 보이게 하여 성능을 최적화하면서 시각적 품질을 높일 수 있습니다.
노멀맵의 법선 벡터는 주로 탄젠트 공간이라고 불리는 로컬 좌표계에서 정의됩니다. 탄젠트 공간은 모델의 각 정점 또는 픽셀마다 고유하게 정의되는 공간으로 해당 지점의 표면과 평행한 X(탄젠트), Y(바이노멀), Z(노멀) 축으로 이루어집니다.
탄젠트 공간 노멀맵은 모델의 회전이나 스케일에 관계없이 일관된 디테일을 유지(방향 독립성)할 수 있습니다. 노멀맵의 Z축이 항상 표면의 바깥쪽을 향하기 때문에 텍스처를 재활용하기 쉽습니다. 모델의 절대적인 방향이 아닌 표면에 대한 상대적인 디테일 변화만을 저장하므로 데이터가 더 효율적이고 범용적입니다. 캐릭터가 애니메이션되거나 변형될 때 모델의 탄젠트 공간도 함께 변형되므로 노멀맵 디테일이 왜곡 없이 따라갑니다. 아티스트가 하이폴리곤 모델에서 베이킹하거나 툴에서 그릴 때 탄젠트 공간을 기준으로 작업하므로 직관적입니다.

네트워크 게임에서 **랙 보상(Lag Compensation)**은 무엇이며, 클라이언트의 입력 지연으로 인한 불공정한 상황을 완화하기 위해 서버 측에서 어떤 방식으로 구현되는지 설명하시오.
->
온라인 게임에서 클라이언트의 네트워크 지연으로 인해 발생하는 불공정한 상황을 완화하기 위해 서버 측에서 수행하는 기술입니다. 주로 플레이어 간의 상호작용에서 상대방이 이미 이동했음에도 자신은 과거 위치를 보고 있는 문제를 해결합니다.
A 플레이어가 B 플레이어를 총으로 쏘았다고 가정하면 A의 클라이언트에서는 총을 쏘는 순간 B는 이미 A의 화면에서 보이지 않는 곳으로 이동했을 수 있습니다. 하지만 A의 화면에서는 B가 여전히 총에 맞을 위치에 있을 수 있습니다. 서버는 B의 현재 위치를 기준으로 판정하므로 A의 총알이 빗나갔다고 판단하여 A는 불공정함을 느낄 수 있습니다.
서버측에서는 과거 생태 저장 -> 클라이언트 입력 수신 -> 지연 시간 계산 -> 상대방 위치 롤백 -> 히트 판정 -> 상태 복원의 과정에 따라 구현할 수 있습니다.
과거 상태 저장은 서버가 모든 플레이어 캐릭터의 과거 위치 및 상태 데이터를 일정 시간동안 기록해둡니다. 각 기록에는 서버의 타임스탬프가 함께 저장됩니다.
클라이언트 입력 수신은 서버가 A 플레이어의 총격 입력을 받습니다. 이 입력에는 A 클라이언트에서 총격이 발생한 시점의 클라이언트 타임스탬프가 포함되어 있습니다.
상대방 위치 롤백은 서버는 추정된 핑 시간을 사용하여 B 플레이어의 과거 상태 기록을 뒤져 A가 총을 쏜 그 시점에 B가 실제로 어디에 있었는지 위치를 롤백합니다. 즉 B의 현재 위치가 아닌 A가 총을 쏜 과거 시점의 B 위치로 되돌립니다.
히트 판정은 서버는 롤백된 B의 과거 위치를 기준으로 A의 총격이 명중했는지 여부를 판정합니다.
상태 복원은 판정 후 B의 위치는 다시 현재 상태로 복원됩니다.

운영체제에서 **가상 메모리(Virtual Memory)**의 페이징(Paging) 메커니즘은 무엇이며, TLB(Translation Lookaside Buffer)의 역할과 TLB 미스(Miss)가 시스템 성능에 미치는 영향에 대해 설명하시오.
->
가상 메모리는 실제 물리 메모리의 한계를 극복하기 위해 프로세스에게 물리 메모리보다 훨씬 큰 가상의 주소 공간을 제공하는 기술입니다. 각 프로세스는 독립적인 가상 주소 공간을 가지며 운영체제가 이 가상 주소를 실제 물리 주소로 변환하여 메모리에 접근하게 합니다.
페이징 매커니즘은 가상 메모리를 구현하는 가장 보편적인 방법입니다.
페이지는 가상 주소 공간을 고정된 크기의 블록으로 나눈 단위입니다.
프레임은 물리 메모리를 페이지와 동일한 크기의 블록으로 나눈 단위입니다.
페이지 테이블은 운영체제가 각 프로세스마다 유지하는 자료구조입니다. 가상 주소의 페이지 번호와 해당 페이지가 매핑되는 물리 메모리의 프레임 번호 정보를 저장합니다.
CPU가 어떤 가상 주소에 접근하려고 할 때 운영체제는 페이지 테이블을 찾아 페이지 번호에 해당하는 프레임 번호를 얻고 프레임 번호와 오프셋을 결합하여 실제 물리 메모리 주소를 생성하고 접근합니다. 만약 페이지가 물리 메모리에 없고 디스크(스왑 공간)에 있다면 페이지 폴트가 발생하고 운영체제가 해당 페이지를 디스크에서 물리 메모리로 로드해야 합니다.
TLB는 CPU 내부에 있는 작은 하드웨어 캐시 메모리로 가상주소-물리주소 매핑 정보(PTE, 페이지 테이블 엔트리)의 최근 사용 내역을 저장합니다. 가상 주소 변환 과정에서 매번 주 메모리의 페이지 테이블을 찾아보는 오버헤드를 줄이기 위한 캐시 역할을 합니다.
TLB 히트는 CPU가 TLB에서 필요한 PTE를 찾으면 주소 변환이 매우 빠르게 완료됩니다.
TLB 미스는 CPU가 TLB에서 필요한 PTE를 찾지 못하면 주 메모리에 있는 페이지 테이블을 직접 참조해야 합니다. 이 과정은 여러번의 메모리 접근(보통 2~4회)을 수반하며 디스크 I/O까지 발생하면 수백~수만배 느려질 수 있습니다.



언리얼 엔진에서 **콘트롤 릭(Control Rig)**은 무엇이며, 기존 애니메이션 방식과 비교하여 절차적 애니메이션(Procedural Animation)이나 복잡한 IK(Inverse Kinematics) 셋업을 구현하는 데 어떤 이점을 제공하는지 설명하시오.
->
컨트롤릭은 UE 내에서 절차적이고 모듈화된 방식으로 리깅 및 애니메이션을 생성하고 편집할 수 있는 프레임워크입니다. 사용자 정의 가능한 노드 그래프를 사용하여 스켈레톤 본을 제어하는 복잡한 로직을 구현할 수 있습니다.
키프레임, 애니메이션 시퀀스 등 기존 애니메이션 방식에서는 미리 정의된 움직임에만 국한되며 런타임에 동적으로 변화하는 환경에 유연하게 반응하는 움직임을 만들기 어렵고 복잡한 IK 솔버를 C++로 직접 구현하거나 외부 툴에서 IK를 베이킹하여 가져와야 하는 경우가 많았습니다. 컨트롤릭을 사용하면 실시간으로 본을 조작하여 애니메이션을 생성할 수 있고 상황에 따른 역운동학을 쉽고 빠르게 설정할 수 있습니다.

언리얼 엔진에서 **애셋 레지스트리(Asset Registry)**는 무엇이며, 엔진이 에셋을 탐색하고 관리하며, 특히 에디터에서 에셋을 빠르게 검색하고 참조를 추적하는 데 어떻게 활용되는지 설명하시오.
->
에셋 레지스트리는 UE에서 프로젝트 내의 모든 에셋에 대한 메타데이터를 저장하고 관리하는 중앙 집중식 데이터베이스입니다. 엔진이 프로젝트를 처음 시작하거나 에셋이 생성/수정/삭제될 때 에셋 파일을 스캔하여 이 레지스트리를 업데이트합니다.
에셋 레지스트리에 저장된 메타데이터를 기반으로 프로젝트 내의 모든 에셋을 매우 빠르게 검색할 수 있고 에셋의 종속성 그래프를 구축하고 GC가 에셋을 안전하게 언로드하도록 지원합니다.
컨텐츠 브라우저, 참조 뷰어, 쿠킹 및 패키징 등에서 활용됩니다.

언리얼 엔진에서 FMemory 유틸리티 함수들(예: FMemory::Malloc, FMemory::Free, FMemory::Memcpy)을 직접 사용하는 경우가 왜 드물며, 주로 어떤 상황(예: 낮은 수준의 메모리 최적화, 커스텀 할당자 구현)에서 사용될 수 있는지 설명하시오.
->
UE는 자체적인 메모리 관리 시스템을 가지고 있으며 대부분의 경우 new/delete 대신 UObject 시스템의 UProperty, TArray, TMap, TSet 등 컨테이너와 스마트포인터(TUniquePtr, TSharedPtr 등)를 통해 메모리를 관리합니다. 이 시스템은 GC, 할당자 플러그인, 디버깅 도구 등 다양한 기능을 통합하여 효율적이고 안전한 메모리 사용을 보장합니다.
FMemory는 로우 레벨 API로 FMemory의 함수들은 UE의 가장 낮은 수준의 메모리 할당/해제 함수들을 래핑한 것입니다. 이들은 OS 레벨의 malloc/free와 유사하게 직접적인 메모리 할당/해제를 담당하지만 엔진의 GC나 리플렉션 시스템과 통합되지 않습니다.
FMemory::malloc으로 할당된 메모리는 GC의 대상이 아니므로 개발자가 수동으로 FMemory::Free를 호출하여 해제해야 합니다.
로우 레벨 수준의 메모리 최적화, 커스텀 할당자 구현, 엔진 내부 개발 시 주로 사용됩니다.

언리얼 엔진의 **언리얼 인사이트(Unreal Insights)**는 무엇이며, CPU 및 GPU 프로파일링, 메모리 트래킹, 로깅 등 다양한 성능 데이터를 수집하고 시각화하여 게임 성능 병목 현상을 진단하는 데 어떻게 활용되는지 설명하시오.
->
언리얼 인사이트는 성능 분석 및 시각화 도구 세트입니다. 엔진 런타임 중에 발생하는 다양한 성능 관련 데이터를 수집하고 이를 시각적으로 표현하여 개발자가 게임의 성능 병목 현상을 효율적으로 진단하고 최적화할 수 있도록 돕습니다.
CPU, GPU, 메모리, 네트워킹, 로딩 등 다양한 성능 데이터를 수집하고 시각화합니다. 이를 통해 개발자는 병목 현상의 주 원인을 파악하고 프레임 내 시간 흐름, 메모리 누수 등을 명확하게 파악하고 조치하여 게임 성능을 개선할 수 있습니다.