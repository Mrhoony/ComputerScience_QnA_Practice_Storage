스택(Stack)과 힙(Heap)의 기본 개념: 프로그램 실행 시 스택 메모리 영역과 힙 메모리 영역이 각각 어떤 용도로 사용되며, 어떤 종류의 데이터가 저장되는지 설명하시오.
->
스택 메모리 영역은 주로 지역 변수, 함수 매개변수, 반환 주소 등 프로그램의 함수 호출과 관련된 데이터를 임시적으로 저장하는데 사용됩니다. LIFO 구조로 동작합니다. 함수가 호출될 때 생성되는 스택 프레임에 포함되는 정보로 함수의 지역 변수, 함수의 매개변수, 함수 호출 후 되돌아갈 반환 주소, 호출자 함수의 스택 프레임 포인터가 포함되며 컴파일 타임에 크기가 결정되는 정적 할당이 대부분이며 매우 빠릅니다.
힙 메모리 영역은 프로그램 실행 중에 동적으로 할당하고 해제해야 하는 데이터를 저장하는데 사용됩니다. 스택과 달리 개발자가 명시적으로 메모리 할당/해제를 제어합니다. 크기가 런타임에 결정되거나 함수 호출이 끝나도 유지되어야 하는 데이터, 객체 인스턴스(new/malloc으로 할당된 데이터), 큰 배열, 동적 배열, 데이터 구조(연결 리스트, 트리 등)의 노드 등 런타임에 크기가 결정되는 동적 할당이며 스택보다 느립니다.

메모리 할당 방식 및 해제: 스택과 힙에서 메모리가 할당되고 해제되는 방식(예: 자동 vs 수동, LIFO vs 임의 접근)의 차이점을 설명하시오.
->
스택 메모리는 자동 할당 방식입니다. 함수가 호출될 때 스택 포인터가 이동하면서 자동으로 공간이 할당되고 함수 호출이 끝나면 스택 포인터가 다시 원래 위치로 돌아가면서 자동으로 해제됩니다. LIFO 방식으로 가장 최근에 할당된 데이터만 접근할 수 있습니다. 자동 해제됩니다. 함수가 반환될 때 해당 함수의 스택 프레이과 그 안에 저장된 모든 데이터가 자동으로 소멸됩니다. 개발자가 명시적으로 해제 코드를 작성할 필요가 없습니다.
힙 메모리는 수동 할당 방식입니다. 개발자가 C++의 new 키워드나 C의 malloc 함수 등을 사용하여 명시적으로 메모리 할당을 요청해야 합니다. 할당된 메모리는 프로그램 실행 중 임의의 위치에 배치될 수 있습니다. 임의 접근이 가능합니다. 포인터를 통해 힙에 할당된 데이터에 자유롭게 접근할 수 있습니다. 수동 해제가 원칙입니다. 개발자가 C++의 delete 키워드나 C의 free 함수 등을 사용하여 명시적으로 메모리 해제를 요청해야 합니다. 만약 해제하지 않으면 메모리 누수가 발생합니다.

성능 및 효율성 비교: 스택 할당과 힙 할당의 성능(속도)을 비교하고, 각각의 할당 방식이 캐시(Cache) 효율성 및 CPU 오버헤드에 어떤 영향을 미치는지 설명하시오.
->
스택 할당은 속도가 매우 빠릅니다. 스택 포인터의 단순한 증감 연산만으로 메모리가 할당/해제되므로 오버헤드가 거의 없습니다. 캐시 효율성이 높습니다. 스택에 할당된 데이터는 연속적인 메모리 공간에 쌓이고 지역성에 딸 ㅏ함께 사용될 가능성이 높아 CPU 캐시(L1, L2, L3 캐시)에 적중될 확률이 높습니다. 이는 캐시 미스를 줄여 성능 향상에 기여합니다. CPU 오버헤드가 거의 없습니다.
힙 할당은 속도가 상대적으로 느립니다. 운영체제나 런타임 라이브러리의 메모리 관리자를 통해 메모리를 검색하고 할당/해제하는 복잡한 과정이 필요합니다. 이 과정에서 락을 획득하는 등 동기화 비용도 발생할 수 있습니다. 캐시 효율성이 낮을 수 있습니다. 힙에 할당된 데이터는 임의의 메모리 위치에 분산될 수 있으므로 관련 데이터들이 메모리상에 떨어져 있을 가능성이 높습니다. 이는 CPU 캐시 미스를 유발하여 성능 저하의 원인이 될 수 있습니다. CPU 오버헤드가 높습니다. 메모리 관리자 호출, 적절한 크기의 블록 탐색, 해제된 블록 관리, 단편화 처리 등 복잡한 오버헤드가 발생합니다.

스택 오버플로우(Stack Overflow): 스택 오버플로우가 발생하는 주된 원인은 무엇이며, 게임 개발에서 이러한 문제가 발생할 수 있는 시나리오(예: 깊은 재귀 호출, 너무 큰 지역 변수)를 제시하시오.
->
스택 메모리 영역은 운영체제에 의해 크기가 제한(일반적으로 몇 MB)되어 있습니다. 이 제한된 스택 공간이 할당해야 할 데이터의 양보다 작을 때 발생합니다. 즉 스택이 자신이 할당받은 최대 크기를 초과하여 사용할 때 발생합니다.
게임 개발에서 발생할 수 있는 시나리오로는 함수가 자기 자신을 너무 많이(또는 무한하게) 호출할 때 발생합니다. 각 함수 호출마다 새로운 스택 프레임이 스택에 쌓이는데 재귀 호출이 끝없이 이어지면 스택 프레임이 계속 쌓여 스택 공간을 모두 소진하게 됩니다. 함수 내에서 스택에 할당하기에는 너무 큰 크기의 지역 변수나 배열(특히 정적 크기의 배열)을 선언할 때 발생합니다. 재귀 호출은 아니더라도 함수 A가 B를 호출하고 B가 C를 호출하는 식으로 함수 호출 체인이 매우 깊어질 때 각 스택 프레임의 누적으로 스택 오버플로우가 드물지만 발생할 수 있습니다.
스택 오버플로우는 일반적으로 프로그램 크래시나 비정상적인 종료로 이어집니다.

힙 단편화(Heap Fragmentation): 힙 단편화가 발생하는 원인과 이것이 프로그램의 메모리 사용 효율성 및 성능에 미치는 부정적인 영향을 설명하시오. 단편화를 완화하기 위한 일반적인 방법에는 어떤 것들이 있나요?
->
힙 메모리에서 잦은 동적 할당과 해제가 불규칙한 크기의 순서로 반복될 때 발생합니다. 메모리 관리자는 할당 요청 시 적절한 크기의 빈 공간을 찾아 할당하고 해제 시 그 공간을 다시 빈 공간으로 표시합니다. 이 과정에서 크고 작은 빈 공간들이 생겨나고 시간이 지남에 따라 사용 가능한 메모리 공간이 여러개의 작고 불연속적인 조각들로 흩어지게 됩니다.
전체적으로 사용 가능한 충분한 메모리가 있음에도 불구하고 연속된 충분히 큰 빈 공간이 없어서 새로운 큰 메모리 할당 요청을 처리하지 못하고 메모리 할당 실패가 발생할 수 있습니다. (외부 단편화) 메모리 관리자가 새로운 할당 요청을 처리하기 위해 더 많은 시간을 들여 단편화된 빈 공간을 검색해야 하므로 할당/해제 성능이 저하됩니다. 또한 불연속적인 메모리 접근은 캐시미스를 증가시켜 CPU 성능에도 부정적인 영향을 미칩니다.
특정 종류의 객체나 동일한 크기의 데이터를 미리 할당된 큰 메모리 블록에서 관리(메모리 풀링)합니다. 객체가 필요하면 풀에서 가져오고 사용이 끝나면 풀에 반환합니다. 이는 잦은 동적 할당/해제를 줄이고 단편화를 완화합니다. 특정 데이터 유형이나 특정 시스템에 최적화된 할당자(커스텀 할당자)를 직접 구현하여 메모리 할당 패턴을 제어하고 단편화를 줄입니다. 일부 GC 시스템은 단편화를 해결하게 위해 사용중인 객체들을 연속적인 메모리 공간으로 이동시키는 압축 과정(GC의 압축)을 수행합니다. (UE의 GC는 압축 기능 X)

메모리 누수(Memory Leak): 힙 메모리에서 메모리 누수가 발생하는 원인과 이것이 장시간 실행되는 게임에 미치는 치명적인 영향(예: 성능 저하, 크래시)을 설명하시오. C++에서 메모리 누수를 방지하기 위한 방법을 제시하시오.
->
힙 메모리에서 동적으로 할당된 메모리가 사용이 끝났음에도 불구하고 delete 또는 free와 같은 명시적인 해제 과정을 거치지 않아 해당 메모리가 운영체제에 반환되지 못하고 계속해서 프로그램이 점유하는 현상입니다. 할당된 메모리의 주소를 저장하는 포인터를 잃어버리거나(Lost Pointer), delete 호출을 잊어버리는 경우가 가장 흔한 원인입니다.
시간이 지남에 따라 프로그램이 점유하는 메모리 양이 계속 증가합니다. 물리 RAM을 초과하면 하드 디스크의 가상 메모리를 사용하게 되는데 이는 현저한 성능 저하(프리즈, 렉)을 유발합니다. 결국 시스템의 모든 사용 가능한 메모리를 고갈시켜 Out Of Memory 오류로 인해 프로그램이 강제 종료되거나 불안정해집니다. 메모리 부족으로 인해 다른 시스템 자원에도 영향을 미쳐 전체 시스템이 불안정해질 수 있습니다. 짧은 시간의 테스트에서는 발견하기 어려울 수 있으나 장시간 플레이 시 점점 더 악화되어 심각한 사용자 경험 저하를 초래합니다.
std::unique_ptr, std::shared_ptr, std::weak_ptr 등 C++ 표준 라이브러리의 스마트 포인터를 사용하여 RAII 원칙에 따라 메모리 수명 주기를 자동으로 관리합니다. 포인터가 스코프를 벗어나거나 참조 카운트가 0이 되면 자동으로 메모리를 해제합니다. (RAII(Resource Acquisition Is Initialization) 원칙, 리소스(메모리, 파일 핸들, 뮤텍스 등)는 객체가 생성될 때 획득하고 객체가 소멸될 때 자동으로 해제되도록 설계합니다. 스마트 포인터가 대표적인 예입니다.) std::vector, std::map, std::string 등 표준 라이브러리의 컨테이너 클래스는 내부적으로 메모리를 관리하며 스코프를 벗어나면 자동으로 메모리를 해제합니다. 누가 언제 메모리를 할당하고 해제할 것인지 명확히 정의합니다. Valgrind, LeakSanitizer, Purify 또는 UE의 메모리 프로파일러(Frontend, Insight)와 같은 도구를 사용하여 런타임에 메모리 누수를 탐지하고 분석합니다.

스마트 포인터와 힙: C++ 스마트 포인터(예: std::unique_ptr, std::shared_ptr)가 힙 메모리 관리에 어떻게 기여하며, 원시 포인터(raw pointer) 사용 시 발생할 수 있는 메모리 관련 문제를 어떻게 해결하는지 설명하시오.
->
C++에서 원시 포인터의 단점을 보완하고 힙 메모리 관리를 자동화하기 위해 설계된 클래스 템플릿입니다. RAII 원칙을 사용하여 포인터가 스코프를 벗어나거나 참조 카운트가 0이 되면 자동으로 delete를 호출하여 힙 메모리를 해제합니다.
std::unique_ptr은 한번에 하나의 unique_ptr만이 특정 힙 메모리 블록을 소유할 수 있도록 합니다. 소유권은 이동할 수 있지만 복사할 수 없습니다. unique_ptr이 소멸될 때 소유하고 있던 힙 메모리를 자동으로 delete합니다. delete 호출을 잊어버리거나 예외 발생 시에도 메모리가 자동으로 해제되므로 메모리 누수를 효과적으로 방지합니다.
std::shared_ptr은 여러 shared_ptr 인스턴스가 동일한 힙 메모리 블록을 공유할 수 있도록 합니다. 내부적으로 참조 카운트를 관리합니다. 참조 카운트가 0이 될 때 소유하고 있던 힙 메모리를 자동으로 delete합니다. 순환 참조가 없는 한 메모리 누수를 방지합니다.
std::weak_ptr은 shared_ptr의 순환 참조 문제를 해결하기 위해 사용됩니다. 메모리 소유권에 참여하지 않고 shared_ptr이 소멸되지 않았는지 약하게 참조합니다.
포인터를 new로 할당하고 delete로 잊어버리는 문제, 이미 해제된 메모리를 다시 해제하려는 문제, 이미 해제된 메모리를 가리키는 포인터(댕글링 포인터)가 남아있는 문제 등 스마트 포인터를 이용해 해결하고 try_catch 블록 없이도 예외 발생 시 스코프를 벗어나면서 메모리가 자동으로 해제되어 자원 누수를 막습니다.

지역 변수와 동적 할당: 함수 내에서 작은 크기의 객체나 배열을 선언할 때 스택에 할당하는 것이 유리한 이유와, 동적으로 크기가 변하거나 함수 호출 후에도 유지되어야 하는 데이터를 힙에 할당하는 이유를 설명하시오.
->
스택 할당은 단순한 포인터 증감 연산만으로 이루어지므로 힙 할당보다 훨씬 빠릅니다. 작은 객체나 지역 변수는 잦은 생성/소멸이 이루어지므로 이 속도 차이가 크게 작용합니다. 스택에 할당된 데이터는 연속적이고 지역성이 높아 CPU 캐시 적중률을 높여 전반적인 성능을 향상시킵니다. 스택에 할당된 메모리는 함수 스코프를 벗어나면 자동으로 해제되므로 메모리 누수 걱정이 없고 코드가 간결해집니다. 개발자가 수동으로 해제할 필요가 없습니다. 스택은 LIFO 방식으로 작동하므로 힙처럼 단편화 문제가 발생하지 않습니다.
힙 할당은 프로그램 실행 중에 필요한 메모리 크기가 결정되거나 변하는 경우에 사용합니다. 스택은 컴파일 시점에 크기가 고정되어야 합니다. 함수 호출이 끝난 후에도 데이터가 계속해서 존재하고 유지되어야 하는 경우에도 힙 할당을 사용합니다. 스택 데이터는 함수 종료와 함께 사라집니다. 스택 공간은 제한적입니다. (대략 몇 MB) 매우 큰 데이터 구조나 배열은 스택에 할당할 수 없으므로 힙에 할당해야 합니다. C++에서 다형적 객체를 동적으로 생성하고 기반 클래스 포인터로 다루려면 힙에 할당해야 합니다.

언리얼 엔진의 메모리 관리: 언리얼 엔진에서 UObject 기반 객체들이 주로 어떤 메모리 영역에 할당되며, 언리얼 엔진의 가비지 컬렉션(Garbage Collection) 시스템이 힙 메모리 관리에 어떤 역할을 하는지 설명하시오.
->
UE의 UObject 클래스 계층에 속하는 대부분의 객체는 엔진의 자체적인 메모리 관리 시스템(FMalloc, FMemory)을 통해 힙 메모리 영역에 할당됩니다. 이들은 C++의 표준 new/delete 키워드를 직접 사용하는 대신 newObject<>(), SpawnActor<>() 등의 UE 전용 함수를 통해 할당됩니다. 이 함수들은 엔진의 메모리 관리자와 가비지 컬렉터와 연동되도록 설계되어 있습니다.
UE는 C++ 기반임에도 불구하고 참조 추적 기반의 GC 시스템을 내장하고 있습니다. 이 시스템은 UObject 기반 객체들만 관리하며 일반 C++ 객체는 관리하지 않습니다.
개발자가 UObject 기반 객체를 명시적으로 delete할 필요 없이 더 이상 어떤 루트로부터도 참조되지 않는 UObject들을 주기적으로 탐지하여 힙 메모리에서 자동으로 해제합니다. UObject 시스템 내에서 참조가 끊긴 객체로 인한 메모리 누수를 효과적으로 방지합니다. UPROPERTY(), TWeakObjectPtr, TSharedPtr 등을 통해 객체 간의 참조 관계를 엔진에 알려주어 GC가 올바르게 작동하도록 돕습니다. GC는 특정 시점에 실행되어 프레임 드롭을 최소화하도록 최적화되어 있습니다.
엔진은 UObject들을 순회하며 Root Set(GWorld, GC 대상에서 제외될 객체들)부터 시작하여 모든 참조 가능한 객체들을 마킹합니다. 마킹되지 않은 객체들은 더 이상 사용되지 않는 것으로 간주되어 다음 GC 사이클에서 삭제(Sweep)됩니다.
UE는 UObejct에 대한 개발자의 수동 메모리 관리 부담을 줄이고 안정적인 힙 메모리 사용을 보장하기 위해 강력한 GC 시스템을 사용합니다. 그러나 UObject가 아닌 일반 C++ 객체의 힙 메모리 관리는 여전히 개발자의 책임입니다.

메모리 정렬(Memory Alignment): 메모리 정렬이 필요한 주된 이유(예: CPU 성능 최적화, 특정 데이터 타입의 요구사항)와 스택 및 힙 할당 시 메모리 정렬이 어떻게 처리될 수 있는지 설명하시오.
->
데이터를 메모리에 저장할 때 특정 데이터 타입의 시작 주소가 특정 값(정렬 요구사항)의 배수가 되도록 맞추는 것을 의미합니다. 예를 들어 4바이트 정렬은 시작 주소가 4의 배수여야 함을 의미합니다.
CPU는 데이터를 캐시라인이라는 단위(일반적으로 64바이트)로 메모리에서 읽어옵니다. 데이터가 캐시라인의 시작 주소에 정렬되어 있으면 CPU는 한번의 메모리 접근으로 필요한 모든 데이터를 효율적으로 캐시로 가져올 수 있습니다. 만약 데이터가 정렬되어 있지 않고 캐시라인의 경계를 넘어가면 CPU는 여러 캐시라인을 읽어와야 하거나 데이터를 두번에 걸쳐 읽어야 할 수 있어 성능 저하(캐시미스 증가)가 발생합니다.
일부 데이터 타입은 하드웨어 수준에서 강력한 정렬 요구사항을 가집니다. 이러한 요구사항을 충족하지 않으면 성능 저하를 넘어 프로그램 크래시나 미정의 동작을 일으킬 수 있습니다. 구조체 멤버 간의 패딩도 정렬 요구사항을 맞추기 위해 컴파일러가 삽입합니다. 멀티스레드 환경에서 아토믹 연산을 수행하거나 특정 데이터에 대한 동시성 접근을 보장할 때 올바른 정렬은 필수적입니다.
스택에서 컴파일러가 스택 프레임을 생성할 때 자동으로 정렬을 처리합니다. 컴파일러는 각 변수의 크기와 시스템의 기본 정렬 요구사항을 고려하여 스택 포인터를 조정하고 변수를 적절한 경계에 배치합니다. 개발자가 alignas 키워드를 사용하여 특정 변수나 구조체의 정렬을 명시적으로 지정할 수도 있습니다.
힙에서 표준 new/malloc 함수는 일반적으로 시스템의 기본 최대 정렬 요구사항(8 또는 16 바이트)을 만족하도록 메모리를 할당합니다. 하지만 특정 데이터 타입이 더 큰 정렬(32, 64 바이트 등)을 요구하는 경우 표준 할당자는 이를 보장하지 못할 수 있습니다. C++17부터는 new 키워드의 오버로드를 통해 정렬된 할당을 요청할 수 있으며 이전 버전에서는 _aligned_malloc(MSVC), posix_memalign(POSIX) 등 플랫폼 별로 정렬된 할당 함수를 사용하거나 커스텀 할당자를 구현하여 정렬 요구사항을 충족시켜야 합니다.
UE는 자체적인 메모리 할당자(FMemory)를 통해 플랫폼 및 엔진의 특정 정렬 요구사항을 내부적으로 처리합니다. 예를 들어 UObject들은 기본적으로 16바이트 정렬이 보장됩니다. 