C++의 std::map과 std::unordered_map의 내부 구현 방식과 각각의 시간 복잡도(평균 및 최악)를 비교하고, 어떤 상황에 더 효율적인지 설명하시오.
->
std::map은 RB트리 기반으로 항상 키-값 쌍이 정렬된 상태를 유지합니다. 삽입/삭제/검색 모두 O(logN)의 시간 복잡도를 가집니다. 데이터의 정렬이 중요하거나 최악의 경우 성능 보장이 필요할 때 유리합니다.
std::unordered_map은 해시 테이블 기반으로 키를 해시하여 빠르게 접근합니다. 평균적으로 삽입/삭제/검색 모두 O(1)의 시간 복잡도를 가지지만 최악의 경우 O(N)이 될 수 있습니다. 데이터 순서가 중요하지 않고 빠른 접근 속도가 필요할 때 효율적입니다.

C++17에 도입된 std::variant와 std::visit는 무엇이며, 여러 타입 중 하나를 저장하고 처리하는 데 어떻게 사용될 수 있는지 간단한 예시를 드시오.
->
std::variant는 여러 타입 중 단 하나의 타입만을 저장할 수 있는 타입-세이프한 공용체입니다. 잘못된 타입 접근을 방지합니다.
std::visit은 std::variant에 저장된 활성화된 타입에 따라 다른 동작을 수행하도록 도와주는 함수 템플릿입니다. 오버로드된 함수 객체나 람다를 사용하여 각 타입별 처리를 정의할 수 있습니다.

C++11에 도입된 기본 멤버 이니셜라이저(Default Member Initializers)는 무엇이며, 생성자 초기화 리스트와 비교했을 때 어떤 장단점이 있는지 설명하시오.
->
기본 멤버 이니셜라이저는 클래스 정의 시 멤버 변수에 직접 초기값을 지정하는 기능입니다. 여러 생성자에서 멤버를 중복 없이 한번만 초기화할 수 있어 코드의 가독성과 안전성을 높이는 장점이 있지만 생성자 초기화 리스트보다 먼저 실행되므로 초기화 순서에 대한 이해가 필요하며 복잡한 런타임 로직으로 초기화해야 할 때는 적합하지 않습니다.



3D 그래픽스 렌더링 파이프라인에서 "G-버퍼(G-Buffer)"는 무엇이며, 지연 셰이딩(Deferred Shading) 방식에서 어떤 중요한 역할을 하는지 설명하시오.
->
G-버퍼는 3D 그래픽스 렌더링에서 지연 쉐이딩(Deferred Shading) 방식에 사용되는 다중 렌더 타겟 집합입니다. 단일 패스에서 노멀, 위치/깊이, 알베도 등 쉐이딩에 필요한 기하학적 정보를 텍스처로 저장합니다. 지연 쉐이딩에서 광원 계산을 기하학적 정보 패스에서 분리하여 많은 광원이 존재하는 복잡한 씬에서 쉐이딩 연산의 효율성을 크게 향상시킵니다. 불필요한 픽셀에 대한 쉐이딩 연산을 방지하여 성능을 최적화합니다.

게임 루프(Game Loop)를 구현할 때 이벤트 기반(Event-driven) 방식과 폴링(Polling) 방식의 차이점을 설명하고, 각각의 장단점을 게임 개발 관점에서 설명하시오.
->
이벤트 발생 시에만 처리하는 이벤트 기반 방식은 유휴 시 자원 효율성이 높고 반응성이 뛰어나다는 장점이 있지만 코드 구조가 복잡해질 수 있고 특정 시간 간격의 업데이트 구현이 어렵습니다.
폴링 방식은 일정 시간 간격으로 상태를 주기적으로 확인하는 방식으로 구현이 단순하며 물리/애니메이션 등 시간 기반 로직 구현에 용이하지만 이벤트가 없어도 지속적으로 자원을 소모한다는 단점이 있습니다.
일반적으로 두 방식을 모두 채용하여 적절히 혼합하여 사용합니다.

3D 그래픽스에서 MSAA(Multi-Sample Anti-Aliasing)는 무엇이며, 계단 현상(Aliasing)을 줄이는 기본적인 원리를 설명하시오.
->
MSAA는 3D 그래픽스에서 계단 현상(Aliasing)을 줄이는 안티-에일리어싱 기법입니다. 각 픽셀 내에 여러개의 서브픽셀 샘플 위치를 정의하고 이 샘플들이 객체에 얼마나 커버되는지 검사합니다. 커버되는 샘플 수에 비례하여 객체 색상과 배경 색상을 혼합함으로서 날카로운 가장자리를 부드러운 그라데이션으로 표현하여 계단 현상을 완화합니다.



언리얼 엔진에서 리플리케이트(Replicated)되는 프로퍼티에 REPNOTIFY 지정자를 사용하는 목적은 무엇이며, 네트워크 복제 시 언제 Notified 함수가 호출되는지 설명하시오.
->
서버에서 클라이언트로 복제되는 프로퍼티의 값이 변경되었을 때 클라이언트에서 특정 함수를 자동으로 호출하도록 지시합니다. 이는 복제된 데이터 변경에 따른 시각적 업데이트나 게임 로직 처리에 사용됩니다.
클라이언트가 서버로부터 변경된 프로퍼티 값을 성공적으로 수신하고 적용한 직후에 호출됩니다. 서버에서는 호출되지 않습니다.

언리얼 엔진 애니메이션 시스템에서 "리타겟팅(Retargeting)"은 무엇이며, 서로 다른 스켈레톤을 가진 캐릭터 간에 애니메이션을 재사용할 때 어떻게 사용되는지 설명하시오.
->
서로 다른 스켈레톤 구조를 가진 캐릭터 간에 애니메이션 시퀀스를 재사용할 수 있도록 변환하는 과정입니다.
IK 릭 또는 휴머노이드 릭을 사용하여 소스 스켈레톤과 타겟 스켈레톤의 본을 매핑하고 애니메이션 에셋을 타겟 스켈레톤의 비율과 구조에 맞게 변환하여 자연스러운 애니메이션 재생을 가능하게 합니다.

언리얼 엔진의 에디터 유틸리티 위젯(Editor Utility Widget)을 사용하여 개발 워크플로우를 개선할 수 있는 구체적인 예시(예: 일괄 에셋 처리, 커스텀 툴)를 2가지 이상 제시하시오.
->
블루프린트 기반으로 커스텀 에디터 툴을 생성하여 개발 워크플로우를 자동화하고 개선합니다. 일괄 에셋을 처리하거나 커스텀 레벨을 구성하는 등 다양한 용도와 목적에 맞게 제작하여 사용할 수 있습니다.

언리얼 엔진 머티리얼(Material) 에디터에서 사용되는 주요 블렌드 모드(Blend Mode, 예: Opaque, Masked, Translucent, Additive)의 차이점과 각각의 일반적인 사용 목적을 설명하시오.
->
Opaque(불투명): 알파 채널을 고려하지 않고 완전히 불투명하게 렌더링됩니다. 대부분의 일반적인 불투명 오브젝트에 사용되며 가장 성능 효율적입니다.
Masked(마스크): 알파 채널을 0 또는 1로만 간주하여 픽셀이 완전히 투명하거나 불투명하게 마스킹됩니다. 나뭇잎, 울타리처럼 구멍이 뚫린 오브젝트에 사용됩니다.
Translucent(반투명): 알파 채널 값을 사용하여 반투명하게 렌더링됩니다. 유리, 물, 연기 등 투명/반투명 효과에 사용되며 드로우 오더에 민감합니다.
Additive(덧셈): 머터리얼 색상 값을 배경에 더하여 빛을 내는 효과를 줍니다. 불꽃, 광선, 에너지 효과 등 밝게 빛나는 파티클에 주로 사용됩니다.
