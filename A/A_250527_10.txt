C++20에 도입된 std::span은 무엇이며, 컨테이너의 일부를 안전하고 효율적으로 참조하여 함수에 전달할 때 어떻게 활용될 수 있는지 설명하시오.
->
C++20에 도입된 경량타입으로 컨테이너나 배열의 일부를 소유권 없이 참조합니다. 시작 포인터와 길이를 가지고 있어 동적으로 크기가 결정되는 뷰를 안전하고 효율적으로 함수에 전달할 수 있습니다. 이를 통해 불필요한 복사 없이 컨테이너의 특정 구간에 대한 접근을 허용하며 범위 기반 for문과 같은 C++11 이후의 기능과 잘 통합되어 사용됩니다.

C++에서 사용자 정의 타입을 std::unordered_map의 키(key)로 사용하려면, 해당 타입에 대해 무엇을 구현(오버로드)해야 하는지 설명하시오.
->
std::unordered_map의 키로 사용자 정의 타입을 사용하려면 해당 타입에 대해 2가지를 구현해야 합니다.
std::hash 특수화: 사용자 정의 타입의 객체를 입력으로 받아 size_t 타입의 해시값을 반환하는 operator()를 구현해야 합니다.
operator==(등가 비교 연산자): 두 사용자 정의 타입 객체가 동일한지 비교하는 operator==를 구현해야 합니다. 이는 해시 충돌 시 올바른 키를 찾기 위해 사용됩니다.

C++에서 예외(Exception)가 발생했을 때 스택 언와인딩(Stack Unwinding)이란 무엇이며, 이 과정에서 지역 객체의 소멸자가 어떤 순서로 호출되는지 설명하시오.
->
예외 발생 시 스택 언와인딩은 예외가 처리될 catch 블록을 찾을 때까지 현재 실행중인 함수의 스택 프레임을 하나씩 해제해 나가는 과정입니다. 이 과정에서 각 스택 프레임에 존재하는 지역 객체의 소멸자는 생성된 역순으로 호출됩니다. 이는 RAII 패턴을 통해 자원의 안전한 해제를 보장하는데 중요합니다.

3D 그래픽스에서 미리 곱해진 알파(Pre-multiplied Alpha)란 무엇이며, 일반적인 알파 블렌딩(Alpha Blending) 방식과 비교했을 때 블렌딩 아티팩트(Artifact)를 줄이는 데 어떤 장점이 있는지 설명하시오.
->
미리 곱해진 알파는 색상값이 이미 알파값과 곱해져 있는 형태의 알파 블렌딩 방식입니다. 즉 Color = OriginalColor * Alpha로 저장됩니다. 일반적으로 알파 블렌딩(Color = OriginalColor * Alpha + BackgroundColor * (1 - Alpha))과 비교했을 때 미리 곱해진 알파는 블렌딩 시 가장자리 아티팩트, 특히 투명한 오브젝트의 가장자리에 나타나는 어두운 테두리를 줄이는데 장점이 있습니다. 이는 다수의 투명 레이어가 블렌딩될 때 색상값이 더 정확하게 보존되기 때문입니다.

네트워크 게임 아키텍처에서 클라이언트-서버(Client-Server) 모델과 P2P(Peer-to-Peer) 모델의 주요 차이점과 각각의 장단점을 게임 장르별 적합성과 함께 비교하시오.
->
클라이언트-서버 모델은 모든 게임 로직과 데이터가 중앙 서버에서 관리됩니다. 클라이언트는 서버에 요청을 보내고 응답을 받습니다. 치트 방지에 용이하고 데이터 일관성 유지, 높은 안정성과 확장성을 가지나 서버 구축 및 유지보수 비용이 발생하고 서버 트래픽 증가 시 성능 저하, 핑 지연등의 문제점을 가집니다. MMORPG, FPS, RTS 등 대규모 동시접속이나 강력한 치트 방지가 필요한 경우 적합합니다.
P2P 모델은 각 플레이어의 클라이언트가 직접 서로 통신하며 게임 로직과 데이터를 분산하여 관리합니다. 서버 비용 절감, 낮은 핑, 쉬운 구현의 장점이 있으나 치트에 취약하고 네트워크 환경에 따른 불안정성, 낮은 확장성을 가집니다. 대전 격투 게임, 턴제 전략 게임, 소규모 협동 게임 등 실시간 동기화가 적고 네트워크 지연에 덜 민감하거나 P2P 특유의 장점을 활용하는 게임에 적합합니다.

의사 난수 생성기(Pseudo-random Number Generator, PRNG)에서 "시드(Seed)"의 역할은 무엇이며, 게임에서 예측 가능한 난수 시퀀스(예: 리플레이, 월드 생성)나 예측 불가능한 난수 시퀀스(예: 가챠)를 얻기 위해 어떻게 활용되는지 설명하시오.
->
의사 난수 생성기에서 시드는 난수 시퀀스를 시작하는 초기값입니다. 동일한 시드를 사용하면 항상 동일한 난수 시퀀스가 생성됩니다.
게임 리플레이, 월드 생성, 퍼즐 게임 등에서 시드를 저장하고 재사용하여 예측 가능한 결과를 얻습니다.
가챠 시스템, 아이템 드롭, 크리티컬 확률 계산 등 공정하고 예측 불가능한 결과를 위해 현재 시간과 같은 무작위적인 값으로 시드를 초기화합니다.

언리얼 엔진에서 GameModeBase 클래스와 GameMode 클래스의 주요 차이점은 무엇이며, 특히 멀티플레이어 게임에서 GameMode가 더 적합한 이유를 설명하시오.
->
GameModeBase는 모든 언리얼 엔진 게임의 기본 게임 모드 클래스입니다. 기본적인 게임 규칙, 플레이어 접속 관리, 스폰지점 결정 등의 기능을 제공합니다. 싱글플레이어 게임이나 매우 단순한 멀티플레이어 게임에 적합합니다.
GameMode는 GameModeBase를 상속받아 멀티플레이어 게임에 필요한 추가 기능들을 제공합니다. GameMode는 서버에서만 존재하며 클라이언트에 리플리케이션되지 않습니다. 이는 게임 규칙이 서버에서만 결정되고 클라이언트에는 전달되지 않아도 되는 경우에 유리합니다. 또한 플레이어 접속 관리, PlayerController 및 PlayerState 인스턴스 관리, 게임 상태 동기화 로직 구현에 더 적합합니다.
GameMode는 게임의 규칙과 상태를 서버에서 일관되게 관리하고 클라이언트 간의 동기화 및 접속 문제를 처리하는데 필요한 추가적인 유틸리티와 구조를 제공하므로 멀티플레이어 게임에 더 적합합니다.

언리얼 엔진의 애셋 레지스트리(Asset Registry)는 무엇이며, 에디터나 런타임에서 특정 조건(예: 특정 태그를 가진 애셋, 특정 클래스 타입의 애셋)에 맞는 애셋을 효율적으로 검색하는 데 어떻게 사용될 수 있는지 설명하시오.
->
언리얼 엔진의 에셋 레지스트리는 프로젝트 내 모든 에셋에 대한 정보를 저장하고 관리하는 데이터베이스입니다. 에디터 시작 시 또는 에셋이 추가/삭제될 때 자동으로 업데이트합니다.
에디터 환경에서는 컨텐츠 브라우저에서 특정 조건에 맞는 에셋을 필터링하거나 검색할 때 사용됩니다.
런타임에서는 게임 실행 중 특정 조건에 맞는 에셋 목록을 동적으로 로드하거나 참조할 필요가 있을 때 에셋 레지스트리 API를 사용하여 효율적으로 에셋 경로를 쿼리할 수 있습니다. 예를 들어 특정 게임모드에 사용할 모든 캐릭터 에셋을 미리 찾아놓는 경우 등에 활용됩니다. 에셋을 직접 로드하는 대신 에셋의 메타데이터만으로 검색을 수행하여 오버헤드를 줄입니다.

언리얼 엔진 머티리얼(Material)의 블렌드 모드(Blend Mode, 예: Opaque, Masked, Translucent) 설정에 따라 Depth Buffer(깊이 버퍼) 쓰기 동작이 어떻게 달라지는지 설명하고, 각각의 일반적인 사용 목적을 설명하시오.
->
Opaque는 항상 뎁스버퍼에 뎁스값을 씁니다. 대부분의 불투명한 오브젝트 렌더링에 사용됩니다. 가장 효율적인 블렌딩 모드입니다.
Masked는 픽셀의 알파값이 임계치를 넘을 경우에만 뎁스버퍼에 뎁스값을 씁니다. 알파값이 임계치 미만인 픽셀은 버려지므로 뎁스버퍼에 쓰지 않습니다. 나뭇잎, 울타리, 그물, 잔디 등 완전히 불투명하거나 완전히 투명한 영역만 존재하는 오브젝트를 표현할 때 사용됩니다.
Translucent는 기본적으로 뎁스버퍼에 뎁스값을 쓰지 않습니다. 이는 투명 오브젝트의 올바른 정렬을 위해 투명 오브젝트는 뎁스 프리패스 후에 가장 나중에 렌더링되고 다른 오브젝트의 깊이 정보를 가리지 않기 위함입니다. 유리, 물, 연기, 불, 특수효과 등 반투명한 오브젝트를 표현할때 사용됩니다. 뎁스값을 쓰지 않으므로 렌더링 순서에 주의해야 합니다.

언리얼 엔진 C++에서 사용자 정의 애니메이션 노티파이(Anim Notify)를 생성하고 애니메이션 시퀀스에 추가하여, 특정 애니메이션 프레임에서 C++ 코드를 실행시키는 과정을 설명하시오.
->
먼저 UAnimNotify 또는 UAnimNotifyState를 상속받는 C++ 클래스를 생성합니다. UAnimNotify는 단발성 이벤트를, UAnimNotifyState는 특정 기간 동안의 이벤트를 발생시킵니다.
Notify() 또는 NotifyBegin(), NotifyEnd()를 오버라이드합니다. 해당 이벤트가 발생했을 때 호출되는 함수들로서 원하는 동작을 C++ 코드로 구현합니다.
애니메이션 시퀀스 타임라인에 추가합니다. 노티파이 트랙에서 마우스 우클릭하여 Add Notify 또는 Add NotifyState를 선택한 후 생성한 노티파이 클래스를 선택합니다.
코드에서 중단점을 건 후 게임을 플레이하여 애니메이션이 재생되었을 때 노티파이가 정상적으로 불리는지, 동작이 정상인지 확인합니다.
