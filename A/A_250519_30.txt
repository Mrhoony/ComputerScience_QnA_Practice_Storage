C++에서 enum과 enum class의 차이점을 설명하고, enum class 사용 시 장점에 대해 설명하시오.
->
enum: 열거자 이름이 enum 스코프 외부로 유출되어 다른 enum이나 변수와의 이름 충돌 가능성이 있습니다. 열거형 값이 정수 타입으로 암시적으로 변환될 수 있습니다. 기저 타입을 명시적으로 지정할 수 없습니다.
enum class: C++11에서 도입되었습니다. 열거자 이름이 enum class 스코프 내부에 존재하며 열거자 접근 시 EnumClass::Enumerator와 같이 스코프 지정 연산자를 사용해야 합니다. 이름 충돌의 위험이 없습니다. 열거형 값이 정수타입으로 암시적으로 변환되지 않습니다. 명시적 타입 캐스팅을 통해서만 변환 가능합니다. enum class MyEnum : unsigned char { ... }와 같이 기저 타입을 명시적으로 지정할 수 있습니다.
enum class 사용 시 이름 충돌을 방지하고 타입 안전성이 강화됩니다.

C++ 변수의 스토리지 기간(Storage Duration: automatic, static, dynamic, thread_local)에 대해 설명하고, 각각 어떤 키워드로 선언되며 메모리 생명주기는 어떻게 되는지 설명하시오.
->
변수의 스토리지 기간은 메모리가 언제 할당되고 해제되는지 변수의 생명주기를 결정합니다.
Automatic Storage Duration: 키워드 없이 함수 내 지역 변수, 함수 매개변수에 사용됩니다. 스코프를 진입할 때 생성되고 벗어날 때 소멸됩니다.
Static Storage Duration: static 키워드나 전역 변수, 네임스페이스 범위 변수에 사용됩니다. 프로그램이 시작될 때 할당되고 프로그램이 종료될 때까지 유지됩니다.
Dynamic Storage Duration: new, delete 키워드를 사용합니다. 프로그래머가 명시적으로 new를 호출하여 힙 메모리에 할당하고 delete를 호출하여 해제하기 전까지 유지됩니다.
Thread-local Storage Duration: thread_local 키워드를 사용합니다. 해당 변수를 포함하는 스레드가 시작될 때 할당되고 스레드가 종료될 때 해제됩니다. 각 스레드는 독립적인 복사본을 가지며 스레드 간 공유되지 않는 데이터를 저장할 때 유용합니다.

C++ 컴파일러 최적화 중 하나인 복사 생략(Copy Elision)에 대해 설명하고, 어떤 경우에 발생할 수 있는지 간단한 예시를 드시오.
->
컴파일러가 프로그램의 의미를 바꾸지 않는 선에서 객체의 복사 생성자나 이동 생성자 호출을 생략하고 객체를 원래 생성될 위치에 직접 생성하는 최적화 기법입니다. RVO, NRVO, 임시 객체 전달/생성에서 발생합니다.

C++에서 volatile 키워드는 언제, 왜 사용하며 어떤 의미를 가지는지 설명하시오.
->
volatile 키워드는 특정 변수의 값이 언제든지 예기치 않게 변할 수 있음을 컴파일러에게 알려줍니다. volatile로 선언된 변수는 컴파일러가 최적화를 위해 레지스터에 캐싱하거나 읽기/쓰기 작업에 대한 최적화를 진행하지 않고 반드시 접근할때마다 메모리에서 직접 값을 읽어오고 메모리에 즉시 쓰도록 강제합니다.

C++17에 도입된 구조적 바인딩(Structured Bindings)이란 무엇이며, 어떤 경우에 코드를 간결하게 만들 수 있는지 간단한 예시를 드시오.
->
구조적 바인딩은 배열, 구조체/클래스, std::pair, std::tuple과 같은 타입의 요소를 여러개의 독립적인 변수로 한번에 분해하거나 언팩하여 선언하고 초기화할 수 있게 해주는 문법입니다.
auto [key, value] = GetData()와 같이 GetData()가 std::pair를 반환하는 경우 첫번째 요소는 key, 두번째 요소는 value 변수에 즉시 바인딩 됩니다.

C++에서 객체 초기화 방법(예: Direct Initialization, Copy Initialization, List Initialization)들을 제시하고, 각각의 특징이나 차이점을 설명하시오.
->
Direct Initialization: int a(10)과 같이 ()를 사용하여 초기화합니다. 인자의 타입과 개수에 맞는 생성자를 찾아서 호출합니다.
Copy Initialization: int a = 10과 같이 =을 사용하여 초기화합니다. 우측값의 임시 객체를 생성하거나 변환한 후 임시 객체를 사용하여 새 객체를 초기화합니다. 복사 생성자 또는 이동 생성자가 호출됩니다. 암시적 타입 변환이 발생할 수 있습니다.
List Initialization: int a[]{1, 2, 3}과 같이 {}를 사용하여 초기화합니다. 중괄호 기반의 통일된 문법으로 std::initializer_lit 우선 및 축소 변환 방지 특징을 가집니다.

함수 내부에서 선언된 static 변수와 전역 변수의 차이점을 스코프(Scope)와 생명주기(Lifetime) 관점에서 설명하시오.
->
전역변수: 파일 스코프 또는 네임스페이스 스코프를 가집니다. 프로그램의 어느 위치에서든 접근할 수 있습니다. 정적 스토리지 기간의 생명주기를 가집니다.
함수 내부의 static 변수: 로컬 스코프를 가집니다. 해당 변수가 선언된 함수 내부에서만 접근할 수 있습니다. 정적 스토리지 기간의 생명주기를 가지지만 초기화는 해당 변수의 선언문이 프로그램 실행 중 처음으로 도달했을 때 한번만 수행됩니다.

멀티스레딩 환경에서 공유 자원에 대한 안전한 접근을 보장하기 위해 std::mutex와 std::lock_guard를 어떻게 함께 사용하는지 간단한 코드로 설명하시오.
->
std::mutex mtx1과 같이 뮤텍스를 선언합니다. 이후 잠금 및 해제가 필요한 스코프 내에서 std::lock_guard<std::mutex> guard1(mtx1)을 선언하여 선언과 동시에 영역에 대한 lock을 생성합니다. 이후 스코프를 벗어나면 std::lock_guard가 소멸하면서 영역에 대한 unlock이 이루어집니다.

C++11에 도입된 완벽한 전달(Perfect Forwarding)의 개념과 std::forward의 역할에 대해 간략히 설명하시오.
->
완벽한 전달은 함수 템플릿에서 인자를 다른 함수로 전달할 때 원래 인자의 값 범주와 cs-한정자를 그대로 유지하여 전달하는 기법입니다. 이는 전달받는 함수(복사 생성자, 이동 생성자 등)에서 원래 인자에 가장 잘 맞는 오버로드된 함수가 호출되도록 보장합니다.
std::forward는 완벽한 전달을 가능하게 하는 표준 라이브러리 유틸리티입니다. 함수 템플릿에서 T&& 형태의 전달 참조로 인자를 받을 때 사용됩니다. std::forward<T>(arg)는 인자 arg를 rvalue라면 우측값 참조(&&)로, lvalue라면 좌측값 참조(&)로 조건부로 캐스팅하는 역할을 합니다.

C++ 함수 선언/정의 시 사용되는 noexcept 키워드는 무엇이며, 어떤 의미를 가지나요?
->
noexcept 키워드는 함수 선언 또는 정의 끝에 붙는 지정자입니다. 이 함수가 실행 중에 예외를 던지지 않음을 컴파일러에게 알려주는 역할을 합니다. 예외가 발생할 가능성이 전혀 없거나 예외 발생 시 복구가 불가능하여 프로그램 종료가 유일한 선택인 함수에 사용합니다.

기본적인 정렬 알고리즘(예: 버블 정렬, 퀵 정렬, 병합 정렬)의 동작 방식(개념)을 간략히 설명하고, 각각의 평균 시간 복잡도를 제시하시오.
->
버블정렬: 인접한 두 요소를 비교하여 정렬 순서가 맞지 않으면 교환하는 과정을 처음부터 끝까지 반복합니다. 평균 시간 복잡도는 O(N^2)입니다.
퀵정렬: 분할 정복 방식으로 하나의 중점을 정하고 중점을 기준으로 컨테이너를 2개로 구분합니다. 중점보다 크면 우측으로 작으면 좌측으로 이동합니다. 컨테이너 분할이 불가능할때까지 각 컨테이너에 재귀적으로 퀵정렬을 수행합니다. 평균 시간 복잡도는 O(NlogN)입니다.
병합정렬: 퀵정렬과 같이 분할 정복 방식입니다. 컨테이너를 더 이상 나눌 수 없을때(나눠진 컨테이너의 요소가 1개일 때) 까지 두개의 하위 컨테이너로 분할합니다. 분할된 하위 리스트들을 병합하는 과정에서 정렬을 수행합니다. 평균 시간 복잡도는 O(NlogN)입니다.

해시 테이블에서 충돌 해결 방법 중 개방 주소법(Open Addressing) 방식(예: 선형 조사법, 제곱 조사법)의 기본적인 아이디어를 설명하시오. (앞선 체이닝과 구분)
->
개방 주소법은 해시 테이블에서 충돌이 발생했을 때 인접한 빈 버킷을 찾아서 데이터를 저장하는 방식입니다. 한 버킷에는 한 요소만 저장하도록 하며 이와 같은 방법은 각 버킷에 요소들의 연결 리스트를 저장하여 한 버킷에 여러 요소를 저장하는 분리 연결법과 대비되는 방식입니다.
선형 조사법은 충돌 시 현재 버킷 인덱스에서 일정한 간격(보통 1)을 더해가며 순차적으로 다음 버킷을 확인하고 제곱 조사법은 충돌 시 현재 버킷 인덱스에서 제곱만큼 떨어진 간격으로 다음 버킷을 확인합니다.
해시 함수를 한번 더 사용해 두개의 서로다른 해시 함수를 사용하는 이중 해싱 방법도 있습니다. 데이터가 특정 부분에 밀집되는 군집화 문제를 가장 효과적으로 줄이는 방법입니다.

TCP/IP 4계층 모델(또는 OSI 7계층 모델)에서 애플리케이션 계층, 전송 계층, 인터넷 계층, 네트워크 인터페이스 계층의 역할을 간략히 설명하시오. (게임 클라이언트와 관련된 계층 위주)
->
애플리케이션 계층: 사용자가 네트워크 서비스에 접근할 수 있도록 하는 최상위 계층입니다. 게임 클라이언트 프로그램은 이 계층에서 동작합니다.
전송 계층: 애플리케이션 계층의 프로세스들 간 데이터 전송 서비스를 제공합니다. TCP, UDP 프로토콜을 사용합니다. 포트번호를 사용하여 데이터를 올바른 애플리케이션 프로세스로 전달합니다. 게임 클라이언트는 TCP 또는 UDP를 선택하여 게임 서버와 통신합니다.
인터넷 계층: 데이터를 패킷 단위로 캡슐화하고 출발지와 목적지의 IP 주소를 사용하여 네트워크 상에서 패킷을 라우팅하는 역할을 합니다. 클라이언트와 서버의 IP주소를 사용해 게임 데이터 패킷이 올바른 목적지로 전달됩니다.
네트워크 인터페이스 계층: 실제 물리적인 네트워크 매체를 통해 데이터를 프레임단위로 전송하고 수신하는 역할을 합니다. 클라이언트 PC의 네트워크 카드와 드라이버가 이 계층에서 동작하며 게임 데이터가 전기 신호 등으로 변환되어 네트워크를 통해 전송됩니다.

CPU 캐시 메모리(Cache Memory)에서 캐시 라인(Cache Line)의 개념과 데이터 지역성(Locality of Reference)이 성능에 미치는 영향에 대해 설명하시오.
->
캐시 라인은 CPU 캐시와 메인 메모리 간에 데이터를 전송하는 최소 단위입니다. CPU가 메인 메모리의 특정 주소에 있는 데이터에 접근하려고 할 때, 해당 주소가 포함된 캐시 라인 전체가 메인 메모리에서 캐시로 한번에 로드됩니다.
데이터 지역성은 프로그램이 메모리에 접근하는 패턴이 시간적 지역성과 공간적 지역성을 보이는 경향을 말합니다. 시간적 지역성은 최근에 사용된 데이터는 곧 다시 사용될 가능성이 높다는 특성이고 공간적 지역성은 최근에 사용된 데이터 근처에 있는 데이터는 곧 사용될 가능성이 높다는 특성입니다.
캐시 메모리는 데이터 지역성을 활용하여 성능을 극대화합니다.
Cache Hit은 CPU가 필요한 데이터가 이미 캐시에 로드되어 있는 경우이며 Cache Miss는 데이터가 캐시에 없는 경우를 말합니다. Cache Miss의 경우 메인 메모리의 캐시 라인을 캐시로 가져오기 때문에 성능 저하가 발생합니다. 지역성이 높을수록 캐시 히트율이 높아져 프로그램 실행 성능이 높아집니다. 배열을 순차적으로 접근하는 경우 공간적 지역성이 높아 캐시 효율이 좋지만 메모리가 흩어져 있는 연결 리스트 노드를 따라가는 것은 공간적 지역성이 낮아 캐시 효율이 떨어집니다.

메모리 단편화(Memory Fragmentation)의 두 가지 유형(내부 단편화, 외부 단편화)을 설명하시오.
->
메모리 단편화는 메모리 공간이 사용되지 않는 작은 조각들로 나뉘어 비효율적으로 사용되는 현상을 말합니다.
내부 단편화는 할당된 메모리 블록의 크기가 요청된 크기보다 커서 할당된 블록 내부에 사용되지 않는 공간이 발생하는 현상입니다. 4KB 단위로 메모리를 할당하느 시스템에서 3KB만 사용하면 1KB는 내부 단편화 공간이 됩니다.
외부 단편화는 전체 사용 가능한 메모리 공간의 총합은 요청된 크기보다 크지만 사용 가능한 공간이 여러개의 작은 서로 떨어져있는 블록으로 흩어져 있어서 요청된 크기의 연속적인 블록을 할당할 수 없는 현상입니다. 10KB의 사용 가능한 메모리가 2KB, 3KB, 5KB로 나뉘어 존재할 때 6KB의 연속적인 메모리를 요청하면 할당이 불가능한 경우가 발생합니다.

운영체제의 프로세스 스케줄링 방식 중 선점형(Preemptive) 스케줄링과 비선점형(Non-preemptive) 스케줄링의 차이점을 설명하시오.
->
프로세스 스케줄링은 CPU를 어떤 프로세스에게 얼마나 오랫동안 할당할지를 결정하는 운영체제의 기능입니다.
선점형 스케줄링은 운영체제가 현재 CPU를 사용하고 있는 프로세스를 강제로 중단시키고 다른 프로세스에세 CPU를 할당할 수 있는 방식입니다. 시간 할당량이 만료되거나 더 높은 우선순위의 프로세스가 준비된 경우, 인터럽트가 발생한 경우에 선점형 스케줄링이 동작합니다. 각 프로세스에게 공평한 CPU 사용 시간을 제공하고 응답성이 중요한 작업에 유리합니다. 대부분의 운영체제에서 이 방식을 사용합니다.
비선점형 스케줄링은 한번 CPU를 할당받은 프로세스는 스스로 CPU 사용을 중지하거나 작업이 완료될 때까지 CPU를 계속 사용하며 운영체제가 임의로 프로세스를 중단시킬 수 없습니다.구현이 선점형보다 단순하며 컨텍스트 교환 오버헤드가 적습니다. 그러나 다른 프로세스의 실행을 무한정 지연시키는 기아 상태가 발생할 수 있습니다.

데이터 압축(Data Compression)이 필요한 주된 이유(게임 리소스, 네트워크 통신 등)와 기본적인 압축 기법(손실/비손실)의 개념을 설명하시오.
->
저장 공간을 절약하고 데이터 전송 대역폭을 줄이며 로딩 시간을 단축하기 위해 데이터 압축이 필요합니다.
비손실 압축은 압축된 데이터를 복원했을 때 손실이 전혀 없는 기법입니다. 데이터의 중복성이나 통계적 특성을 찾아 더 짧은 코드로 대체하는 방식입니다. 허프만 코딩 기법이 대표적입니다.
손실 압축은 압축 과정에서 사람이 인지하기 어렵거나 덜 중요한 데이터를 일부 삭제하여 압축률을 높이는 기법 입니다. 이미지, 오디오, 비디오 등 약간의 품질 저하가 허용되는 멀티미디어 데이터에 주로 사용됩니다.

그래프(Graph) 자료구조에서 너비 우선 탐색(BFS)과 깊이 우선 탐색(DFS)의 탐색 순서 차이점을 설명하고, 각각 어떤 문제 해결에 적합한지 간단한 예시를 드시오.
->
너비 우선 탐색은 시작 노드부터 가까운 노드들을 먼저 탐색합니다. 큐를 사용하여 방문할 노드를 관리합니다. 최단 경로를 찾거나 모든 노드에 방문해야 할 경우 사용됩니다.
깊이 우선 탐색은 시작 노드에서 한방향으로 가장 가능한 깊이 들어가면서 노드를 탐색합니다. 더 이상 깊이 갈수없다면 되돌아와서(백트래킹) 다른 방향으로 다시 탐색을 진행합니다. 스택을 사용하거나 재귀 호출을 통해 구현됩니다. 모든 경로를 탐색하거나 특정 경로를 따라 끝까지 가야할 경우 사용됩니다.

엔디언(Endianness: Little-endian vs Big-endian)이란 무엇이며, 네트워크 통신이나 파일 입출력 시 왜 이를 고려해야 하는지 설명하시오.
->
엔디언은 컴퓨터 메모리에서 멀티바이트 데이터 타입을 저장할 때 바이트들의 순서를 결정하는 방식입니다.
리틀 엔디언: 데이터의 가장 낮은 유효 바이트(LSB)가 메모리의 가장 낮은 주소에 저장되고 가장 높은 유효 바이트(MSB)가 가장 높은 주소에 저장되는 방식입니다. 0x12345678은 메모리에 78 56 34 12 순서로 저장됩니다. 대부분의 x86 계열 CPU에서 사용됩니다.
빅 엔디언: 데이터의 가장 높은 유효 바이트(MSB)가 가장 낮은 주소에 저장되고 가장 낮은 유효 바이트가 가장 높은 주소에 저장되는 방식입니다. 0x12345678은 메모리에 12 34 56 78 순서로 저장됩니다. 네트워크 프로토콜, RISC 계열 CPU에서 사용됩니다.
서로 다른 엔디언 방식을 사용하는 두 컴퓨터가 네트워크를 통해 멀티바이트 데이터를 교환할 때 바이트 순서가 바뀌어 데이터를 잘못 해석하게 됩니다. 이를 방지하기 위해 네트워크 통신에서는 빅 엔디언 방식을 사용하고 송수신 측에서 필요에 따라 바이트 순서를 변환해야 합니다. 파일 입출력 시 특정 엔디언 방식으로 바이너리 파일을 저장한 후 다른 엔디언 방식으로 읽으려고 하면 데이터 값을 잘못 해석할 수 있어 파일 포맷을 정의하거나 파싱할 때 엔디언을 명시적으로 처리, 모든 플랫폼에서 동일한 엔디언으로 파일을 읽고 쓰도록 규칙을 정해야합니다.

컴파일러(Compiler)와 인터프리터(Interpreter)의 차이점을 설명하시오.
->
컴파일러는 프로그램 실행 전 소스 코드 전체를 한번에 읽어들여 컴퓨터가 실행할 수 있는 코드로 변환합니다. 변환된 결과물은 원본 소스 코드 없이도 동작합니다. 실행 속도가 빠르고 오류는 컴파일 시점에 발견됩니다.
인터프리터는 프로그램 실행 시 소스 코드를 한줄씩 또는 명령어 단위로 읽어들여 즉석에서 번역하고 실행합니다. 별도의 실행 파일을 생성하지 않고 프로그램 실행 시 소스 코드가 필요합니다.

언리얼 엔진 애니메이션 시스템에서 애니메이션 몽타주(Animation Montage)는 무엇이며, 어떤 경우(예: 스킬 사용, 피격 애니메이션)에 사용되는지 설명하시오.
->
여러 개의 개별 애니메이션 시퀀스나 다른 몽타주를 하나로 묶어서 관리하고 재생 순서, 속도, 블렌딩, 노티파이 등을 제어할 수 있는 복합적인 애니메이션 에셋입니다. 애니메이션 시퀀스의 변형이 필요한 경우에 사용합니다.

언리얼 엔진 AI 시스템에서 감각 시스템(Perception System, 예: 시각, 청각 감지)은 어떻게 작동하며, AI 캐릭터가 플레이어나 다른 오브젝트를 인식하도록 구현하는 기본적인 아이디어를 설명하시오.
->
AI Controller에 PerceptionComponent를 등록하고 PerceptionComponent에서 감지할 감각을 설정합니다. 각각의 AISense에서 감지에 대한 데이터를 획득할 수 있고 PerceptionComponent에서 감지된 객체 리스트를 받아 추가적인 계산을 진행할 수 있습니다.

언리얼 엔진 AI 시스템에서 내비게이션 메시(Navigation Mesh, Nav Mesh)는 무엇이며, AI 캐릭터의 경로 탐색(Pathfinding)에 어떻게 사용되는지 설명하시오.
->
AI 캐릭터가 이동할 수 있는 월드 공간의 표면 영역을 추상화하여 표현한 데이터입니다. 레벨에 배치된 NavMeshBoundsVolume을 통해 이동이 불가능한 오브젝트를 제외한 walkable한 영역 위에 자동 생성되는 3D 메시 형태의 데이터 구조입니다.
경로 탐색 시 AIController 또는 명령 주체가 출발지와 목적지를 포함하여 이동을 요청합니다. Nav Mesh 내 출발지와 목적지가 존재하는 지 확인한 후 NavMesh의 폴리곤들을 노드로 인접 폴리곤의 연결을 엣지로 간주하여 그래프 탐색 알고리즘을 실행하여 목적 폴리곤까지 도착하는 경로를 찾습니다.

언리얼 엔진의 파티클 시스템(FX) 중 Cascade와 Niagara의 차이점 및 Niagara의 장점에 대해 간략히 설명하시오.
->
Cascade는 언리얼 엔진 4의 주력 파티클 시스템이고 Niagara는 언리얼 엔진 4 후반부터 도입되어 언리얼 엔진 5의 주력 파티클 시스템입니다.
Niagara는 복잡하거나 대규모 파티클 시뮬레이션에서 뛰어난 성능을 제공하며 저수준의 모듈 스크립트를 직접 설정하거나 편집할 수 있고 데이터 중심, 통합 스크립팅으로 파티클 생성 및 동작 방식을 보다 세밀하게 커스터마이징 할 수 있고 모듈 구조로 이루어져 재사용이 용이합니다.

언리얼 엔진에서 Gameplay Tag는 무엇이며, 어떤 목적으로 사용될 수 있는지 실무적인 예시(예: 상태 표현, 시스템 필터링)를 들어 설명하시오.
->
언리얼 엔진의 Gameplay Tags 시스템은 게임 내 요소들을 분류하고 식별하기 위한 계층적인 이름 시스템입니다. 태그 기반의 프로그래밍이 가능하여 클라이언트와 서버의 통신 간 복잡한 구조체를 보낼 필요 없이 태그네임만 보내 통신할 수 있고 스킬/능력을 사용하고 상태를 표현하거나 규칙을 적용할 수 있으며 데이터 및 에셋과의 연동도 가능합니다.

언리얼 엔진의 데이터 테이블(Data Table)은 무엇이며, 주로 어떤 종류의 데이터(예: 스탯 정보, 아이템 정보)를 관리하는 데 사용되는지 설명하시오.
->
데이터 테이블은 구조화된 게임 데이터를 관리하기 위한 에셋 타입입니다. 스프레드시트 형태로 데이터를 작성하고 엔진으로 임포트하여 데이터 테이블 에셋으로 변환합니다. 아이템이나 몬스터 등 특정 구조체의 구조를 따르는 형태의 데이터를 그룹으로 관리하는 데 사용합니다.

언리얼 엔진에서 게임 상태나 플레이어 데이터를 저장하고 불러오는 SaveGame 시스템의 기본적인 사용법과 목적을 설명하시오.
->
게임의 진행 상태나 플레이어 관련 데이터를 로컬 PC에 저장하여 나중에 게임을 다시 진행할 때 상태와 데이터를 불러올 수 있도록 하는 것이 목적입니다.
USaveGame의 파생 클래스를 생성하고 저장할 데이터에 대해 직렬화를 적용합니다. 저장 시점에 메모리 상의 저장할 데이터를 USaveGame 클래스 내 선언한 변수에 담아 저장하며 불러올 때 파일이 미리 있는지 확인하고 USaveGame 인스턴스를 역직렬화하여 메모리 상에 저장된 데이터를 올려 사용합니다.

언리얼 엔진 C++에서 UPROPERTY 매크로에 사용되는 주요 지정자(Specifier, 예: EditAnywhere, VisibleAnywhere, BlueprintReadWrite, Transient)들의 의미와 역할을 설명하시오.
->
EditAnywhere: 언리얼 에디터의 디테일 패널 어디서든 편집이 가능합니다.
VisibleAnywhere: 언리얼 에디터의 디테일 패널 어디서든 보는 것만 가능합니다.
BlueprintReadWrite: 블루프린트에서 읽고 쓰기가 가능합니다.
BlueprintReadOnly: 블루프린트에서 읽기만 가능합니다.
Transient: 이 지정자를 소유한 변수는 객체가 저장되거나 로딩될 때 직렬화 대상에서 제외됩니다. 런타임 중에만 필요한 임시 데이터를 저장하는 변수에 사용합니다.
ReplicatedUsing: 네트워크 환경에서 서버에 의해 클라이언트로 복제되며 복제될 때 지정된 OnRep 함수를 호출합니다.

언리얼 엔진에서 C++ 클래스를 블루프린트로 확장하거나 블루프린트에서 C++ 함수를 호출할 때, BlueprintNativeEvent와 BlueprintImplementableEvent의 차이점을 설명하시오.
->
BlueprintImplementableEvent는 함수의 선언만 C++ 코드에 작성하고 구현은 블루프린트에서 합니다.
BlueprintNativeEvent는 함수의 선언과 구현 모두 C++ 코드에서 작성할 수 있지만 블루프린트에서 해당 함수를 오버라이드하여 사용할 수 있습니다.

언리얼 엔진 에디터 유틸리티 위젯(Editor Utility Widget)은 무엇이며, 개발 워크플로우 개선에 어떻게 활용될 수 있는지 간단한 예시를 드시오.
->
언리얼 엔진 에디터 내에서 실행되는 UMG 위젯으로 게임플레이 중이 아닌 에디터 환경에서 동작하며 블루프린트 스크립팅을 통해 에디터 기능, 에셋, 월드에 접근하고 조작할 수 있습니다. 아트, 기획, QA 등 다른 팀의 요청에 따라 개발에 필요한 기능을 생성하여 작업의 편의성을 제공할 수 있습니다.