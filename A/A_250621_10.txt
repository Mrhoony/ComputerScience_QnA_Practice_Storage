RPC(Remote Procedure Call)와 Property Replication의 기본 개념: 언리얼 엔진에서 RPC와 Property Replication은 각각 무엇이며, 멀티플레이어 게임에서 클라이언트와 서버 간에 어떤 종류의 데이터(행동 vs 상태)를 동기화하기 위해 사용되는지 설명하시오.
->
RPC는 원격 프로시저 호출의 줄임말로 네트워크를 통해 다른 머신에 있는 함수를 마치 로컬 함수처럼 호출하여 실행하는 매커니즘입니다. 주로 행동 또는 이벤트를 동기화하는데 사용됩니다. 일회성 동작을 서버에 알리거나 서버가 모든 클라이언트에 특정 이벤트를 발생시키고자 할 때 사용됩니다.
Property Replication은 UObject 또는 AActor의 특정 프로퍼티(변수)의 값을 네트워크를 통해 자동으로 클라이언트와 서버 간에 동기화하는 매커니즘입니다. 서버의 프로퍼티 값이 변경되면 해당 변경 사항이 자동으로 클라이언트에 전송되어 클라이언트의 해당 프로퍼티 값을 업데이트합니다. 주로 상태 또는 데이터를 동기화하는데 사용됩니다. 지속적으로 유지되거나 주기적으로 업데이트되는 값을 동기화할 때 사용됩니다.

RPC의 종류와 호출 컨텍스트: UFUNCTION(Server), UFUNCTION(Client), UFUNCTION(NetMulticast) 매크로로 선언된 RPC의 동작 방식과 각각의 호출 주체(어디서 호출하는지) 및 실행 컨텍스트(어디서 실행되는지)를 명확히 구분하여 설명하시오.
->
UE의 RPC는 UFUNCTION 매크로와 함께 Server, Client, NetMulticast 키워드를 사용하여 선언됩니다. 
UFUNCTION(Server)는 클라이언트가 서버에게 특정 함수를 실행해달라고 요청합니다. 클라이언트에서 호출하고 서버에서 실행됩니다. 클라이언트의 행동을 서버에 알려 서버에서 해당 행동을 검증하고 실제 게임 로직을 처리할 때 사용됩니다.
UFUNCTION(Client)는 서버가 특정 클라이언트에게 특정 함수를 실행해달라고 명령합니다. 서버에서 호출하고 해당 클라이언트에서 실행됩니다. 서버가 특정 클라이언트에게만 알려줘야 하는 정보를 전달하거나 해당 클라이언트의 특정 로직을 실행하도록 지시할 때 사용됩니다.
UFUNCTION(NetMulticast)는 서버가 모든 연결된 클라이언트에게 특정 함수를 실행해달라고 명령합니다. 서버에서 호출하고 서버와 모든 연결된 클라이언트에서 동시에 실행됩니다. 모든 플레이어에게 보여지거나 영향을 미치는 이벤트를 동기화할 때 사용됩니다.

Property Replication 메커니즘: UPROPERTY(Replicated)로 선언된 프로퍼티가 서버에서 클라이언트로 동기화되는 기본적인 메커니즘을 설명하시오. DOREPLIFETIME 매크로의 역할은 무엇인가요?
->
UPROPERTY(Replicated) 매크로로 선언된 프로퍼티는 해당 프로퍼티가 속한 액터 또는 컴포넌트의 복제가 활성화되어 있고 서버 권한을 가질 때만 서버에서 클라이언트로 동기화됩니다.
서버에서 UPROPERTY(Replicated)로 선언된 변수의 값이 변경됩니다. 리플리케이션 시스템은 변경된 프로퍼티를 더티 상태로 표시합니다. 일정 간격 또는 특정 이벤트 발생 시 서버는 더티로 표시된 프로퍼티들의 변경 사항을 감지합니다. 변경된 프로퍼티의 새로운 값이 네트워크 패킷에 담겨 관련 클라이언트로 전송됩니다. 클라이언트가 패킷을 수신하면 해당 액터의 프로퍼티 값을 서버로부터 받은 새로운 값으로 업데이트합니다.
DOREPLIFETIME(ClassName, PropertyName) 매크로는 해당 클래스 내에서 특정 프로퍼티가 네트워크를 통해 복제될 것임을 UE의 리플렉션 시스템에 등록합니다. 이 매크로는 보통 .cpp 파일의 GetLifetimeReplicatedProps 함수 내에서 사용됩니다. 실제로 이 매크로가 하는 일은 엔진이 프로퍼티의 메모리 오프셋을 알게하여 해당 프로퍼티의 변경을 추적하고 네트워크를 통해 전송할 수 있도록 하는 것입니다. UPROPERTY(Replicated) 매크로는 컴파일러에게 리플렉션 정보를 생성하라고 지시하고 DOREPLIFETIME은 그 정보를 엔진의 리플리케이션 시스템에 연결하는 역할을 합니다.

네트워크 신뢰성(Reliability): RPC 및 Property Replication에서 사용되는 Reliable 및 Unreliable 키워드가 의미하는 바는 무엇이며, 각각 어떤 종류의 데이터 전송에 적합한지 (예: 한 번이라도 놓치면 안 되는 중요 데이터 vs 빈번한 상태 업데이트) 예시와 함께 설명하시오.
->
RPC 및 Property Replication에서 사용되는 Reliable 및 Unreliable 키워드는 네트워크 패킷 전송의 신뢰성 수준을 정의합니다.
Reliable 키워드로 표시된 데이터는 네트워크 상에서 반드시 목표 클라이언트/서버에 도달함을 보장합니다. 순서 보장 및 누락된 패킷의 재전송 매커니즘이 포함됩니다. 한번이라도 놓치면 게임 플레이에 치명적인 영향을 미치는 중요 데이터에 적합합니다. 재전송 매커니즘으로 인해 네트워크 지연이 증가할 수 있고 대역폭을 더 많이 사용합니다.
Unreliable 키워드로 표시된 데이터는 최대한 빨리 전송되려 노력하지만 도달 여부나 순서가 보장되지 않습니다. 패킷이 손실되더라도 재전송을 시도하지 않으므로 네트워크 오버헤드가 적습니다. 빈번하게 업데이트되지만 일부 누락되거나 순서가 바뀌어도 괜찮은 경우, 최신 정보가 곧 전송되므로 이전 정보의 손실이 중요하지 않은 경우의 데이터에 적합합니다. 패킷 손실 가능성이 있습니다.

Replication Condition을 통한 최적화: DOREPLIFETIME_COND 또는 DOREPLIFETIME_ACTIVE_OVERRIDE와 같은 복제 조건(Replication Condition) 매크로를 사용하는 주된 이유는 무엇이며, 이를 통해 불필요한 네트워크 대역폭 사용을 어떻게 최적화할 수 있는지 구체적인 예시를 들어 설명하시오.
->
모든 복제된 프로퍼티가 항상 모든 클라이언트에 복제될 필요는 없습니다. Replication Condition을 사용하여 특정 조건이 충족될 때만 해당 프로퍼티를 복제하도록 제어함으로서 불필요한 네트워크 대역폭 사용을 줄이고 성능을 최적화할 수 있습니다. Replication Condition은 복제되는 데이터의 양과 빈도를 세밀하게 제어하여 대규모 멀티플레이어 게임에서 네트워크 트래픽을 최적화하고 서버의 부하를 줄이는 데 매우 중요한 역할을 합니다.

네트워크 관련성(Network Relevancy): 언리얼 엔진에서 액터의 "네트워크 관련성(Network Relevancy)"은 무엇을 의미하며, IsNetRelevantFor() 함수와 NetUpdateFrequency 속성이 액터 복제에 어떻게 영향을 미치는지 설명하시오.
->
네트워크 관련성은 UE에서 특정 AActor가 현재 클라이언트에게 복제될 필요가 있는지를 결정하는 기준입니다. 서버는 모든 액터를 모든 클라이언트에 복제하는 대신 각 클라이언트에게 관련성 있는 액터들만 선별하여 복제합니다. 이는 네트워크 대역폭을 크게 절약합니다.
IsNetRelevantFor() 함수는 서버에서 각 액터 인스턴스마다 각 클라이언트에 대해 호출되어 해당 액터가 특정 클라이언트에게 관련성이 있는지 또는 없는지를 판단합니다. 기본적으로 이 함수는 클라이언트의 시야 내에 액터가 있는지 액터가 클라이언트의 NetCullDistanceSquared 범위 내에 있는지 액터에 플레이어가 빙의되어 있는지 등 여러 요소를 고려하여 관련성을 판단합니다. 개발자는 이 함수를 오버라이드하여 자신만의 복제 관련성 로직을 구현할 수 있습니다.
NetUpdateFrequency는 AActor의 프로퍼티가 클라이언트에 복제되는 최대 빈도를 제어하는 변수입니다. 값이 높을수록 더 자주 복제되고 낮을수록 덜 자주 복제됩니다. 이를 적절히 조절함으로서 각 액터의 중요도에 따라 복제 빈도를 조절하여 전체 네트워크 대역폭 사용량을 최적화할 수 있습니다.

Replication Graph의 역할과 장점: 언리얼 엔진의 Replication Graph는 무엇이며, 어떤 상황에서 기존의 액터 복제 방식 대신 Replication Graph를 사용하면 대규모 멀티플레이어 환경에서 복제 성능 및 네트워크 대역폭 사용을 크게 최적화할 수 있는지 설명하시오.
->
Replication Graph는 UE의 기존 액터 복제 시스템을 대체하거나 보완하여 대규모 멀티플레이어 환경에서 복제 성능을 크게 최적화하기 위한 고급 네트워크 시스템입니다. 기존 시스템이 모든 액터를 개별적으로 순회하여 관련성을 검사하는 방식이었다면 Replication Graph는 공간 분할 및 그래프 기반 필터링을 통해 복제 대상을 효율적으로 결정합니다.
액터들을 지역적으로 그룹화하고 클라이언트의 시야나 중요도에 따라 복제 우선순위를 동적으로 조절합니다. 각 클라이언트에게 어떤 액터들이 복제되어야 하는지 그리고 어떤 프로퍼티들이 복제되어야 하는지를 효율적으로 결정합니다. 매 프레임 모든 액터의 관련성을 일일이 검사하는 대신 액터들을 노드로 관리하고 노드 간의 관계를 통해 복제 결정을 내립니다.
기존 방식은 액터 수가 많아질수록 IsNetRelevantFor() 호출 횟수가 기하급수적으로 늘어나 서버 CPU에 큰 부담을 줍니다. Replication Graph는 공간 쿼리나 중요도 기반 필터링을 사용하여 복제 검사에 필요한 CPU 시간을 크게 절약합니다. 액터의 중요도, 거리에 따른 복제 빈도 조절, 특정 그룹에 대한 최적화된 복제 등 더욱 정교한 복제 규칙을 적용하여 불필요한 데이터를 줄이고 네트워크 대역폭 사용을 최소화합니다. 수백, 수천 개의 액터가 동시에 존재하는 배틀 로얄, MMO 같은 대규모 게임에서 성능 저하 없이 많은 수의 플레이어와 액터를 지원할 수 있도록 설계되었습니다. 개발자가 필요에 따라 자신만의 노드를 추가하거나 복제 로직을 커스터마이징하여 특정 게임에 최적화된 복제 전략을 구현할 수 있습니다. 기존 복제 시스템으로 성능 병목 현상이 발생하는 대규모 멀티플레이어 게임에서 Replication Graph를 사용하면 서버 성능과 네트워크 효율성을 크게 향상시킬 수 있습니다.

RPC의 보안 및 서버 측 검증: 클라이언트에서 서버로 호출되는 Server RPC를 구현할 때, 치팅(Cheating)과 같은 보안 취약점을 방지하기 위해 서버 측에서 어떤 종류의 데이터 검증(Validation)을 반드시 수행해야 하는지 설명하시오.
->
클라이언트에서 서버로 호출되는 Server RPC는 클라이언트가 서버에 특정 행동을 요청하는 것이므로 치팅과 같은 보안 취약점에 매우 취약합니다. 악의적인 클라이언트가 조작된 RPC를 보내 게임 규칙을 위반할 수 있기 때문입니다. 이를 방지하기 위해 서버 측에서는 클라이언트로부터 받은 모든 Server RPC 호출에 대해 반드시 엄격한 데이터 검증(Validation)을 수행해야 합니다.
유효성 검사를 통해 클라이언트가 보낸 데이터가 올바른 범위 내에 있는지, 유효한 값인지 확인합니다. 권한 검사를 통해 클라이언트가 해당 행동을 수행할 권한이 있는지 확인합니다. 상태 검사를 통해 클라이언트가 요청한 행동이 현재 게임의 상태와 일치하는지 확인합니다. 속도/빈도 검사를 통해 클라이언트가 특정 RPC를 너무 빠르게 또는 비정상적인 빈도로 호출하지 않는지 확인합니다. 논리적 일관성 검사를 통해 클라이언트의 요청이 게임의 핵심 로직과 일치하는지 확인합니다. 서버는 항상 게임의 신뢰할 수 있는 단일 진실의 원천 역할을 해야 합니다. 클라이언트로부터 받은 모든 입력은 잠재적으로 조작될 수 있다는 가정하에 철저히 검증해야만 안전하고 공정한 멀티플레이어 게임을 만들 수 있습니다.

RPC 호출 시점 및 제약 사항: RPC를 액터의 생성자(Constructor)에서 직접 호출할 수 없는 이유와, RPC가 성공적으로 호출되고 실행되기 위한 액터의 네트워크 상태(예: 서버 권한 여부, 액터가 이미 복제되었는지)에 대한 제약 사항을 설명하시오.
->
액터의 생성자가 호출되는 시점은 아직 네트워크 시스템이 완전히 초기화되지 않았거나 액터가 네트워크에 등록되지 않은 상태입니다. RPC는 네트워크 스택을 통해 패킷을 전송하는 매커니즘인데 이 시스템이 준비되지 않은 상태에서는 호출될 수 없습니다. 또한 생성자는 서버와 클라이언트 모두에서 실행될 수 있지만 RPC는 특정 권한이 필요하며 아직 네트워크 상에서 액터의 권한이 확립되지 않은 시점입니다. 결론적으로 생성자는 네트워크 상호작용을 위한 올바른 컨텍스트가 아닙니다.
RPC를 호출하려는 액터는 bReplicates 속성이 true로 설정되어 있어야 합니다. Server RPC는 클라이언트에서 호출할 때 호출하는 액터가 해당 클라이언트의 소유여야 합니다. 액터가 서버에 스폰되어 클라이언트에 복제되었더라도 클라이언트가 소유하지 않은 액터의 Server RPC를 호출할 수 없습니다. Client/NetMulticast RPC는 서버에서 호출할 때 액터가 반드시 서버에 존재하고 서버가 해당 액터의 네트워크 권한을 가지고 있어야 합니다. RPC를 호출하려는 액터가 유효하게 존재하고 해당 액터가 포함된 월드가 네트워크 세션에 연결되어 활성화되어 있어야 합니다. 특히 클라이언트에서 서버로 Server RPC를 호출할 때 해당 액터가 이미 서버에 스폰되어 클라이언트에 복제되어 있어야 합니다. AActor::BeginPlay() 함수는 액터가 월드에 성공적으로 스폰되고 네트워크 시스템이 준비된 후 호출되므로 BeginPlay() 이후가 RPC 호출의 안전한 시점입니다.

복제된 변수 콜백(OnRep_Notify): UPROPERTY(ReplicatedUsing=FunctionName) 매크로로 선언된 프로퍼티의 OnRep_Notify 함수가 언제 호출되는지 설명하고, 클라이언트에서 복제된 변수의 값이 변경되었을 때 특정 로직(예: 비주얼 업데이트, 사운드 재생, 애니메이션 변경)을 즉시 실행하는 데 어떻게 활용되는지 설명하시오.
->
UPROPERTY(ReplicatedUsing=FunctionName) 매크로는 특정 프로퍼티가 서버에서 클라이언트로 복제될 때 클라이언트에서 해당 프로퍼티의 값이 변경되면 자동으로 지정된 FunctinoName(콜백 함수)를 호출하도록 합니다. OnRep_Notify 함수는 서버로부터 복제된 프로퍼티의 값이 변경되어 클라이언트의 로컬 변수에 적용되는 시점에 해당 클라이언트 측에서만 호출됩니다. 액터가 클라이언트에 처음으로 복제될 때도 이 콜백 함수가 호출됩니다. 이후 서버에서 해당 프로퍼티의 값이 변경되어 클라이언트로 새로운 값이 복제될 때마다 호출됩니다.
OnRep_Notify 함수는 클라이언트에서 서버의 권한을 가진 프로퍼티의 변경 사항에 즉각적으로 반응하여 시각적/청각적 피드백이나 로컬 로직을 실행하는 데 매우 유용합니다. 일반적으로 시각적 비주얼 업데이트, 사운드 재생, 애니메이션 변경 등의 로직을 실행하는 데 활용됩니다.
OnRep_Notify를 통해 클라이언트는 서버의 최신 데이터를 기반으로 즉각적인 피드백을 제공함으로서 네트워크 지연으로 인한 사용자 경험 저하를 최소화할 수 있습니다. 예를 들어 서버에서 총알이 발사되었다는 정보를 받고 즉시 발사 애니메이션을 재생하여 플레이어에게 즉각적인 반응을 제공합니다.