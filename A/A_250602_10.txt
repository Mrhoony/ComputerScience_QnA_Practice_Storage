객체 지향 프로그래밍(OOP)에서 "객체 관계(Object Relationship)"란 무엇이며, 왜 좋은 소프트웨어 설계를 위해 객체 관계를 이해하는 것이 중요한지 설명하시오.
->
객체 지향 프로그래밍에서 여러 객체들이 서로 어떤 방식으로 상호작용하고 연결되어 있는지를 나타내는 구조입니다.
좋은 소프트웨어는 모듈화되고 재사용성이 높으며 유지보수가 용이해야 합니다. 객체 관계를 명확히 이해하고 설계하면 객체 간의 책임 분배를 명확히 하고 불필요한 결합도를 낮춰 유연하고 확장 가능한 시스템을 구축할 수 있습니다.

연관(Association) 관계와 의존(Dependency) 관계의 차이점을 설명하고, 각각 게임 개발 컨텍스트에서 간단한 C++ 코드 예시를 들어 설명하시오.
->
연관(Association) 관계는 두 객체 사이에 비교적 영구적인 관계를 나타냅니다. 한 객체가 다른 객체의 참조(포인터, 참조 변수)를 멤버 변수로 가지고 지속적으로 상호작용할 때 발생합니다. knows-a 의미를 나타냅니다.
의존(Dependency) 관계는 한 객체가 다른 객체를 일시적으로 사용하거나 호출할 때 발생하는 관계입니다. 주로 함수 인자로 전달되거나 지역 변수로 생성되어 사용 후 사라지는 경우입니다. uses-a 의미를 나타냅니다.

집약(Aggregation) 관계와 합성(Composition) 관계의 핵심적인 차이점을 설명하시오. 특히, 객체의 생명 주기(Lifetime)와 소유권(Ownership) 관점에서 차이점을 명확히 하시오.
->
객체의 생명 주기와 소유권에서 차이가 발생합니다. 둘 다 has-a 관계를 나타냅니다.
합성(Composition) 관계는 전체 객체가 부분 객체의 생명 주기를 전적으로 책임집니다. 전체 객체가 파괴되면 부분 객체도 함께 파괴됩니다. 전체 객체가 부분 객체의 독점적인 소유권을 가집니다.
집약(Aggregation) 관계는 전체 객체가 부분 객체의 생명 주기를 직접 책임지지 않습니다. 전체 객체가 파괴되어도 부분 객체는 계속 존재할 수 있습니다. 부분 객체가 여러 전체 객체에 의해 공유되거나 독립적으로 존재할 수 있습니다.

C++에서 집약 관계와 합성 관계는 일반적으로 어떻게 구현되는지 (예: 원시 포인터/참조, 임베디드 객체, 스마트 포인터 사용) 각각의 구현 방식을 설명하시오.
->
임베디드 객체는 전체 클래스의 멤버 변수로 부분 객체를 직접 포함시킵니다. 전체 객체 생성/소멸 시 부분 객체도 함께 생성/소멸됩니다.
집약 구현은 전체 객체가 부분 객체의 주소를 멤버 변수로 가집니다. 부분 객체는 외부에서 생성되고 관리됩니다.

상속(Inheritance)은 객체 간의 "Is-A(이다)" 관계를 나타냅니다. 상속을 통한 객체 관계의 주요 이점(코드 재사용, 다형성)과 잠재적인 단점(강한 결합, 상속 계층의 복잡성)을 설명하시오.
->
상속(Inheritance) 관계는 is-a 관계를 나타내며 기본 클래스에 구현된 코드를 파생 클래스에서 그대로 사용할 수 있어 중복 코드를 줄이고 기본 클래스 포인터/참조를 통해 파생 클래스 객체를 조작할 수 있어 코드를 유연하고 확장 가능하게 만듭니다. 하지만 파생 클래스는 기본 클래스의 구현에 강하게 의존하므로 기본 클래스의 변경이 파생 클래스에 예기치 않은 영향을 미칠 수 있고 너무 깊거나 넓은 상속 계층은 이해하고 관리하기 어려워질 수 있으며 상속의 단점을 유발할 수 있습니다.

**위임(Delegation)**은 객체 관계의 한 형태로, 코드 재사용을 위해 상속 대신 사용될 수 있습니다. 위임이란 무엇이며, 어떤 상황에서 상속보다 위임이 더 나은 설계 대안이 될 수 있는지 설명하시오.
->
한 객체가 다른 객체에게 특정 작업을 대신 수행하도록 요청하는 객체 관계입니다. 위임자는 피위임자의 인스턴스를 멤버 변수로 포함하고 피위임자의 함수를 호출하여 자신의 인터페이스를 구현합니다. 상속처럼 is-a 관계가 아닌 has-a 관계가 구현되므로 위임자는 피위임자의 구현에 덜 의존합니다. 위임자는 피위임자의 인터페이스에만 의존합니다. 런타임에 어떤 객체에게 위임할지 변경할 수 있어 동적인 행동 변경이 가능합니다. C++의 다중 상속이 가지는 복잡성을 피하면서 여러 행동을 조합해야 할 때 유용합니다.

인터페이스(Interface) 구현은 객체 관계의 한 측면을 나타냅니다. C++의 순수 추상 클래스(Pure Abstract Class)나 언리얼 엔진의 UInterface를 구현하는 것이 "Has-A(가진다)" 또는 "Is-A" 관계 중 어느 쪽에 더 가깝다고 볼 수 있는지, 그리고 행동 공유 관점에서 인터페이스 사용의 이점을 설명하시오.
->
C++의 순수 추상 클래스나 언리얼 엔진의 UInterface 구현은 is-a 관계에 더 가깝습니다. 특정 클래스가 해당 인터페이스를 구현한다는 것은 이 인터페이스의 행동을 할 수 있다는 것을 의미하기 때문입니다.
클래스가 특정 기능을 제공해야 함을 명시적인 계약으로 정의합니다. 이를 통해 여러 독립적인 클래스들이 동일한 인터페이스를 통해 상호작용할 수 있게 됩니다. 실제 구현에 대한 지식 없이 인터페이스를 통해서만 객체를 다루므로 객체 간의 결합도가 낮아집니다. 구현 변경 시에도 인터페이스를 사용하는 코드는 영향을 받지 않습니다. 인터페이스 포인터/참조를 통해 다양한 구현을 가진 객체들을 일관된 방식으로 처리할 수 있습니다.

C++에서 객체 관계(합성, 집약, 연관)가 메모리 관리 및 객체 생명 주기에 어떻게 영향을 미치는지 설명하시오. 특히 스마트 포인터(예: std::unique_ptr, std::shared_ptr)가 이러한 관계에서 어떤 역할을 하는지 포함하여 설명하시오.
->
합성 관계에서 전체 객체가 부분 객체의 생명주기를 책임집니다. 부분 객체는 전체 객체와 함께 생성되고 소멸됩니다. 집약 관계에서 전체 객체는 부분 객체의 메모리 관리에 관여하지 않습니다. 연관 관계도 메모리 관리 책임이 없습니다.
unique_ptr은 합성 관계로 단독 소유권을 명확히 표현하며 전체 객체가 소멸될 때 부분 객체의 메모리를 자동으로 해제하여 메모리 누수를 방지합니다.
shared_ptr은 집약/공유 소유 연관 관계로 공유 소유권을 표현하며 여러 전체 객체가 동일한 부분 객체를 참조할 때 사용합니다. 참조 카운트가 0이 되면 부분 객체를 해제하여 복잡한 공유 객체의 메모리 관리를 자동화합니다.
weak_ptr은 연관/순환 참조 방지 관계로 shared_ptr의 약한 참조이며 참조 카운트에 영향을 주지 않습니다. 순환 참조로 인한 메모리 누수를 방지하거나 객체의 존재 여부를 확인하고 싶을 때 사용됩니다.

언리얼 엔진의 액터(Actor)와 컴포넌트(Component) 모델은 객체 관계의 좋은 예시입니다. 액터가 컴포넌트를 소유하는 관계는 합성(Composition)에 가깝다고 볼 수 있습니다. 이 관계에서 언리얼 엔진의 가비지 컬렉션(Garbage Collection) 시스템이 컴포넌트의 생명 주기를 어떻게 관리하는지 설명하시오.
->
AActor는 UActorComponent를 합성 관계로 소유합니다. 컴포넌트는 액터 없이는 독립적으로 존재할 수 없습니다.
액터와 컴포넌트 모두 UObject 시스템에 의해 관리되며 GC 대상입니다.
액터가 컴포넌트를 UPROPERTY()로 멤버 변수로 가지고 있으면 액터가 컴포넌트에 대한 강력한 참조를 가지게 됩니다.
액터가 더 이상 참조되지 않아 GC 대상이 되면 액터 내의 모든 컴포넌트 UPROPERTY 참조도 함께 사라지므로 컴포넌트들도 더 이상 참조되지 않게 되어 GC 대상이 됩니다.
결과적으로 액터가 파괴되면 GC 시스템이 자동으로 해당 액터에 속한 컴포넌트들의 메모리를 회수합니다. 이는 컴포넌트의 생명 주기가 액터에 종속됨을 의미하며 unique_ptr과 유사한 소유권 패턴입니다.

게임 프로젝트에서 객체 관계를 설계할 때 **느슨한 결합(Loose Coupling)**을 달성하는 것이 왜 중요한지 설명하시오. 또한, 이를 위해 적용할 수 있는 설계 원칙이나 디자인 패턴(예: 의존성 주입, 옵저버 패턴)에는 어떤 것들이 있는지 간략히 제시하시오.
->
느슨한 결합은 객체들이 서로의 구현 세부 사항에 대한 의존성을 최소화하는 것을 의미합니다. 이는 모듈성 및 재사용성 향상, 유지보수 용이, 확장성 등의 이점을 제공합니다.
느슨한 결합을 적용하려면 인터페이스 분리 원칙(ISP), 의존성 역전 원칙(DIP), 의존성 주입(DI), 옵저버 패턴, 전략 패턴 등의 설계 원칙과 디자인 패턴을 선택할 수 있습니다.
옵저버 패턴은 한 객체의 상태 변화를 여러 다른 객체에 통지하여 상태를 발행하는 객체와 이를 구독하는 객체 간의 직접적인 결합을 제거합니다. GameState와 위젯을 옵저버 패턴으로 제작할 수 있습니다.