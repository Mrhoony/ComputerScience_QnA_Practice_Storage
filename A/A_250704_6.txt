캐시란?
->
고속의 임시 저장 공간, RAM보다 빠르고 CPU와 더 가까운 곳에 저장하여 CPU가 데이터를 요청할 때 메인 메모리까지 가지 않고 캐시에서 바로 가져올 수 있도록 함으로서 처리 속도를 높이는 역할

원리.
데이터 요청
캐시 확인
캐시 히트 -> 데이터 처리
캐시 미스 -> 캐시 업데이트

메모리 계층구조.
레지스터: CPU 내부에 있는 가장 빠른 저장 공간, 캐시의 일부는 아니지만 CPU가 직접 접근하는 데이터 최상위 계층
캐시
용량: L1 캐시 < L2 캐시 < L3 캐시
속도: L1 캐시 > L2 캐시 > L3 캐시
메인 메모리(RAM)
보조 기억 장치, 스왑 공간(SSD/HDD)

지역성 원리.
캐시가 효과적으로 작동하는 핵심 이유로 프로그램의 데이터 접근 패턴은 무작위적이지 않고 특정 경향을 보인다는 원리
시간 지역성: 최근에 참조된 데이터는 가까운 미래에 다시 참조될 가능성이 높음
공간 지역성: 최근에 참조된 데이터의 주변 메모리 공간에 있는 데이터들이 가까운 미래에 참조될 가능성이 높음

캐시 종류 및 관리.
캐시 라인: 캐시와 메인 메모리 간에 데이터를 주고받는 최소 단위
캐시 매핑.
메인 메모리의 특정 주소가 캐시의 어느 위치에 저장될지 결정하는 방식
직접 매핑: 메모리 블록이 캐시의 특정 고정된 위치에만 매핑
완전연관 매핑: 메모리 블록이 캐시의 어떤 위치든 매핑
세트연관 매핑: 캐시를 여러개의 세트로 나누고 각 세트 내에서 완전연관 매핑 방식 사용

캐시 교체 정책.
캐시가 가득 찼을 때 새로운 데이터를 저장하기 위해 기존 데이터 제거를 결정하는 정책
LRU: 가장 오랫동안 미사용 데이터 제거
FIFO: 가장 먼저 들어온 데이터 제거
LFU: 가장 적게 사용된 데이터 제거
Random: 무작위 데이터 제거

쓰기 정책.
캐시의 데이터가 변경되었을 때 메인 메모리에 어떻게 반영할지 결정하는 정책
Write-Through: 캐시와 메인 메모리 동시에 데이터 쓰기
Write-Back: 캐시에만 먼저 쓰고 나중에 메인 메모리에 쓰기

캐시 일관성.
멀티코어 프로세서 환경에서는 여러 코어가 각자의 캐시를 가지고 있기 때문에 동일한 데이터가 여러 캐시에 존재할 수 있음, 이때 한 코어가 캐시의 데이터를 변경하면 다른 코어의 캐시에 있는 동일한 데이터는 오래된 데이터가 될 수 있음, 이를 캐시 일관성 문제라고 함



스레드가 개별 스택/레지스터를 가지는 이유는?
->
스레드의 독립적인 실행 흐름과 컨텍스트 스위칭의 효율성을 보장하기 위함



페이징이란?
->
프로세스의 가상 주소 공간을 고정된 크기의 블록인 페이지로 나누고 물리적 메모리를 동일한 크기의 페이지 프레임으로 나누어 이들을 비연속적으로 매핑하여 메모리를 효율적으로 관리하는 방식, 각 프로세스당 하나의 고유한 페이지 테이블을 가짐, 페이지 테이블 자체는 물리적 메모리에 저장



단편화란?
->
메모리나 디스크 저장 공간과 같은 자원들이 여러개의 작은 사용 불가능하거나 비효율적인 조각들로 나뉘어 있는 현상

내부 단편화.
할당된 메모리 블록 내부에 실제로 사용되지 않지만 다른 용도로 할당될 수 없는 공간이 생기는 현상
고정된 크기의 구획으로 나누어 할당할 때 프로세스 크기가 구획보다 작으면 남는 공간 발생(페이징, 파일 저장 등)

외부 단편화.
메모리나 디스크 공간이 할당 및 해제를 반복하면서 작은 조각들로 흩어져 전체 합은 충분하지만 연속적인 공간이 부족하여 새로운 프로세스나 파일을 할당할 수 없는 현상, 사용가능한 공간이지만 연속적이지 않음

해결방법.
압축: 흩어진 빈 공간들을 한곳으로 모아서 큰 연속적인 빈 공간을 만듬
재배치: 프로세스가 메모리에서 이동
페이징: 외부 단편화를 근본적으로 해결하기 위해 개발된 기법(페이지 단위로 비연속적으로 할당하기 때문)



해시 테이블의 개방 주소법이란?
->
해시 테이블: 키-값 쌍을 저장하는 자료구조로 키를 해시 함수에 넣어 얻은 해시 값을 사용하여 데이터를 저장할 버킷의 인덱스를 결정
해시 충돌: 서로 다른 키가 동일한 해시 값을 생성하는 경우

체이닝: 각 버킷을 연결 리스트로 만들어 충돌이 발생하면 해당 버킷의 연결 리스트에 데이터를 추가
개방 주소법: 해시 테이블 내의 다른 빈 버킷을 찾아 데이터를 저장

선형 탐사: 인덱스 오프셋 상수값만큼 건너뛰며 빈 버킷 탐색 및 저장
이차 탐사: 인덱스 오프셋의 제곱값만큼 건너뛰며 빈 버킷 탐색 및 저장
이중 해싱: 두번째 해시 함수를 사용하여 빈 버킷 탐색 및 저장

로드 팩터: 해시 테이블에 저장된 데이터의 수 / 총 버킷 수
로드 팩터가 특정 임계값을 넘어서면 테이블 리사이징이 필요

검색.
A를 저장한 후 B를 저장하려할 때 충돌이 발생해서 이중 해싱으로 B를 저장한 상황
B를 한번 해싱하여 A가 저장된 버킷을 탐색 -> 키 비교 -> B가 해당 버킷에 저장되지 않았음을 확인 -> B 이중 해싱 -> 이중 해싱된 인덱스의 버킷에서 확인 -> 데이터가 있다면 검색 종료, 없다면 해당 데이터는 해시 테이블에 저장되지 않은 것임



은행원 알고리즘이란?
->
운영체제에서 교착 상태(Deadlock)을 회피하기 위한 대표적인 자원 할당 알고리즘
자원을 할당하기 전에 미래를 예측하여 시스템의 안전을 보장하려고 함
대표적인 데드락 회피 기법