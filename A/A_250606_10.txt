C++17에 도입된 [[nodiscard]] 속성(attribute)은 무엇이며, 함수 반환 값을 무시하는 것을 방지하여 코드의 안정성과 가독성을 어떻게 향상시키는지 설명하시오.
->
C++17에 도입된 속성으로 함수 반환값을 호출자가 반드시 사용해야 함을 나타냅니다. 이 속성이 지정된 함수의 반환값을 무시할 경우 컴파일러가 경고를 발생시킵니다.
개발자가 반환값을 의도치 않게 무시하여 발생할 수 있는 논리적 오류나 잠재적 버그를 방지합니다. 함수의 반환값이 중요하며 반드시 처리되어야 한다는 설계 의도를 명확하게 전달하여 코드의 가독성을 높입니다.

람다(Lambda) 표현식에서 변수를 값으로 캡처([var])하는 것과 참조로 캡처([&var])하는 것의 차이점을 설명하고, 각각 어떤 상황에 적합하며 주의할 점은 무엇인지 설명하시오.
->
[var]는 값캡처로 람다를 정의하는 시점의 var 변수값의 복사본을 람다 내부에 저장합니다. 람다 외부의 원본 var 변수가 나중에 변경되더라도 람다 내부의 var 값은 변하지 않습니다. 람다가 람다 외부의 변수에 대한 읽기 전용 스냅샷을 필요로 할 때 또는 람다가 정의된 스코프를 벗어나서 실행될 때 원본 변수의 생명주기가 끝나더라도 안전하게 사용되어야 할 때 적합합니다. 큰 객체를 값으로 캡처하면 불필요한 복사 비용이 발생할 수 있습니다.
[&var]는 참조캡처로 람다를 정의하는 시점의 var 변수를 람다 내부에 저장합니다. 람다 내부에서 var에 접근하면 람다 외부의 원본 var 변수에 직접 접근하게 되므로 원본 var의 변경은 람다 내부에서도 반영됩니다. 람다 외부의 변수를 직접 수정해야 할 때 또는 큰 객체를 복사 없이 사용해야 할 때 적합합니다. 람다가 정의된 스코프를 벗어나서 실행될 경우 원본 변수의 생명주기가 끝날 수 있으므로 (댕글링 참조) 위험합니다. 특히 비동기 코드에서 람다를 사용할 때 이 점을 반드시 고려해야 합니다.

noexcept 예외 지정자(exception specifier)는 무엇이며, 함수에 noexcept를 선언했을 때 컴파일러가 어떤 최적화를 수행할 수 있으며, 만약 noexcept 함수 내에서 예외가 발생하면 어떤 일이 벌어지는지 설명하시오.
->
C++11부터 도입된 키워드로 함수 선언 뒤에 붙여 해당 함수가 예외를 발생시키지 않을 것임을 컴파일러에게 약속합니다. noexcept 함수는 예외가 발생할 가능성이 없으므로 컴파일러는 예외 처리 매커니즘과 관련된 오버헤드를 제거하여 더 공격적인 최적화를 수행할 수 있습니다. 이는 코드 크기 감소와 실행 속도 향상에 기여합니다.
런타임에 noexcept로 선언된 함수 내에서 예외가 발생하면 C++ 런타임은 즉시 std::terminate()를 호출하여 프로그램을 강제 종료시킵니다. 이는 개발자가 이 함수는 예외를 던지지 않는다고 명시적으로 약속했음에도 불구하고 예외가 발생했기 때문에 프로그램이 더 이상 유효한 상태를 유지할 수 없다고 간주하기 때문입니다.



게임 루프(Game Loop)에서 고정 타임스텝(Fixed Timestep)과 가변 타임스텝(Variable Timestep)의 차이점을 설명하고, 각각 물리 시뮬레이션이나 네트워크 동기화에 어떤 영향을 미치는지 비교하시오.
->
고정 타임스텝은 게임 루프에서 업데이트 로직이 항상 동일한 고정된 시간 간격으로 실행됩니다. 만약 실제 프레임 시간이 길어지면 여러 업데이트를 한번에 실행하여 따라잡습니다. 안정적이고 예측 가능한 물리 시뮬레이션을 제공합니다. 동일한 입력에 대해 항상 동일한 물리 결과를 보장하여 네트워크 동기화에 유리합니다. 서버와 클라이언트 간의 물리 시뮬레이션을 동기화하기에 이상적입니다. 모두 동일한 고정 타임스텝으로 시뮬레이션하므로 상태 불일치가 줄어듭니다.
가변 타임스텝은 게임 루프에서 업데이트 로직이 이전 프레임과 현제 프레임 사이의 실제 경과 시간에 따라 실행됩니다. 물리 계산 결과가 프레임 레이트에 따라 달라질 수 있어 불안정하고 예측 불가능한 물리 동작을 유발할 수 있습니다. 클라이언트마다 프레임 레이트가 다를 수 있으므로 물리 시뮬레이션을 가변 타임스텝으로 돌리면 서버와 클라이언트 간의 상태 불일치가 심해져 동기화가 어려워집니다.
대부분의 게임은 렌더링은 가변 타임스텝으로 물리 및 중요한 게임 로직은 고정 타임스텝으로 실행하는 하이브리드 방식을 사용합니다.

3D 그래픽스에서 "라이트 프로브(Light Probe)"는 무엇이며, 정적(Static) 또는 동적(Dynamic) 오브젝트에 간접 조명(Indirect Lighting)을 실시간에 가깝게 표현하는 데 어떻게 사용되는지 설명하시오.
->
3D 공간의 특정 지점에서 배치되는 가상의 센서로 해당 지점의 모든 방향에서 들어오는 빛의 정보를 미리 캡처(베이킹)하여 저장하는 시스템입니다. 일반적으로 구면 조화 함수 또는 큐브맵 형태로 빛 정보를 저장합니다.
정적 오브젝트는 주로 라이트맵으로 간접 조명을 표현하지만 라이트 프로브는 이와는 다른 방식으로 장면에 더 미묘한 간접 조명 효과를 추가합니다. 특히 라이트 프로브 간의 보간을 통해 넓은 영역에 걸쳐 자연스러운 간접 조명 변화를 표현합니다.
동적 오브젝트는 움직이기에 라이트맵을 적용할 수 없습니다. 라이트 프로브는 주변 라이트 프로브들의 빛 정보를 보간하여 동적인 오브젝트가 실시간에 가깝게 주변 간접 조명을 받아 사실적으로 보이게 합니다. 오브젝트가 라이트 프로브 그리드 내를 이동하면 주변의 빛 정보가 계속 업데이트되어 그림자와 색상이 환경에 맞게 변화합니다.

블룸 필터(Bloom Filter)는 무엇이며, 어떤 용도(예: 데이터 집합 내 요소 존재 여부 빠르게 검사)로 사용되며, 거짓 양성(False Positive) 가능성이라는 특징에 대해 설명하시오.
->
대규모 데이터 집합 내에 특정 요소가 존재하는지 여부를 빠르게 하지만 확률적으로 검사하기 위해 사용되는 공간 효율적인 확률적 자료구조입니다.
데이터 집합 내 요소 존재 여부를 검사하거나 네트워크 패킷에서 이미 처리된 패킷인지 확인하여 중복 처리를 방지할 때 또는 웹 브라우저에서 방문했던 URL인지를 빠르게 확인하여 캐시 히트율을 높일 때 빠른 처리를 제공합니다.
블룸 필터의 가장 큰 특징이자 단점은 거짓 양성 가능성이 있다는 것입니다. 블룸 필터가 요소가 존재한다고 판단했고 실제로 요소가 존재하는 경우 참 양성입니다. 블룸 필터가 요소가 존재하지 않는다고 판단했고 실제로 요소가 존재하지 않는 경우 참 음성입니다. 블룸 필터가 요소가 존재한다고 판단했지만 실제로는 요소가 존재하지 않는 경우 거짓 양성이고 블룸 필터가 요소가 존재하지 않는다고 판단했지만 실제로는 요소가 존재하는 경우는 절대 발생하지 않습니다. 거짓 양성 가능성을 감수하는 대신 매우 적은 메모리를 사용하고 빠른 조회 속도를 제공합니다.



언리얼 엔진 UMG(Unreal Motion Graphics)에서 UPROPERTY(meta=(AllowPreserveRatio))와 같은 메타 데이터 키워드는 무엇이며, UI 요소(예: 이미지)의 비율을 유지하며 크기를 조절하는 데 어떻게 사용되는지 설명하시오.
->
UPROPERTY 매크로 내에서 사용되는 meta 키워드는 에디터의 프로퍼티 패널이나 블루프린트에서 해당 프로퍼티의 동작이나 표시 방식을 제어하는 추가적인 정보를 제공합니다. 이는 컴파일러에는 영향을 미치지 않지만 에디터에서 해당 프로퍼티의 동작을 변경합니다. AllowPreserveRatio는 주로 UImage와 같은 UI 위젯의 Brush 프로퍼티에 사용됩니다. 이 키워드가 설정되면 에디터 내에서 해당 이미지의 크기를 조절할 때 가로/세로 비율을 유지할 수 있는 옵션을 활성화시킵니다.

언리얼 엔진 애니메이션 시스템에서 애니메이션 커브(Animation Curve)는 무엇이며, 애니메이션 중 머티리얼 파라미터나 다른 게임플레이 로직을 동적으로 제어하는 데 어떻게 사용될 수 있는지 설명하시오.
->
애니메이션 시퀀스 에셋 내에 포함될 수 있는 시간에 따른 float 또는 bool 값의 변화 곡선입니다. 애니메이션 재생 시간에 맞춰 미리 정의된 값들을 출력합니다. 머터리얼 파라미터/게임플레이 로직 동적 제어에 활용됩니다.

언리얼 엔진 네트워크에서 MinNetUpdateFrequency 속성은 액터의 복제 성능에 어떤 영향을 미치며, 언제 이 값을 조정하여 네트워크 대역폭 사용량을 최적화하고 불필요한 복제를 줄일 수 있는지 설명하시오.
->
AActor 클래스에 있는 복제 관련 프로퍼티로 해당 액터의 최소 네트워크 업데이트 빈도를 제어합니다. 자주 복제되지 않는 액터의 최소 복제 빈도를 설정하여 네트워크 대역폭을 최적화하고 불필요한 복제를 줄일 수 있습니다.

언리얼 엔진에서 TArray의 Add(), Insert(), RemoveAt() 메서드들이 각각 어떤 성능적 특성(시간 복잡도)을 가지는지 설명하고, 특히 Insert()와 RemoveAt()가 배열의 중간에서 빈번하게 호출될 때 성능 저하를 피하기 위한 전략을 제시하시오.
->
Add()는 배열의 끝에 요소를 추가합니다. O(1)의 시간 복잡도를 가지나 재할당이 필요한 경우 O(N)의 시간 복잡도를 가집니다. Insert()는 배열의 중간에 요소를 삽입합니다. 삽입될 위치 이후의 모든 요소들을 뒤로 한칸씩 이동시켜야 하므로 최악의 경우 O(N)의 시간 복잡도를 가집니다. RemoveAt()은 배열의 중간에 있는 요소를 삭제합니다. 삭제 이후의 모든 요소들을 앞으로 이동시켜야 하므로 최악의 경우 O(N)의 시간 복잡도를 가집니다.
배열의 중간에 삽입/삭제가 빈번하다면 TArray 대신 TSet이나 TMap과 같이 삽입/삭제에 더 효율적인 자료구조를 고려합니다. 순서가 중요하지 않다면 RemoveSwap()을 사용하고 지연된 삭제/배치 처리, 용량 예약, 정렬 후 중복 제거 등 다양한 방법을 적용하여 성능 저하를 회피합니다.