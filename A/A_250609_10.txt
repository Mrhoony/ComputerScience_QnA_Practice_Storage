C++20에 도입된 std::latch 또는 std::barrier는 무엇이며, 다중 스레드 환경에서 스레드들이 특정 지점에서 동기화(예: 모든 스레드가 작업을 완료할 때까지 대기)하는 데 어떻게 사용되는지 설명하시오.
->
std::latch는 한번만 사용 가능한 동기화 프리미티브로 특정 수의 스레드가 모두 특정 지점에 도달할 때까지 나머지 스레드들을 대기시키는 데 사용됩니다. 카운터가 0이 되면 모든 대기 스레드가 동시에 해제됩니다.
std::latch latch(count);로 초기화하고 각 스레드는 작업 완료 후 latch.count_down();을 호출하며 대기해야 하는 스레드는 latch.wait();을 호출합니다.
여러 스레드가 공동 작업을 시작하기 전에 모든 초기화 작업이 완료되기를 기다리거나 병렬 계산 후 모든 스레드의 결과가 모일 때까지 기다리는 등 모든 스레드가 여기까지 왔다를 한번만 보장하는데 사용됩니다.
std::barrier는 여러번 재사용 가능한 동기화 프리미티브로 std::latch와 유사하게 모든 스레드가 특정 지점에 도달하기를 기다리지만 대기 후 배리어를 재설정하여 다음 라운드에서 다시 사용할 수 있습니다. 각 라운드마다 완료 시 호출될 콜백 함수를 지정할 수 있습니다.
std::barrier barrier(count, on_completion_function);로 초기화하고 각 스레드는 barrier.arrive_and_wait();을 호출합니다.
병렬 알고리즘에서 여러 단계의 반복적인 동기화 지점이 필요할 때 적합합니다.

std::shared_from_this() 함수는 무엇이며, std::shared_ptr로 관리되는 객체 내부에서 자신의 std::shared_ptr를 안전하게 얻어야 할 때 왜 사용되는지 설명하시오.
->
std::shared_from_this() 함수는 std::enable_shared_from_this 클래스를 상속받은 클래스 내에서 사용할 수 있는 멤버 함수입니다. 이 함수는 현재 객체를 소유하는 기존 std::shared_ptr의 복사본을 반환합니다.
객체가 std::shared_ptr로 관리되고 있을 때 객체 내부의 메서드에서 this 포인터를 std::shared_ptr로 변환하여 외부로 전달하거나 다른 std::shared_ptr에 할당해야 하는 상황이 발생할 수 있습니다. 만약 단순하게 std::shared_ptr<DerivedClass>(this)와 같이 this 포인터로 새 std::shared_ptr을 생성하면 새로운 독립적인 제어 블록이 생성되어 참조 카운트가 이중으로 관리됩니다. 이는 객체가 두번 해제되거나 참조 카운트가 꼬여서 메모리 이중 해제 또는 조기 해제를 유발할 수 있습니다. std::shared_from_this()는 이미 존재하는 std::shared_ptr의 제어 블록을 사용하여 안전하게 새로운 std::shared_ptr을 생성하므로 참조 카운트가 올바르게 공유되고 관리되어 이러한 문제를 방지합니다.

C++17의 폴드 표현식(Fold Expressions)은 무엇이며, 가변 템플릿(Variadic Templates)에서 매개변수 팩(parameter pack)에 대한 연산(예: 모든 요소 합계)을 압축적으로 정의하는 데 어떻게 사용될 수 있는지 간단한 예시와 함께 설명하시오.
->
가변 템플릿의 매개변수 팩에 대해 이항 연산자를 적용하여 압축적으로 연산을 수행하는 구문입니다.
template<typename... Args>
auto sum(Args... args)
{
    return (args + ...);  // 단항 왼쪽 폴드
}
재귀적인 템플릿 함수를 사용하여 매개변수 팩을 처리하던 기존 방식보다 훨씬 간결하고 직관적인 코드로 작성할 수 있게 합니다. 이는 가변 템플릿의 사용성을 향상시킵니다.



3D 그래픽스에서 블룸(Bloom) 효과는 무엇이며, 어떻게 구현(예: 밝은 영역 추출, 블러링, 원본 이미지와 합성)되어 화면에 빛이 번지는 듯한 시각적 효과를 만들어내는지 설명하시오.
->
블룸 효과는 3D 그래픽스에서 매우 밝은 영역의 빛이 주변으로 번져 나가는 듯한 효과를 시뮬레이션하여 이미지의 사실감과 몰입도를 높이는 후처리 효과입니다.
렌더링된 원본 이미지에서 특정 임계값 이상의 밝기를 가진 픽셀들만 추출(1. 밝은 영역 추출)합니다. 이 픽셀들이 블룸 효과의 원천이 됩니다. 추출된 밝은 영역 이미지에 가우시안 블러와 같은 블러 필터를 적용(2. 블러링)하여 빛이 부드럽게 번져 나가는 효과를 만듭니다. 블러의 강도와 반복 횟수가 블룸의 확산 정도를 결정합니다. 블러링된 이미지를 원본 렌더링된 이미지에 추가(3. 원본 이미지와 합성)합니다. 이 과정에서 블룸의 강도와 색상을 조절할 수 있습니다.
광원, 반사 표면, 발광 오브젝트 등이 더욱 빛나고 생생하게 보이게 합니다. 장면의 밝은 부분과 어두운 부분 사이의 대비를 강조하여 시각적인 깊이감을 더합니다. 화면에 몽환적이거나 부드러운 분위기를 연출하는데 사용됩니다.

다중 스레딩 환경에서 뮤텍스(Mutex)와 스핀락(Spinlock)의 차이점을 설명하고, 각각 락(Lock)을 점유하는 예상 시간(짧은 시간 vs 긴 시간)에 따라 어떤 상황에 더 적합한지 비교하시오.
->
뮤텍스는 락을 획득하지 못하면 스레드를 운영체제 레벨에서 대기 상태로 전환시킵니다. 대기 상태의 스레드는 CPU를 점유하지 않고 락이 해제될 때까지 스케줄링에서 제외됩니다.
락 획득/해제 시 커널 모드 전환, 스레드 컨텍스트 스위칭 등 비교적 큰 오버헤드가 발생할 수 있습니다.
락을 긴 시간 동안 점유할 것으로 예상될 때, 스레드가 락을 기다리는 동안 CPU를 낭비하지 않고 다른 유용한 작업을 수행할 수 있도록 합니다.
스핀락은 락을 획득하지 못하면 스레드를 바쁜 대기 상태로 만듭니다. 락이 풀릴 때까지 계속해서 락 상태를 반복적으로 확인하여 CPU를 점유합니다.
락 획득/해제 시 커널 모드 전환이나 컨텍스트 스위칭 오버헤드가 없습니다.
락을 매우 짧은 시간 동안만 점유할 것으로 예상될 때, 락을 기다리는 시간이 컨텍스트 스위칭 오버헤드보다 짧을때 효율적입니다. 스핀락은 락을 기다리는 동안 CPU를 낭비하므로 오랜 시간 락을 점유하면 다른 스레드의 실행을 방지하여 시스템 전체 성능을 저하시킬 수 있습니다.

CPU 캐시 메모리에서 "캐시 라인 정렬(Cache Line Alignment)"과 "거짓 공유(False Sharing)" 문제는 무엇이며, 다중 스레드 프로그래밍에서 성능에 어떤 부정적인 영향을 미칠 수 있는지 설명하고, 이를 완화하기 위한 방법을 제시하시오.
->
캐시 라인은 CPU 캐시가 데이터를 관리하는 최소 단위입니다. 메모리에서 데이터를 캐시로 가져올 때 특정 크기의 블록 단위로 가져옵니다.
캐시 라인 정렬은 데이터 구조체나 변수를 캐시 라인 크기의 배수에 해당하는 메모리 주소에 배치하는 것을 의미합니다. 데이터가 캐시 라인 경계를 넘어 여러 캐시 라인에 걸쳐 저장되는 것을 방지하여 하나의 데이터 접근으로 여러 캐시 라인을 가져와야 하는 캐시 미스를 줄이고 캐시 효율성을 높입니다.
거짓 공유는 다중 스레드 환경에서 서로 다른 스레드가 각각 독립적으로 사용하지만 우연히 동일한 캐시 라인에 속해 있는 변수들을 수정할 때 발생하는 성능 문제입니다. 한 스레드가 캐시 라인의 변수를 수정하면 CPU의 캐시 일관성 프로토콜에 따라 해당 캐시 라인 전체가 무효화되거나 다시 쓰여져야 합니다. 이로 인해 다른 코어에 캐시에 있는 동일한 캐시 라인이 무효화되고 다른 스레드가 해당 캐시 라인의 변수에 접근할 때 불필요한 캐시 미스가 발생하여 주 메모리에서 데이터를 다시 가져와야 합니다. 각 스레드는 자신이 사용하는 변수만 수정했는데도 다른 스레드의 수정으로 인해 자신의 캐시가 계속 무효화되어 성능이 크게 저하됩니다.
독립적으로 사용되는 변수들 사이에 캐시 라인 크기만큼 빈 공간(패딩)을 추가하여 서로 다른 캐시 라인에 위치하도록 합니다. 자주 함께 사용되는 데이터는 묶고 독립적으로 사용되는 데이터는 분리하여 캐시 지역성을 높입니다. 작은 변수 대신 더 큰 구조체를 사용하여 캐시 라인 하나에 최대한 많은 관련 데이터를 넣고 캐시 라인 경계를 넘지 않도록 합니다.



언리얼 엔진의 Behavior Tree에서 "Sequence(시퀀스)"와 "Selector(셀렉터)" 컴포지트 노드(Composite Node)는 각각 어떤 역할을 하며, AI 행동 흐름의 성공/실패 조건과 제어 흐름에 어떻게 영향을 미치는지 설명하시오.
->
컴포짓 노드는 비헤이비어 트리의 제어 흐름을 결정하는 노드로 여러 자식 노드를 가질 수 있습니다. 컴포짓 노드는 자식 노드들을 왼쪽에서 오른쪽으로 순서대로 실행합니다.
시퀀스는 모든 자식 노드가 성공을 반환하면 자신도 성공을 반환하고 자식 노드 중 하나라도 실패를 반환하면 시퀀스 내 다른 노드의 실행을 중지하며 자신은 실패를 반환합니다. 모든 단계가 성공해야만 최종적으로 성공하는 선형적인 작업 흐름에 사용됩니다.
셀렉터는 자식 노드 중 하나라도 성공을 반환하면 시퀀스 내 다른 노드의 실행을 중지하고 자신도 성공을 반환합니다. 모든 자식 노드가 실패하면 자신도 실패를 반환합니다. 여러 대안 중 하나라도 성공하면 최종적으로 성공하는 선택적인 작업 흐름에 사용됩니다.

언리얼 엔진에서 TWeakObjectPtr는 AActor 컴포넌트(예: USkeletalMeshComponent)를 참조할 때 어떤 상황에서 유용하게 사용될 수 있으며, 가비지 컬렉션(Garbage Collection)으로부터 안전하게 참조를 유지하는 데 어떻게 기여하는지 설명하시오.
->
TWeakObjectPtr은 UE의 약한 참조 스마트 포인터입니다. UObject 기반의 모든 클래스를 가리킬 수 있습니다. A가 B를 강한 참조하고 B가 A를 강한 참조하여 두 객체가 해제되지 못하는 순환참조를 방지합니다. TWeakObjectPtr를 사용하는 코드는 유효하지 않은(댕글링) 포인터에 접근하는 위험을 방지하고 GC가 안전하게 객체를 해제할 수 있도록 합니다.

언리얼 엔진에서 NetProfiler와 같은 네트워크 디버거(Network Debugger)는 무엇이며, 멀티플레이어 게임의 네트워크 대역폭 사용량, 패킷 손실, RPC 호출 빈도 등을 분석하여 네트워크 성능 문제를 진단하는 데 어떻게 활용되는지 설명하시오.
->
UE에서 멀티플레이어 게임의 네트워크 성능을 분석하고 디버깅하기 위한 도구입니다. 게임 실행 중에 실시간으로 네트워크 트래픽과 관련된 다양한 통계 데이터를 수집하고 시각화하여 보여줍니다.
네트워크 대역폭 사용량 분석, 패킷 손실 및 지연 진단, RPC 호출 빈도 및 효율성 검사, 복제되는 액터/프로퍼티 상세 분석, 디버깅 과정에서 활용됩니다.

언리얼 엔진 머티리얼 시스템에서 "머티리얼 함수(Material Function)"는 무엇이며, 복잡한 머티리얼 노드 그래프를 모듈화하고 재사용하여 작업 효율성을 높이고 일관된 머티리얼 표현을 유지하는 데 어떻게 기여하는지 설명하시오.
->
재사용 가능한 머터리얼 노드 그래픽의 일부분입니다. 마치 프로그래밍 언어의 함수처럼 입력과 출력을 정의하여 복잡한 노드들을 하나의 응집된 단위로 캡슐화할 수 있습니다.
모듈화, 재사용성, 작업 효율성 증가, 일관된 머터리얼 표현에 기여합니다.