C++11에 도입된 람다(Lambda) 함수는 무엇이며, 캡처(Capture) 방식(값 캡처 [=], 참조 캡처 [&], 특정 변수 캡처 [var], [&var])에 따른 차이점과 각각의 사용 시 주의사항을 설명하시오.
->
람다함수는 익명 함수를 코드 내에서 즉석으로 정의하고 사용할 수 있게 해줍니다. 람다함수는 클로저를 생성하며 이는 람다가 정의된 스코프 내의 변수들을 캡쳐하여 사용할 수 있게 합니다.
[=] 값 캡쳐는 람다 외부 스코프에 있는 모든 지역변수를 값으로 복사하여 람다 내부에서 사용할 수 있도록 합니다. [var] 특정 변수 var만 값으로 복사하여 람다 내부에서 사용할 수 있도록 합니다. 캡쳐된 변수는 람다 생성 시점의 값을 복사하며 람다 외부에서 원본 변수의 값이 변경되어도 람다 내부의 캡쳐된 값은 변경되지 않습니다. 람다 내부에서 캡쳐된 변수를 수정하려면 람다를 mutable로 선언해야 합니다.
[&] 참조 캡쳐는 람다 외부 스코프에 있는 모든 지역변수를 참조로 캡쳐합니다. [&var] 특정 변수 var만 참조로 캡쳐합니다. 캡쳐된 변수는 원본 변수의 별칭이므로 람다 외부에서 원본 변수의 값이 변경되면 람다 내부에서도 변경된 값을 사용합니다. 하지만 람다의 수명주기가 캡쳐된 변수의 수명주기보다 길면 댕글링 참조 문제가 발생할 수 있습니다.
[=, &var]와 같이 혼합하여 사용할 수도 있습니다.

C++에서 std::function과 std::bind는 각각 어떤 용도로 사용되며, 런타임에 다양한 형태의 콜백(Callback)이나 함수 객체를 저장하고 호출하는 데 어떻게 활용되는지 설명하시오.
->
std::function은 다양한 종류의 호출 가능한 객체를 저장하고 호출할 수 있는 범용적인 함수 래퍼입니다. 런타임에 콜백 함수를 유연하게 변경하거나 저장해야 할때 사용됩니다.
std::bind는 함수 객체, 함수 포인터, 멤버 함수 포인터의 인수를 바인딩하거나 재배열하여 새로운 함수 객체를 생성하는데 사용됩니다. 특정 함수의 일부 인수를 미리 고정하여 전달하거나 멤버 함수를 일반 함수처럼 호출할 수 있도록 만들때 유용합니다. 람다가 등장하며 사용 빈도가 줄었지만 여전히 사용처가 존재합니다.

C++의 네 가지 명시적 타입 캐스트 연산자(const_cast, static_cast, dynamic_cast, reinterpret_cast)의 주된 용도를 각각 설명하고, 이들의 안전성 측면에서의 차이점 및 사용 시 주의사항을 논하시오.
->
const_cast: 객체의 const 또는 volatile 한정자를 제거하거나 추가하는데 사용됩니다. 주로 const 객체를 인자로 받지 않는 레거시 함수에 const 객체를 전달해야 할 때 사용됩니다. const_cast를 통해 const 객체의 const를 제거하고 값을 변경하려고 시도할 경우 해당 객체가 실제로 const 메모리에 있거나 const로 선언된 변수라면 미정의 동작을 유발할 수 있습니다. 원래 const가 아니었지만 const 포인터/참조로 전달된 경우에만 안전하게 const를 제거하고 수정할 수 있습니다.
static_cast: 서로 관련있는 타입 간의 변환에 사용됩니다. 주로 숫자타입 변환, void*와 다른 포인터 타입 간의 변환, 기본 클래스 포인터/참조를 파생 클래스 포인터/참조로 변환(다운캐스팅, 안전하지않음), 파생 클래스 포인터/참조를 기본 클래스 포인터/참조로 변환(업캐스팅, 안전함) 등에 사용됩니다. 컴파일 시점에 타입 체크가 이루어집니다. 상대적으로 안전하나 다운캐스팅 시 주의가 필요합니다. 실제 객체가 파생 클래스 타입이 아닌데 파생 클래스 타입으로 static_cast를 시도하면 컴파일러 오류는 발생하지 않지만 잘못된 메모리에 접근하여 미정의 동작을 유발할 수 있습니다.
dynamic_cast: 클래스 계층 구조 내에서 안전한 다운캐스팅을 수행하는데 사용됩니다. 반드시 다형적인 클래스에만 적용할 수 있습니다. 런타임에 타입 정보를 확인(RTTI)하여 캐스팅의 유효성을 검사합니다. 캐스팅이 성공하면 유효한 포인터/참조를 변환하고 실패하면 포인터의 경우 nullptr을, 참조의 경우 std::bad_cast 예외를 발생시킵니다. 따라서 런타임에 실제 객체 타입에 따라 안전하게 처리할 수 있습니다. 하지만 RTTI 오버헤드가 있고 다형적인 클래스에만 적용 가능하다는 제약이 있습니다.
reinterpret_cast: 서로 전혀 관련없는 타입 간의 비트 단위 재해석 변환에 사용됩니다. 주로 저수준 프로그래밍(하드웨어 제어, 주소 변환, 시스템 호출 인터페이스 등)에서 사용되며 포인터와 정수 타입 간의 변환, 서로 다른 포인터 타입 간의 변환 등에 쓰입니다. 컴파일러가 어떠한 안전성 검사도 수행하지 않으며 단지 비트 패턴을 그대로 다른 타입으로 해석합니다. 잘못 사용하면 미정의 동작, 메모리 손상, 보안 취약점 등을 쉽게 유발할 수 있습니다. 특별한 이유 없이는 사용을 피해야 하며 사용하더라도 극도로 주의하고 플랫폼 의존성을 인지해야 합니다.



**전략 패턴(Strategy Pattern)**은 무엇이며, 게임 개발에서 캐릭터의 행동(예: 다양한 공격 방식, 이동 로직)을 유연하게 변경하고 확장하는 데 어떻게 적용될 수 있는지 구체적인 예시와 함께 설명하시오.
->
전략 패턴은 알고리즘군을 정의하고 각 알고리즘을 캡슐화하며 이들을 상호 교환 가능하게 만드는 디자인 패턴입니다. 이는 클라이언트로부터 알고리즘을 사용하는 방법을 분리하여 알고리즘을 독립적으로 변경하거나 확장할 수 있게 합니다. 게임 캐릭터의 다양한 행동 로직을 유연하게 변경하고 확장하는데 이상적입니다. 각 행동 로직을 별도의 전략 클래스로 캡슐화하고 캐릭터는 런타임에 이 전략을 동적으로 변경할 수 있습니다. (Interface 활용)
런타임에 행동 로직을 쉽게 변경할 수 있고 새로운 행동 방식을 추가하더라도 기존 코드를 수정할 필요 없이 새로운 전략 클래스만 추가하면 됩니다. 각 전략은 독립적으로 개발되고 테스트될 수 있으며 다른 캐릭터나 시스템에서도 재사용될 수 있습니다.

**옵저버 패턴(Observer Pattern)**은 무엇이며, 게임 내 이벤트 시스템(예: UI 업데이트, 게임 상태 변경 알림, 플레이어 스탯 변화 감지)을 구현하는 데 어떻게 활용될 수 있는지 설명하시오.
->
옵저버 패턴은 객체 간의 일대다 의존성을 정의하는 디자인 패턴입니다. 한 객체의 상태가 변경될 때 그 객체에 의존하는 모든 객체들에게 자동으로 알림이 가고 그에 따라 자신의 상태를 업데이트하도록 합니다. 옵저버 패턴은 게임 내에서 발생하는 다양한 이벤트 발생 시 종속된 시스템들이 반응하도록 하는 이벤트 시스템을 구현하는데 매우 효과적입니다. 핵심 구성요소는 주제(Subject)와 옵저버(Observer)로 주제는 이벤트를 발생시키는 객체로 옵저버를 등록/해제하고 상태 변경 시 등록된 모든 옵저버에게 알립니다. 옵저버는 이벤트에 반응하는 객체로 주제에 등록되어 있다가 알림을 받으면 정의된 동작을 수행합니다. 일반적으로 Update()와 같은 콜백 함수를 가집니다.
UI 업데이트, 게임 상태 변경 알림, 플레이어 스탯 변화 감지 등에 활용될 수 있습니다.
주제와 옵저버 간에 직접적인 의존성을 줄여서 한 쪽의 변경이 다른 쪽에 미치는 영향을 최소화합니다. 새로운 옵저버를 쉽게 추가하거나 제거할 수 있으며 이는 새로운 기능을 추가하거나 기존 기능을 변경할 때 유연성을 제공합니다. 이벤트 시스템의 핵심 로직을 재사용하기 용이합니다.

대규모 게임 프로젝트에서 **버전 관리 시스템(Source Control System)**으로 Git 또는 Perforce를 사용할 때의 일반적인 워크플로우(WorkFlow)와 바이너리 에셋(Binary Assets)에서 발생하는 충돌(Conflict)을 해결하기 위한 전략에 대해 아는 대로 설명하시오.
->
대규모 게임 프로젝트에서 버전 관리 시스템(VCS)는 협업, 코드 및 에셋 변경 이력 관리, 충돌 해결에 필수적입니다. Git과 Perforce는 게임 개발에서 가장 널리 사용되는 두가지 VCS입니다.
일반적인 워크플로우는 중앙 저장소를 설정하고 개발자들은 이를 로컬로 클론하거나 워크스페이스를 생성합니다. 새로운 기능 개발이나 버그 수정을 위해 브랜치를 생성합니다. Git은 로컬 프랜치 생성이 용이하고 빠르게 전환 가능하며 Perforce는 작업 공간 설정 및 체인지리스트를 활용합니다. 개발자는 코드 및 에셋을 수정하고 주기적으로 변경 사항을 로컬 저장소에 커밋하거나 체인지리스트에 추가하여 중앙 서버에 체크인합니다. Git은 작업 중에는 주기적으로 원격 저장소에서 최신 변경 사항을 풀링하여 자신의 로컬 브랜치에 병합하거나 리베이스합니다. 작업 완료 후에는 자신의 브랜치를 메인 브랜치로 병합하기 위해 풀 리퀘스트를 생성하고 코드 리뷰를 거칩니다. Perforce는 작업 시작 전 최신 버전을 Get Lastest Revision으로 가져오고 작업 완료 후 자신의 체인지리스트를 서버에 Submit합니다. 다른 개발자의 변경 사항은 Integrate 또는 Merge 명령으로 가져옵니다. 충돌이 발생하면 텍스트 파일은 시각적으로 비교하고 수동으로 해결할 수 있고 바이너리 에셋의 경우 텍스트 파일처럼 줄 단위 병합이 안되어 덮어 씌우는 방향으로 해결합니다.
바이너리 에셋 충돌에 대한 해결방법으로 Perforce에서는 파일락 기능을 강력하게 지원합니다. 특정 바이너리 에셋을 수정하려는 개발자는 먼저 해당 파일을 락하여 다른 개발자가 동시에 수정하지 못하도록 합니다. 이렇게 하면 한번에 한명의 개발자만 해당 파일을 수정할 수 있으므로 바이너리 충돌을 원천적으로 방지합니다. 바이너리 충돌이 발생하지 않으므로 에셋 관리자나 아티스트의 작업 흐름을 크게 단순화합니다. 락을 건 개발자가 작업을 끝내고 락을 해제할 때까지 다른 개발자는 해당 파일을 수정할 수 없어 병렬 작업이 제한될 수 있습니다. 또는 에셋 단위 분할, 에셋 관리 툴을 통합하여 충돌 문제를 관리하기도 합니다.



언리얼 엔진의 **애니메이션 몽타주(Animation Montage)**는 무엇이며, 캐릭터의 특정 동작(예: 공격, 스킬 사용, 피격)을 애니메이션 블루프린트와 분리하여 재생, 제어, 블렌딩하는 데 어떻게 사용되는지 설명하시오.
->
애니메이션 몽타주는 UE에서 캐릭터의 특정 동작을 애니메이션 블루프린트의 주요 스테이트 머신 흐름과 분리하여 제어, 재생, 블렌딩할 수 있도록 설계된 애니메이션 에셋입니다. 짧고 반복적이지 않은 이벤트 기반의 애니메이션 시퀀스를 관리하는데 주로 사용됩니다.
애니메이션 몽타주는 별도의 재생 제어, 블렌딩, 애니메이션 블루프린트와의 분리, 섹션 및 노티파이 사용을 위해 사용됩니다.

언리얼 엔진에서 게임을 패키징(Packaging)하기 전에 수행되는 "쿠킹(Cooking)" 과정은 무엇이며, 이 과정이 원본 에셋을 어떤 방식으로 최종 게임 빌드에 최적화하고 통합하는 데 기여하는지 설명하시오.
->
UE에서 게임을 배포 가능한 형태로 만들기 전 쿠킹 과정은 원본 에셋을 특정 플랫폼에 최적화된 최종 게임 빌드에 통합하는 필수적인 프로세스입니다.
쿠킹 과정의 역할은 플랫폼 최적화, 데이터 압축 및 직렬화, 불필요한 데이터 제거, 에셋 청킹 및 패키징, 의존성 해결 등을 담당합니다.
쿠킹 과정을 통해 UE는 원본의 방대한 개발 데이터를 특정 플랫폼에서 효율적으로 실행될 수 있는 작고 빠른 런타임 데이터 형식으로 변환합니다. 이는 게임의 로딩 시간을 단축하고 메모리 사용량을 최적화하며 전반적인 런타임 성능을 향상시키는데 결정적인 역할을 합니다. 개발자는 에디터에서 자유롭게 고품질 에셋을 작업하고 쿠킹 과정을 통해 자동으로 다양한 플랫폼에 맞게 최적화된 빌드를 생성할 수 있게 됩니다.

언리얼 엔진의 TInlineAllocator는 무엇이며, TArray와 같은 컨테이너에서 작은 크기의 배열 데이터에 대해 힙 할당을 피하고 스택에 직접 메모리를 할당하여 성능을 최적화하는 데 어떻게 사용되는지 설명하시오.
->
TInlineAllocator는 UE의 컨테이너 클래스에서 사용되는 메모리 할당 전략의 한 종류입니다. 이는 작은 크기의 배열 데이터에 대해 힙 할당을 피하고 스택에 직접 메모리를 할당하여 성능을 최적화하는데 사용됩니다.
TArray와 같은 컨테이너는 기본적으로 TArray<T, InAllocatorType>와 같이 템플릿 인자로 할당자 타입을 받습니다. 기본 할당자는 힙에서 메모리를 할당하는 FHeapAllocator입니다. TInlineAllocator는 내부적으로 미리 고정된 크기(InlineBytes)의 버퍼를 스택에 가지고 있습니다. TArray가 요소를 저장할 공간이 필요할 때 먼저 TInlineAllocator가 제공하는 내부 인라인 버퍼를 사용하려고 시도합니다. 만약 필요한 공간이 인라인 버퍼의 크기를 초과하면 그때서야 FHeapAllocator와 같은 다른 할당자를 사용하여 힙에서 메모리를 할당합니다.
이를 통해 힙 할당 오버헤드를 회피하고 메모리 단편화 감소, 캐시 효율성 등의 성능 최적화 이점을 챙길 수 있습니다.
TArray<FVector, TInlineAllocator<8>> VectorArray;
위의 TArray는 FVector 타입의 요소를 최대 8개까지는 힙 할당 없이 스택에 직접 저장할 수 있는 공간을 가집니다. 만약 8개 이상의 FVector가 필요하면 그때부터 힙에 할당됩니다. UE의 많은 내부 컨테이너나 함수 파라미터에서 TInlineAllocator를 사용하여 작은 임시 배열이나 문자열 처리에 대한 성능을 최적화합니다. 인라인 버퍼의 크기가 너무 크면 스택 메모리를 낭비하거나 스택 오버플로우 위험을 증가시킬 수 있으므로 적절한 크기 설정이 중요합니다.

언리얼 엔진의 Behavior Tree에서 **커스텀 태스크(Custom Task), 서비스(Service), 데코레이터(Decorator)**는 각각 어떤 역할을 하며, AI 행동 로직을 C++로 확장하고 재사용하는 데 어떻게 활용되는지 설명하시오.
->
UE의 BehaviorTree는 복잡한 인공지능의 행동 로직을 시각적으로 설계하고 구현하는데 사용되는 트리 구조의 시스템입니다. 각 노드는 AI의 의사결정 및 행동을 나타내며 개발자는 이들을 C++ 또는 블루프린트로 확장할 수 있습니다.
커스텀 태스크는 AI가 실제로 수행할 특정 단일 행동을 정의합니다. 적 공격하기, 아이템 줍기, 경로 순찰하기, 대기하기와 같은 구체적인 동작을 구현합니다.
서비스는 태스크가 실행되기 전에 주기적으로 실행되는 로직을 정의합니다. 주로 AI의 현재 상태를 관찰하거나 업데이트하거나 특정 데이터를 수집하는데 사용됩니다.
데코레이터는 특정 태스크 또는 서브트리의 실행 조건을 정의하거나 실행 결과에 따라 성공/실패 여부를 변경하는데 사용됩니다. AI가 특정 행동을 수행할지 말지를 결정하는 논리적인 게이트 역할을 합니다.
위 세가지 컴포넌트는 BehaviorTree의 모듈성과 확장성을 크게 높입니다. 개발자는 각 AI 행동의 무엇(Task), 어떻게(Service), 언제(Decorator)를 명확하게 분리하여 구현할 수 있습니다. 각 컴포넌트는 독립적인 로직 단위를 형성하므로 한번 구현하면 다양한 AI 캐릭터의 BehaviorTree에서 조합하여 복잡한 행동을 손쉽게 구성할 수 있습니다. 이는 개발 시간을 단축하고 코드 일관성을 유지하는데 큰 이점이 됩니다. 행동 로직이 잘게 나뉘어 있으므로 특정 행동을 수정하거나 디버깅하기가 용이합니다. 이러한 커스텀 컴포넌트들을 C++로 구현한 후 블루프린트에서 사용하여 AI 디자이너가 C++ 코드 지식 없이도 복잡한 AI 행동을 시각적으로 조립할 수 있게 합니다.