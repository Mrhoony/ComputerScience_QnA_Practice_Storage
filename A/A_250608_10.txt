C++20에 도입된 [[likely]]와 [[unlikely]] 속성(attribute)은 무엇이며, 컴파일러가 조건부 분기(conditional branch)의 실행 빈도를 예측하여 코드의 성능을 어떻게 최적화하는 데 사용되는지 설명하시오.
->
개발자가 컴파일러에게 조건부 분기의 실행 빈도에 대한 힌트를 제공하는데 사용됩니다.
[[likely]]는 이 조건이 참일 가능성이 높음을, [[unlikely]]는 이 조건이 참일 가능성이 낮음을 컴파일러에게 알려줍니다.
CPU는 분기 예측이라는 기능을 사용하여 다음에 실행될 코드를 미리 예측하고 캐시에 로드하여 성능을 높입니다. 개발자가 [[likely]] 또는 [[unlikely]]를 사용하면 컴파일러는 이 힌트를 바탕으로 분기 예측을 최적화할 수 있는 기계어 코드를 생성합니다. 이를 통해 캐시 효율성을 높이거나 false 경로로의 점프를 최소화 하는 등의 최적화를 수행합니다. 분기 예측 실패로 인한 성능 저하를 줄여 전체적인 프로그램 실행 속도를 향상시킬 수 있습니다.

std::tuple (C++11)과 C++17의 구조적 바인딩(Structured Bindings)은 무엇이며, 여러 값을 함수에서 반환하거나 복합 데이터를 다룰 때 어떤 이점을 제공하는지 설명하시오.
->
std::tuple은 C++11에 도입된 임의의 개수와 타입의 요소들을 저장할 수 있는 고정 크기의 이종 컨테이너입니다. std::pair의 일반화된 형태라고 볼 수 있습니다. 함수에서 여러개의 독립적인 값을 하나의 객체로 묶어 반환하거나 서로 다른 타입의 데이터들을 묶어 다룰 때 유용합니다.
구조적 바인딩은 std::tuple, std::pair, 구조체, 배열 등 여러 요소를 가진 객체에서 각 요소를 개별 변수처럼 선언하고 접근할 수 있게 하는 구문입니다. 복잡한 객체에서 특정 멤버들을 추출하여 사용하거나 함수에서 여러 값을 반환받을 때 코드를 훨씬 간결하고 가독성 있게 만들어줍니다. 별도의 임시 변수를 선언할 필요가 없어 생산성이 향상됩니다.

CRTP(Curiously Recurring Template Pattern)는 무엇이며, C++에서 정적 다형성(Static Polymorphism)이나 믹스인(Mixins)과 같은 설계 패턴을 구현하는 데 어떻게 활용될 수 있는지 설명하시오.
->
재귀적으로 발생하는 템플릿 패턴이라는 의미로 기본 클래스 템플릿이 자기 자신의 파생 클래스를 템플릿 인자로 받는 형태의 디자인 패턴입니다.
런타임에 가상 함수 테이블을 통한 오버헤드 없이 컴파일 시점에 호출될 함수가 결정(정적 다형성)됩니다. Base 클래스에서 Derived 클래스의 메서드를 static_cast를 통해 호출함으로써 런타임 다형성과 유사한 기능을 제공하지만 더 높은 성능을 가집니다. 여러가지 독립적인 기능을 다른 클래스에 주입하여 재사용가능한 컴포넌트를 만들때 사용(믹스인, Mixins)됩니다. 각 믹스인은 CRTP를 통해 호스트 클래스의 특정 기능에 접근하거나 호스트 클래스에 새로운 기능을 추가할 수 있습니다.



3D 그래픽스에서 PBR(Physically Based Rendering)은 무엇이며, 기존 렌더링 방식과 비교했을 때 어떤 시각적 이점(더 사실적인 표현)과 머티리얼 제작 접근 방식의 변화를 가져왔는지 설명하시오.
->
PBR은 빛과 물질의 물리적 특성을 기반으로 렌더링을 수행하는 기법입니다. 빛이 오브젝트 표면과 상호작용하는 방식(반사, 흡수, 산란 등)을 실제 물리 법칙에 가깝게 시뮬레이션하여 더욱 사실적인 이미지를 생성합니다. 현실적인 조명 반응과 직관적인 머터리얼 제작과 높은 재사용성의 이점이 있습니다. 머터리얼 제작 과정에서 PBR은 Metallic, Roughness, Specular, BaseColor와 같은 물리적 기반 입력 값을 사용하고 에너지 보존 법칙을 준수하여 비현실적인 밝기를 방지하고 워크플로우를 표준화했습니다.

온라인 게임에서 "네트워크 권한(Network Authority)"이란 무엇이며, 클라이언트 권한(Client Authority)과 서버 권한(Server Authority)의 차이점을 설명하고, 각각 어떤 장단점을 가지는지 비교하시오.
->
특정 게임 상태나 오브젝트의 실제, 최종적인 상태를 누가 결정하고 관리하는가에 대한 개념입니다.
클라이언트 권한(Client Authority)는 클라이언트가 자신의 캐릭터 움직임, 액션 등 특정 게임 상태를 직접 결정하고 서버에 그 결과를 통보하는 방식입니다. 낮은 네트워크 지연으로 인해 플레이어의 즉각적인 반응성이 뛰어나고 서버의 부하가 적습니다. 치트에 취약하고 클라이언트가 임의로 게임 상태를 조작할 수 있으므로 핵 사용이 용이합니다. 공정성 문제가 발생할 수 있습니다. 주로 싱글 플레이어 기반의 게임에서 멀티플레이어 기능을 추가하거나 빠르게 움직이는 액션 게임에서 반응성이 가장 중요할 때 제한적으로 사용됩니다.
서버 권한(Server Authority)는 서버가 게임의 모든 중요한 상태와 로직을 결정하고 관리하며 클라이언트는 서버의 상태를 받아 단순히 렌더링하거나 제한된 입력만 보냅니다. 치트 방지에 강력합니다. 서버가 모든 것을 통제하므로 공정성이 보장됩니다. 모든 플레이어에게 일관된 게임 상태를 제공합니다. 네트워크 지연에 민감하며 클라이언트의 반응성이 떨어질 수 있습니다. 서버의 부하가 커질 수 있습니다. 대부분의 대규모 온라인 멀티플레이어 게임(MMORPG, FPS 등)에서 핵 방지 및 공정성 유지를 위해 핵심적인 게임 로직과 상태 관리에 사용됩니다.

CPU 캐시 메모리에서 "캐시 일관성(Cache Coherence)" 문제란 무엇이며, 다중 코어(Multi-core) 프로세서 환경에서 이러한 문제가 발생하는 원인과 이를 해결하기 위한 기본적인 메커니즘을 설명하시오.
->
다중 코어 프로세서 환경에서 여러 CPU 코어가 동일한 메모리 주소의 데이터를 각자의 캐시 메모리에 복사하여 저장했을 때 발생합니다. 한 코어가 캐시 내의 데이터를 변경하면 다른 코어의 캐시에 있는 동일한 데이터는 오래된 값이 되어 데이터 불일치가 발생하는 문제입니다.
각 코어가 독립적으로 캐시를 가지고 있기 때문에 공유 데이터에 대한 수정이 발생했을 때 다른 코어의 캐시가 즉시 업데이트되지 않기 때문입니다.
각 코어의 캐시 컨트롤러가 버스 상의 모든 메모리 트랜잭션을 감시(스누핑)합니다. 만약 다른 코어가 자신이 캐싱하고 있는 메모리 주소의 데이터를 수정하는 것을 감지하면 해당 데이터를 자신의 캐시에서 무효화하거나 업데이트합니다. 이를 통해 항상 최신 데이터를 사용하도록 합니다.
대규모 시스템에서 스누핑의 버스 트래픽 오버헤드를 줄이기 위해 디렉토리 기반이 사용됩니다. 중앙 디렉토리가 각 메모리 블록이 어떤 코어의 캐시에 복사되어 있는지 그리고 수정되었는지 여부를 추적합니다. 데이터가 수정되면 디렉토리가 해당 데이터를 캐싱하고 있는 다른 코어들에게 직접 메세지를 보내 캐시를 업데이트하거나 무효화하도록 지시합니다.



언리얼 엔진에서 PBR 기반 머티리얼을 생성할 때, Metallic, Roughness, Specular, Normal 맵 등 주요 입력 값들이 어떤 물리적 의미를 가지며 렌더링 결과에 어떻게 영향을 미치는지 설명하시오.
->
BaseColor는 기본색상으로 물리적으로 빛이 유전체 표면에 닿았을 때 확산 반사되는 빛의 색상을 정의합니다. 렌더링에서 오브젝트의 주요 색상을 결정합니다. 유전체의 경우 어두운 색일수록 빛을 많이 흡수하고 밝은 색일수록 많이 반사합니다.
Metallic은 금속성으로 물리적으로 표면이 금속인지 유전체인지를 정의합니다. 금속은 확산 반사 없이 모든 빛을 스페큘러 반사하고 유전체는 확산 반사와 스페큘러 반사가 모두 일어납니다. 렌더링에서 0과 1 사이 값으로 표면의 반사 방식을 극적으로 변화시켜 금속적인 외형을 부여합니다.
Roughness는 거칠기로 물리적으로 표면의 미세한 요철의 정도를 정의합니다. 거칠기가 낮으면 표면이 매끄러워 빛이 정반사되어 선명한 반사를 만들고 거칠기가 높으면 표면이 거칠어 빛이 여러 방향으로 산란되어 흐릿한 반사를 만듭니다. 렌더링에서 스페큘러 하이라이트의 크기와 선명도를 조절합니다. 0.0은 완벽하게 매끄러운 표면을 1.0은 매우 거친 표면을 나타냅니다.
Specular는 비금속 전용 반사로 물리적으로 비금속 표면의 반사 강도를 정의합니다. 빛이 표면에 닿았을 때 반사되는 빛의 양을 제어합니다. 렌더링에서 비금속 오브젝트의 광택의 밝기를 조절합니다. 일반적으로 0.5정도의 회색 값으로 고정하여 사용하는 경우가 많습니다.
Normal 맵은 법선 맵으로 물리적으로 픽셀 단위로 표면의 법선 벡터를 재정의합니다. 실제 지오메트리 변경 없이 세부적인 표면 디테일(주름, 요철, 긁힌 자국)을 표현합니다. 렌더링에서 오브젝트의 표면을 음영으로 변경하여 실제로는 평평한 면이지만 울퉁불퉁하거나 세부적인 디테일이 있는 것처럼 보이게 합니다. 이는 모델의 폴리곤 수를 줄이면서도 시각적 품질을 높이는 데 핵심적입니다.

언리얼 엔진에서 stat net 또는 stat net show와 같은 네트워크 프로파일링 명령어를 사용하여 어떤 정보를 얻을 수 있으며, 이를 통해 네트워크 성능 문제(예: 대역폭 사용량, 패킷 손실)를 어떻게 진단할 수 있는지 설명하시오.
->
현재 네트워크 통신에 대한 실시간 통계 정보를 화면에 오버레이로 표시합니다. 대역폭 사용량, 패킷 손실률, 핑, 패킷 수, 복제되는 액터 수, 복제되는 프로퍼티 수/크기, RPC 호출 수 등의 정보를 알 수 있으며 이를 통해 현재 네트워크의 성능을 파악하고 문제가 되는 부분을 확인할 수 있습니다.

언리얼 엔진의 GameplayTagQuery 시스템은 무엇이며, 복잡한 조건(예: 특정 태그 포함, 다른 태그는 제외, 태그 집합의 교집합)을 사용하여 액터나 에셋을 필터링하고 게임 로직을 구현하는 데 어떻게 사용될 수 있는지 설명하시오.
->
FGameplayTagQuery 구조체를 사용하여 하나 이상의 GameplayTag 또는 GameplayTagContainer에 대해 복잡한 조건을 구성하고 다른 GameplayTagContainer가 이 쿼리를 만족하는지 여부를 검사하는 시스템입니다. 특정 태그의 포함/제외, 태그 집합의 교집합/합집합, 태그를 활용한 게임 로직 구현 등에 사용됩니다.

언리얼 엔진에서 비동기 에셋 로딩(Asynchronous Asset Loading)은 무엇이며, 게임 플레이 중 끊김 없는 경험을 제공하고 로딩 시간을 최적화하는 데 (예: 레벨 스트리밍, 대규모 에셋 로딩) 어떻게 활용되는지 설명하시오.
->
게임이 실행 중인 동안 별도의 스레드에서 백그라운드로 에셋을 메모리에 로드하는 방식입니다. 메인 게임 스레드가 에셋 로딩 작업으로 인해 멈추는 것을 방지합니다. 레벨 스트리밍, 대규모 에셋 로딩 시 사용되는 방식입니다.