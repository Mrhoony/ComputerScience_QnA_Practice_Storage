C++ 디자인 패턴 중 싱글톤(Singleton) 패턴과 옵저버(Observer) 패턴의 개념을 설명하고, 게임 개발에서 각각 어떤 경우에 사용될 수 있는지 간단한 예시를 드시오.
->
싱글톤 패턴은 특정 클래스의 인스턴스가 프로그램 전체에서 단 하나만 존재하도록 보장하고 그 인스턴스에 대한 전역적인 접근 방법을 제공하는 디자인 패턴입니다. 언리얼 엔진에서 CDO가 싱글톤 개념이 적용되어 있고 서브시스템 클래스 제작 시 싱글톤 패턴을 이용합니다.
옵저버 패턴은 객체들 간의 일대다 의존성을 정의하는 디자인 패턴입니다. 어떤 객체의 상태가 변경될 때 이 객체를 주시하고 있는 모든 의존적인 객체들에게 자동으로 알림이 가고 업데이트되도록 합니다. 일반적으로 게임스테이트와 Widget의 관계가 옵저버 패턴을 이용합니다.

C++에서 예외 안전성(Exception Safety)의 세 가지 보장 수준(No-throw guarantee, Strong guarantee, Basic guarantee)에 대해 설명하시오.
->
no-throw guarantee: 함수나 연산이 절대 예외를 던지지 않을 것을 보장합니다.
strong guarantee: 예외가 발생하면 연산이 시도되기 전의 원래 상태로 완벽하게 되돌려 놓음을 보장합니다.
basic guarantee: 예외가 발생할 수 있지만 발생하더라도 리소스 누수가 없고 프로그램은 유효하고 사용가능한 상태를 유지함을 보장합니다.

reinterpret_cast는 언제 사용하며, 다른 캐스팅 연산자(static_cast, dynamic_cast)와 비교했을 때 어떤 위험성이 있는지 설명하시오.
->
서로 관련없는 포인터 타입 간의 변환, 포인터 타입과 정수 타입 간의 변환, 매우 낮은 수준의 비트 단위 재해석이 필요할 때 사용합니다.
컴파일 시점이나 런타임에 타입 체크를 수행하지 않습니다. 크래시나 데이터 손상을 유발할 수 있습니다.

C++에서 프리프로세서(Preprocessor) 지시자(예: #ifdef, #pragma once)의 사용 목적과 주의할 점을 설명하시오.
->
전처리기(Preprocessor)는 컴파일이 시작되기 전에 소스 코드를 전처리하는 단계에서 작동하는 프로그램입니다. 프리프로세서 지시자는 전처리기가 수행할 작업을 지시합니다.
조건부 컴파일, 헤더 파일 중복 포함 방지, 매크로 정의 및 확장 등의 작업을 진행할 수 있습니다.
매크로는 타입 체크를 수행하지 않아서 예기치 않은 오류를 발생시킬 수 있습니다.

C++에서 mutable 키워드는 언제, 왜 사용하며 어떤 의미를 가지는지 설명하시오.
->
const로 선언된 객체나 함수 내일지라도 const 상태에 구속받지 않고 변경하고자 할 때 사용하는 키워드입니다. 객체의 논리적인 상태(주로 읽기전용)에 상관없이 내부 관리용 멤버 변수에 사용될 수 있습니다.

friend 키워드는 무엇이며, 캡슐화 원칙과 관련하여 어떤 장단점을 가지는지 설명하시오.
->
friend 키워드는 특정 함수나 다른 클래스가 friend로 선언된 클래스의 private 및 protected 멤버에 직접 접근할 수 있도록 허용하는 접근 지정자입니다. 원래는 접근이 제한되는 변수 및 함수에 접근할 수 있는 편의를 제공하지만 클래스 내부 구현이 외부에 노출되어 캡슐화 원칙이 깨집니다.

extern "C"는 무엇이며, C++ 코드에서 C 언어 라이브러리나 다른 언어의 라이브러리와 연동할 때 왜 필요한지 설명하시오.
->
extern "C"는 C++의 연결 지정 중 하나입니다. C++ 컴파일러에게 스코프 영역 내 선언된 함수나 변수를 C언어의 이름 맹글링 규칙과 호출 규약을 사용하여 처리하도록 지시합니다.
C++ 이름 맹글링은 C++ 컴파일러가 컴파일 시점에 함수 이름과 매개변수 타입 등의 정보를 조합하여 고유한 맹글링된 이름을 생성하는 것을 말합니다. 링커는 맹글링된 이름을 사용하여 함수 정의를 찾습니다.
C언어 라이브러리 연동 시 extern "C"는 C++ 컴파일러에게 이 함수는 C언어의 규칙에 따라 심볼을 작성했으니 이 이름으로 맹글링 없이 심볼을 찾거나 생성할 것을 알려줄 수 있습니다.

C++에서 함수 오버로딩(Function Overloading)과 함수 오버라이딩(Function Overriding)의 차이점을 설명하시오.
->
함수 오버로딩은 동일한 함수가 매개변수 목록에 따라 여러개의 선언을 하는 것을 의미합니다.
함수 오버라이딩은 상속 관계에 있는 클래스에서 기반 클래스에서 선언된 가상 함수의 구현부를 파생 클래스에서 재구현하여 사용하는 것을 의미합니다.

C++11에 도입된 위임 생성자(Delegating Constructors)란 무엇이며, 어떤 장점이 있는지 설명하시오.
->
위임 생성자란 한 클래스의 생성자가 동일한 클래스의 다른 생성자를 호출하여 객체 초기화의 일부 또는 전부를 수행하도록 하는 것입니다.
코드 중복을 제거하고 마스터 생성자의 로직만 관리하면 되는 유지보수의 이점을 가집니다.

final 키워드는 클래스 또는 멤버 함수에 사용될 때 어떤 의미를 가지며, 어떤 경우에 유용하게 사용될 수 있는지 설명하시오.
->
final은 클래스/가상멤버함수의 상속/오버라이딩을 제한하는 키워드입니다.
협업중인 다른 작업자에게 디자인 의도를 명확히 전달할 수 있습니다.



3D 그래픽스에서 알파 블렌딩(Alpha Blending)의 개념과 반투명(Transparency) 오브젝트 렌더링 시 고려해야 할 사항을 설명하시오.
->
알파 블렌딩은 2개의 색상을 섞어 새로운 색상을 만드는 기법으로 주로 반투명 효과를 구현하는데 사용합니다. 알파값을 이용하여 전경 픽셀의 색상과 배경 픽셀의 색상을 얼마나 혼합할지 결정하기 때문에 알파 블렌딩이라고 명칭되었습니다.
FinalColor = SourceColor * SourceAlpha + DestColor * (1 - SourceAlpha) // 0 <= SourceAlpha <= 1
반투명 오브젝트를 렌더링하는 경우 드로잉 순서와 깊이 정령이 가장 중요한 고려사항입니다. 반투명 오브젝트는 깊이 버퍼에 쓰지 않으며 반투명 오브젝트가 여러겹 겹쳐지는 오버드로가 발생하지 않도록 유의해야 합니다.

LOD(Level of Detail) 기법은 그래픽스 성능 최적화에 어떻게 기여하는지 설명하고, 지오메트리(Geometry) LOD와 텍스처(Texture) LOD에 대해 간략히 설명하시오.
LOD(Level of Detail)는 오브젝트의 Detail Level을 카메라의 거리나 화면에서의 크기에 따라 동적으로 조절하여 렌더링하는 최적화 기법입니다.
화면에서 멀리 떨어져 있거나 작게 보이는 오브젝트는 표현할 픽셀의 수가 적어 세부적인 디테일이 잘 보이지 않으므로 낮은 수준의 모델이나 텍스처를 사용하여 필요한 GPU 연산을 줄여 렌더링 성능을 향상시킵니다.
지오메트리 LOD: 모델의 폴리곤 수(버텍스, 트라이앵글)를 단계적으로 줄여 렌더링합니다.
텍스처 LOD: 텍스처의 해상도를 단계적으로 줄여 렌더링합니다.

네트워크 통신 시 패킷 손실(Packet Loss)과 패킷 재정렬(Packet Reordering)이 게임 플레이에 미치는 영향과 이를 완화하기 위한 일반적인 접근 방식에 대해 설명하시오.
->
패킷 손실은 네트워크를 통해 전송된 데이터 패킷이 목적지에 도달하지 못하고 사라지는 현상입니다.
패킷 손실이 발생하면 멀티 플레이 게임에서 지연 및 끊김현상을 일으키며 싱크 불일치의 문제를 유발하고 플레이어의 조작 품질을 저하시킵니다. 안정적인 수준의 신뢰성이 보장되지 않는 경우 실시간성을 포기하고 TCP 프로토콜을 이용하여 통신하거나 클라이언트 예측 기법을 이용하여 패킷 손실의 패널티를 완화할 수 있습니다.
패킷 재정렬은 전송된 패킷들이 네트워크 경로의 차이 등으로 인해 순서가 다르게 도착하는 현상입니다. 지터나 추가 지연이 발생할 수 있으며 지터 번호나 패킷에 순서에 대한 인덱스값을 부여하여 수신측에서 순서를 확인할 수 있도록 하여 완화할 수 있습니다.

온라인 게임에서 기본적인 형태의 부정행위(Cheating)를 방지하기 위한 클라이언트 또는 서버 측의 일반적인 방어 전략(예: 서버 검증, 데이터 암호화)에 대해 설명하시오.
->
게임 플레이의 모든 중요한 로직은 오직 서버에서만 동작하거나 서버에서 최종 검증하도록 해야 합니다. 언리얼 엔진의 데디케이드 서버는 서버 권한 모델을 채용하고 있으며 모든 핵심 게임 상태나 로직은 서버에서 처리하도록 하여 부정행위를 방지할 수 있습니다.
클라이언트는 코드 난독화를 통해 디컴파일링이 어렵도록 하며 메모리/파일의 변조를 감지하고 차단하는 시스템을 구현하고 안티 치트 소프트웨어를 사용하며 클라이언트 데이터를 암호화하여 보호합니다.

운영체제에서 인터럽트(Interrupt)와 시스템 콜(System Call)의 개념을 설명하고, 운영체제가 이들을 통해 하드웨어 및 소프트웨어 자원을 관리하는 방법을 간략히 설명하시오.
->
인터럽트는 CPU가 현재 수행 중인 작업을 잠시 중단하고 특정 이벤트를 처리하기 위해 운영체제의 특정 루틴으로 제어권을 넘기는 매커니즘입니다. 하드웨어 인터럽트와 소프트웨어 인터럽트가 있습니다.
시스템 콜은 사용자 프로그램이 운영체제 커널이 제공하는 특권 기능을 사용하기 위해 운영체제에게 서비스를 요청하는 방법입니다.
운영체제는 인터럽트를 통해 주변 장치의 I/O 작업 완료를 효율적으로 인지하고 처리합니다.
CPU는 사용자 모드와 커널 모드를 가지며 사용자 모드 프로그램은 하드웨어에 직접 접근하거나 다른 프로그램의 메모리에 접근할 수 없어 자원 보호 및 격리 기능을 제공하고 시스템 콜을 통해 추상화 및 표준 인터페이스를 제공하여 표준화된 인터페이스를 통해 자원에 접근합니다.

알고리즘 설계 패러다임 중 분할 정복(Divide and Conquer)과 동적 계획법(Dynamic Programming)의 기본적인 아이디어를 설명하고, 각각 어떤 문제 해결에 적합한지 예시를 드시오.
->
분할 정복은 주어진 문제에 대해 더이상 나눌 수 없을 때까지 독립적인 작은 문제로 나누고 각 문제를 재귀적으로 해결한뒤 해답을 결합하여 원래 문제의 해답을 구하는 방식입니다. 퀵 정렬과 병합 정렬이 대표적인 분할 정복 알고리즘을 이용한 정렬 방식입니다.
동적 계획법은 큰 문제를 작은 부분 문제들로 나누는 것은 분할 정복과 유사하지만 부분 문제들이 겹치는 경우에 사용됩니다. 각 부분 문제를 한번만 해결하고 그 해답을 저장하여 나중에 같은 부분 문제가 필요할 때 해답을 재사용함으로서 중복 계산을 피합니다. 피보나치 수열 문제에서 동적 계획법을 이용하여 계산을 최소화 할 수 있습니다.

그래프 알고리즘 중 최소 신장 트리(Minimum Spanning Tree)의 개념과 대표적인 알고리즘(예: Prim, Kruskal)의 목적을 설명하시오.
->
가중치(Weight)를 가진 간선(Edge)들로 이루어진 연결된 무방향 그래프에서 모든 정점을 연결하면서 사이클을 포함하지 않는 부분 그래프 중 간선들의 가중치 합이 최소가 되는 트리를 최소 신장 트리라고 부릅니다.
주어진 모든 노드를 최소 비용으로 연결하는 네트워크를 구축하는 문제에 주로 사용됩니다. 대표적인 알고리즘으로 프림 알고리즘은 시작 정점에서부터 트리를 점진적으로 확장해 나가는 방식으로 MST를 구성하며 크루스칼 알고리즘은 모든 간선을 오름차순으로 정렬한 후 사이클을 형성하지 않는 순서대로 선택하여 MST를 구성합니다.

캐시 메모리의 작동 원리 중 한 종류인 쓰기 정책(Write Policy: Write-through, Write-back)에 대해 간략히 설명하시오.
->
Write-through: CPU가 캐시에 데이터를 쓸 때 동시에 메인 메모리에도 데이터를 씁니다. 캐시의 데이터가 변경되면 메인 메모리에도 변경 사항이 반영됩니다. 데이터의 일관성이 높으나 쓰기 작업의 속도가 느려질 수 있습니다.
Write-back: 우선 캐시에만 데이터를 쓰고 해당 캐시 라인에 더티비트를 설정합니다. 캐시라인이 더이상 필요없어서 교체되거나 캐시 내용이 플러시될 때만 더티비트가 설정된 캐시라인의 내용이 메인메모리에 기록됩니다. 캐시만 쓰기 떄문에 쓰기 성능이 빠르지만 메인 메모리와의 데이터 일관성 문제가 발생할 수 있습니다.

병렬 컴퓨팅에서 동시성(Concurrency)과 병렬성(Parallelism)의 차이점을 설명하시오.
->
동시성은 여러개의 작업이 동시에 진행되는 것처럼 보이는 상태를 의미합니다.
병렬성은 여러개의 작업이 실제로 동시에 실행되는 상태를 의미합니다.

가상 메모리 시스템에서 페이징(Paging)과 스와핑(Swapping)의 개념을 설명하시오.
->
페이징은 프로세스의 가상 주소 공간을 고정된 크기의 작은 블록인 페이지로 나누고 물리 메모리를 페이지와 동일한 크기의 프레임으로 나눕니다. 프로세스가 실행될 때 필요한 페이지만 물리 메모리에 적재하고 나머지는 보조 저장 장치에 보관합니다.
스와핑은 전체 프로세스를 일시적으로 물리 메모리에서 보조 저장 장치로 완전히 내보내고 나중에 필요할 때 다시 물리 메모리로 불러들이는 메모리 관리 기법입니다.



언리얼 엔진에서 에셋 레퍼런스(Asset Reference) 중 하드 레퍼런스(Hard Reference)와 소프트 레퍼런스(Soft Reference)의 차이점을 설명하고, 각각 언제 사용하는 것이 적합한지 설명하시오.
->
하드 레퍼런스는 UPROPERTY()로 선언된 UObject* 포인터나 블루프린트 내의 직접적인 객체 참조와 같이 대상 에셋에 대한 직접적인 메모리 참조를 의미합니다. 캐릭터의 스켈레탈 메시 등 반드시 존재해야하는 필수 에셋에 대해 하드 레퍼런스를 사용합니다.
소프트 레퍼런스는 TSoftObjectPtr<T> 또는 FSoftObjectPath와 같이 대상 에셋의 경로 정보만을 저장하는 레퍼런스입니다. 메모리에 직접적인 참조를 가지고 있지 않습니다. 선택적 로딩이 필요한 에셋에 대해 소프트 레퍼런스를 사용합니다.

언리얼 엔진의 GameInstance 클래스는 어떤 역할을 하며, 어떤 종류의 데이터나 로직을 관리하는 데 사용되는지 설명하시오.
->
언리얼 엔진에서 가장 높은 수준의 게임 로직 클래스 중 하나입니다. 게임이 실행되는 동안 단 하나의 인스턴스만 존재하며 게임의 전체 생명주기 동안 유지됩니다. 레벨 간에 공유되거나 게임 전체의 생명주기와 관련된 데이터를 관리하는데 사용됩니다.

언리얼 엔진의 Enhanced Input System에서 입력 컨텍스트(Input Context)의 개념과 사용 목적을 설명하시오.
->
실제 물리적인 입력을 게임 내의 특정한 입력 액션으로 매핑하는 규칙들의 집합을 정의하는 데이터 에셋입니다. 컨텐스트 기반 입력 관리와 매핑 충돌에 대한 우선순위 제어를 제공합니다.

언리얼 엔진 네트워크에서 액터의 Net Relevancy(네트워크 관련성)는 무엇이며, 어떻게 설정되며, 클라이언트 성능에 어떤 영향을 미치는지 설명하시오.
->
특정 클라이언트에게 해당 액터의 상태 변경 정보를 보낼 필요가 있는지 여부를 결정하는 개념입니다. 액터가 클라이언트에게 관련성이 있다고 판단될 때만 해당 클라이언트에게 액터의 업데이트 정보가 복제됩니다.
APawn::IsNetRelevantFor() 함수는 가상함수이므로 그대로 사용하거나 필요시 파생 클래스에서 재정의하여 사용합니다.
NetRelevancy를 설정함으로서 네트워크 대역폭을 절약할 수 있고 서버 및 클라이언트의 부하를 감소할 수 있어 성능의 최적화를 기대할 수 있습니다.

언리얼 엔진 애니메이션 시스템에서 블렌드 스페이스(Blend Space)는 무엇이며, 어떤 애니메이션 블렌딩 상황에 사용되는지 설명하시오.
->
하나 또는 두개의 입력 파라미터의 값에 따라 여러개의 개별 애니메이션 시퀀스를 부드럽게 보간하여 새로운 애니메이션을 생성하는데 사용되는 데이터 에셋입니다. 일반적으로 걷기와 뛰기등 기본적인 이동 동작에 대해서 속력과 회전값을 받는 블렌드스페이스2D 에셋을 구성하여 사용합니다. TPS나 FPS의 게임에서는 블렌드스페이스1D를 이용해 수직 방향에 대한 에임 오프셋을 구성하기도 합니다.

언리얼 엔진 애니메이션 시스템에서 IK(Inverse Kinematics, 역운동학)는 무엇이며, 어떤 경우에 유용하게 사용되는지 설명하시오.
->
스켈레탈 체인의 최종 관절의 위치와 방향을 지정했을 때 이 최종 관절에 도달하기 위해 체인에 있는 모든 중간 관절들의 위치 및 회전을 자동으로 계산해주는 기술입니다. 이는 루트 관절에서 시작하여 최종 관절의 위치를 결정하는 FK의 반대 개념입니다.
지형에 따른 발 위치 조정이나 손/무기 상호작용, 시선 추적 등에 사용됩니다.

언리얼 엔진 AI 시스템에서 블랙보드(Blackboard)는 무엇이며, 행동 트리(Behavior Tree)와 함께 AI의 상태 및 데이터 관리에 어떻게 사용되는지 설명하시오.
->
블랙보드는 AI 시스템에서 AI 에이전트의 동적인 상태와 작업 메모리를 저장하는 키-값 저장소입니다. 행동트리는 블랙보드를 사용하여 AI의 현재 상태, 목표, 인지된 정보 등을 공유하고 관리합니다. 행동트리와 블랙보드의 연동을 위해 제공하거나 임의로 생성한 태스크, 데코레이터, 서비스를 사용하여 AI의 행동을 제어합니다.

언리얼 엔진의 머티리얼(Material) 시스템에서 주요 노드 유형(예: Scalar Parameter, Vector Parameter, Texture Sample)과 각각의 역할을 설명하시오.
->
Scalar Parameter: 단일 부동 소수점 값을 나타냅니다.
Vector Parameter: 색상이나 3D 공간의 벡터를 나타내는 3개 또는 4개의 부동 소수점 값의 집합입니다.
Texture Sample: 외부에서 임포트된 텍스처 에셋을 머터리얼 그래프로 가져와 샘플링하여 텍스처의 색상 데이터를 읽어옵니다.
각 파라미터는 외부에서 값을 받아와서 머터리얼 그래프 내에서 노드를 제어하는 값으로 사용할 수 있습니다.

언리얼 엔진에서 포스트 프로세스 볼륨(Post Process Volume)은 무엇이며, 게임 화면에 어떤 시각적 효과를 적용하는 데 사용되는지 설명하시오.
->
액터 중 하나로 이 볼륨 내부에 카메라가 위치하거나 전역 설정으로 사용될 때 최종 렌더링 된 게임 화면에 다양한 시각적 효과를 적용할 수 있도록 하는 도구입니다. 색상 보정, 블룸, 비네트, SSAO, SSR, DOF, 노출, 모션 블러 등의 다양한 시각적 효과를 제공합니다.

언리얼 엔진에서 Destructible Mesh(파괴 가능한 메시)는 무엇이며, 환경 상호작용이나 게임 플레이에 어떤 식으로 활용될 수 있는지 설명하시오.
->
3D 모델을 특수하게 처리하여 파괴돌 수 있는 상태로 만든 메시 에셋입니다. 이 과정은 모델을 여러개의 작은 조각들로 미리 파쇄하는 과정을 거칩니다. 평소에는 정적 메시처럼 보이다가 충분한 힘을 받으면 각 조각이 분리되어 물리 시뮬레이션이 적용됩니다.
벽이나 기둥, 엄폐물, 유리, 창문 등의 파괴 요소로 활용할 수 있고 천장이 무너지거나 지형이 변하는 등 플레이어에게 시각적 피드백 및 몰입감을 제공합니다.
