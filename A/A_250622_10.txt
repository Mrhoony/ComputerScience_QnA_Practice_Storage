메모리 누수(Memory Leak)와 댕글링 포인터(Dangling Pointer): 메모리 누수와 댕글링 포인터가 발생하는 주된 원인은 무엇이며, 이들이 프로그램의 안정성과 성능에 미치는 치명적인 영향을 설명하시오. C++에서 이들을 방지하기 위한 일반적인 프로그래밍 기법(예: RAII, 스마트 포인터)을 제시하시오.
->
메모리 누수는 힙에 동적으로 할당된 메모리를 사용 후 명시적으로 해제하지 않아 해당 메모리가 프로그램에 의해 계속 점유되고 운영체제에 반환되지 못하는 현상으로 흔히 포인터가 해당 메모리 주소를 잃어버리거나 delete 호출을 잊어버렸을 때 발생합니다. 장기간 실행되는 프로그램에서 메모리 점유량이 지속적으로 증가하여 결국 시스템의 가용 메모리를 모두 소진시키고 성능 저하, 프로그램 크래시를 유발합니다. 사용자 경험을 매우 저하시키고 예상치 못한 시점에 시스템 전체에 영향을 미칠 수 있습니다.
댕글링 포인터는 이미 해제된 메모리 영역을 여전히 가리키고 있는 포인터를 의미합니다. 메모리가 해제된 후에도 포인터 변수 자체는 남아있고 이 포인터가 가리키는 주소에 다른 데이터가 할당되거나 변경될 수 있습니다. 댕글링 포인터를 사용하여 데이터를 읽거나 쓰려고 시도하면 미정의 동작이 발생합니다. 이는 프로그램 크래쉬, 데이터 손상, 보안 취약점 등 예측 불가능하고 심각한 오류로 이어질 수 있습니다.
이를 발지하기 위한 c++의 일반적인 프로그래밍 기법으로 RAII 원칙은 리소스(메모리, 파일 핸들, 뮤텍스 등)는 객체가 생성될 때 획득되고 객체가 소멸될 때 자동으로 해제되도록 설계하는 원칙으로 이를 통해 delete 호출을 잊거나 예외 발생으로 인한 자원 누수를 방지합니다. 스마트포인터는 RAII를 구현한 대표적인 예로 std::unique_ptr은 단독 소유권을 보장하여 메모리 누수와 이중 해제를 방지합니다. std::shared_ptr은 공유 소유권을 제공하며 참조 카운트가 0이 되면 자동으로 해제됩니다. std::weak_ptr와 함께 사용하여 순환 참조로 인한 누수를 방지할 수 있습니다. 이를 통해 개발자가 직접 new와 delete를 관리하는 부담을 줄이고 메모리 수명 주기를 컴파일러/런타임이 자동으로 처리하게 합니다. std::vector, std::string, std::map 등 C++ 표준 컨테이너는 내부적으로 메모리를 안전하게 관리하고 해제하므로 가능한 이를 활용하는 것이 좋습니다. 코드 작성 시 누가 특정 메모리 블록의 소유권을 가지며 언제 해제할 책임이 있는지 명확히 정의합니다.

CPU 캐시 메모리의 중요성: CPU 캐시 메모리(L1, L2, L3)의 역할은 무엇이며, 프로그램의 데이터 접근 패턴(예: 순차 접근 vs 무작위 접근)이 캐시 히트(Cache Hit)와 캐시 미스(Cache Miss)에 어떻게 영향을 미쳐 전반적인 성능을 좌우하는지 설명하시오.
->
CPU 캐시(L1, L2, L3)는 CPU와 메인 메모리 사이에 위치한 작고 매우 빠른 메모리 계층입니다. CPU가 메인 메모리에서 데이터를 가져오는 데는 상대적으로 긴 시간이 소요되므로 자주 사용되거나 사용될 가능성이 높은 데이터를 미리 캐시에 저장하여 데이터 접근 속도를 극적으로 높여 CPU의 연산 처리 속도를 최적화합니다.
캐시 히트는 CPU가 필요한 데이터가 이미 캐시 메모리에 있는 경우 CPU는 매우 빠르게 데이터를 가져와 처리할 수 있으므로 성능이 높습니다. 캐시 미스는 CPU가 필요한 데이터가 캐시 메모리에 없는 경우 CPU는 메인 메모리까지 내려가 데이터를 가져와야 하므로 상대적으로 긴 지연 시간이 발생하고 성능이 저하됩니다. 캐시 미스 시에는 필요한 데이터와 함께 인접한 메모리 블록도 캐시로 로드(공간적 지역성)됩니다.
순차 접근은 배열의 요소를 순서대로 접근하는 것과 같이 메모리 상에서 연속적인 데이터를 순차적으로 처리하는 패턴으로 공간적 지역성이 높아 캐시 히트율이 매우 높습니다. 한번의 캐시 로드로 여러 데이터를 미리 가져올 수 있기 때문에 성능이 매우 좋습니다. 무작위 접근은 연결 리스트의 노드를 순회하거나 해시 테이블에서 데이터를 찾는 것과 같이 메모리 상에서 불연속적인 데이터를 임의의 순서로 접근하는 패턴으로 이는 공간적 지역성이 낮아 캐시 미스율이 높아집니다. CPU가 매번 캐시 미스를 겪으며 메인 메모리까지 내려가야 하므로 성능이 크게 저하됩니다.
프로그램의 데이터 접근 패턴이 캐시 효율성을 직접적으로 좌우하며 이는 전반적인 성능에 결정적인 영향을 미칩니다. 캐시 친화적인 데이터 구조와 알고리즘 설계는 고성능 어플리케이션, 특히 게임에서 매우 중요합니다.

메모리 단편화(Fragmentation) 심화: 힙(Heap) 메모리에서 외부 단편화(External Fragmentation)와 내부 단편화(Internal Fragmentation)가 발생하는 원인을 각각 설명하고, 이들이 프로그램의 메모리 사용 효율성 및 새로운 메모리 할당 실패에 미치는 영향을 논하시오.
->
외부 단편화는 힙 메모리에서 잦은 할당과 해제가 불규칙한 크기의 순서로 반복될 때 발생합니다. 전체적으로 사용 가능한 빈 메모리 공간의 총량은 충분하지만 그 공간들이 여러개의 작고 불연속적인 조각들로 흩어져 있기 때문에 연속된 큰 블록의 메모리가 필요한 할당 요청을 처리할 수 없게 되는 현상입니다. 메모리 사용 효율성이 저하되고 결국 메모리가 부족하지 않지만 할당할 수 없는 상태가 되어 새로운 큰 메모리 할당 요청이 실패할 수 있습니다.
내부 단편화는 메모리 할당자가 요청된 크기보다 더 큰 고정된 크기의 블록을 할당해주거나 특정 정렬 요구사항을 충족시키기 위해 패딩을 삽입하는 경우 발생합니다. 즉 할당된 메모리 블록 내에서 실제로 사용되지 않고 낭비되는 공간이 생기는 것입니다. 할당된 메모리 블록 내부에 사용되지 않는 공간이 생기므로 전체적인 메모리 사용 효율성이 저하됩니다. 외부 단편화만큼 치명적이지 않을 수 있지만 누적되면 상당한 메모리 낭비로 이어질 수 있습니다.
두가지 유형의 단편화 모두 메모리 사용 효율성을 떨어뜨리고 할당/해제 속도를 저하시키며 궁극적으로는 메모리 부족으로 인한 프로그램의 불안정성이나 크래쉬를 유발할 수 있습니다. 특히 장시간 실행되는 게임에서는 누적된 단편화가 심각한 성능 저하로 이어질 수 있습니다.

메모리 정렬(Memory Alignment)의 필요성: 메모리 정렬이 왜 중요한지 (예: CPU의 데이터 접근 효율성, SIMD 명령어 사용, 특정 하드웨어 요구사항) 설명하고, C++에서 alignas 키워드나 컴파일러 특정 지시자를 사용하여 메모리 정렬을 명시적으로 제어하는 방법을 제시하시오.
->
CPU는 메모리에서 데이터를 읽을 때 캐시라인 단위(64바이트 등)로 데이터를 로드합니다. 데이터의 시작 주소가 캐시라인의 배수에 정렬되어 있으면 CPU는 한번의 메모리 접근으로 캐시라인 전체를 효율적으로 가져올 수 있습니다. 만약 데이터가 정렬되지 않고 캐시라인 경계를 넘어가면 CPU는 필요한 데이터를 얻기 위해 두번의 캐시라인 로드를 수행해야 하거나 복잡한 주소계산을 해야 하므로 성능 저하가 발생합니다.
SSE, AVX와 같은 SIMD 명령어 세트는 한번의 명령으로 여러 데이터를 동시에 처리하여 연산속도를 크게 높입니다. 그러나 이러한 명령어들은 대부분 특정 크기(16바이트, 32바이트 등)로 엄격하게 정렬된 메모리 접근을 요구합니다. 정렬되지 않은 메모리에 대해 SIMD 명령어를 사용하려고 하면 성능 저하, 오류 발생, 또는 크래시가 발생할 수 있습니다.
일부 하드웨어 아키텍처나 장치(GPU, DMA 컨트롤러 등)는 특정 데이터 구조나 버퍼가 메모리에 특정 방식으로 정렬되어 있어야만 올바르게 작동하거나 최적의 성능을 낼 수 있습니다.
멀티스레드 환경에서 아토믹 연산을 수행하거나 데이터 경쟁을 피하기 위해 특정 변수를 스레드로부터 안전하게 접근하려면 올바른 메모리 정렬이 보장되어야 합니다.
// 32바이트 정렬을 요구하는 구조체
struct alignas(32) MyAlignedStruct {
    int a;
    float b;
    // ...
};

// 64바이트 정렬을 요구하는 배열
alignas(64) int AlignedArray[10];

객체 풀링(Object Pooling): 객체 풀링 기법은 무엇이며, 게임 개발에서 (특히 빈번하게 생성/파괴되는 총알, 이펙트 등) 힙 할당 및 해제로 인한 성능 오버헤드와 메모리 단편화를 줄이는 데 어떻게 기여하는지 설명하시오.
->
빈번하게 생성되고 파괴되는 동일한 종류의 객체들을 미리 할당해 둔 메모리 풀에서 관리하는 기법입니다. 객체가 필요할 때 새로 생성하는 대신 풀에서 활성화하여 재사용하고 사용이 끝나면 파괴하는 대신 풀로 비활성화하여 반환합니다.
new/delete와 같은 힙 할당/해제 연산은 상대적으로 느리고 CPU 오버헤드가 큽니다. 특히 게임에서 총알, 폭발 이펙트처럼 초당 수십-수백개가 생성/파괴되는 객체들의 경우 매번 힙 연산을 수행하면 프레임 드랍이나 렉이 발생할 수 있습니다. 객체 풀링은 초기화 시점에 한번만 대량의 메모리를 할당하고 이후에는 풀 내에서 간단한 포인터 조작이나 배열 인덱스 접근만으로 객체를 활성화/비활성화하므로 런타임 할당/해제 오버헤드를 거의 제거합니다.
잦고 불규칙한 할당/해제는 시간이 지남에 따라 힙 단편화를 유발하여 메모리 사용 효율성을 떨어뜨리고 나중에는 큰 메모리 할당 요청이 실패하게 만들 수 있습니다. 객체 풀링은 모든 객체가 미리 할당된 하나의 큰 연속적인 메모리 블록 내에 존재하도록 하여 동적인 할당/해제로 인한 단편화를 원천적으로 방지합니다. 이는 메모리 관리의 예측 가능성을 높이고 안정성을 향상시킵니다.
풀 내의 객체들이 연속적인 메모리에 배치되므로 이들을 순회하거나 접근할 때 캐시 히트율이 높아져 전반적인 성능 향상에도 기여합니다.

C++ 커스텀 할당자(Custom Allocator): C++ 표준 라이브러리 컨테이너(예: std::vector, std::map)에 커스텀 할당자를 사용하는 주된 이유는 무엇이며, 어떤 상황(예: 특정 메모리 영역 사용, 고성능/저단편화 요구)에서 커스텀 할당자 구현을 고려할 수 있는지 설명하시오.
->
std::vector, std::map 등의 표준 컨테이너는 기본적으로 std::allocator를 사용하여 힙 메모리를 할당/해제합니다. 하지만 이 기본 할당자는 범용적이고 안전하게 설계되어 있어 특정 시나리오에서는 성능 병목 현상, 과도한 메모리 사용, 또는 단편화 문제를 야기할 수 있습니다.
커스텀 할당자를 사용하면 메모리 할당 및 해제 방식에 대한 세밀한 제어권을 얻어 특정 어플리케이션의 요구사항에 맞춰 메모리 관리를 최적화할 수 있습니다.
특정 메모리 영역 사용, 고성능/저단편화 요구, 메모리 디버깅/추적, 메모리 정렬 요구사항 등의 상황에서 커스텀 할당자 구현을 고려해볼 수 있습니다.
커스텀 할당자는 범용적인 해결책은 아니지만 특정 성능 병목 현상을 해결하거나 독특한 메모리 요구사항을 충족해야할 때 강력한 최적화 도구가 될 수 있습니다. 하지만 구현이 복잡하고 버그 발생 가능성이 높으므로 신중하게 고려해야 합니다.

언리얼 엔진의 가비지 컬렉션(Garbage Collection): 언리얼 엔진의 가비지 컬렉션 시스템이 어떤 방식으로 UObject 기반 메모리를 관리하는지 설명하시오. UPROPERTY(), AddReferencedObjects(), MarkAsGarbage()와 같은 메커니즘이 어떻게 작동하는지 간략히 설명하시오.
->
UE의 GC는 C++의 일반적인 메모리가 아닌 UObject 기반의 객체들의 힙 메모리를 관리합니다. 일반 C++ 클래스는 GC 대상이 아니며 개발자가 직접 관리해야 합니다.
UE의 GC는 마크 앤 스윕 기반의 참조 추적 방식을 사용합니다. 엔진은 UObject에 대한 강력한 참조를 유지하는 루트 객체들(UWorld, UGameInstance UObject*, UPROPERTY()로 선언된 멤버 변수 등)을 식별합니다. 루트 세트에서 시작하여 모든 강력한 UObject* 참조를 따라가며 도달 가능한(Reachable) 모든 UObject들을 사용중으로 표시합니다. 마킹 페이즈 후에 사용중으로 표시되지 않은 모든 UObject들을 가비지로 간주하고 힙 메모리에서 해제합니다.
GC는 레벨 로딩/언로딩 시점, 특정 시간 간격, 또는 메모리 부족 상황 등 엔진에 의해 특정 주기로 실행됩니다. 프레임 드랍을 최소화하기위해 백그라운드에서 실행되거나 게임 로딩 화면 등 비교적 안전한 시점에서 실행되도록 최적화되어 있습니다.
UPROPERTY() 매크로로 선언된 UObject* 타입의 멤버 변수는 GC 시스템에 의해 자동으로 참조 추적됩니다. 즉 이 변수가 다른 UObject를 참조하고 있다면 GC는 해당 UObject가 여전히 사용 중임을 인식하고 삭제하지 않습니다. 강력한 참조를 형성하며 해당 프로퍼티를 가진 객체가 유효하다면 참조된 UObject도 GC 대상에서 보호됩니다.
클래스에 UObject를 상속받지 않는 일반 C++ 클래스 내에 UObject* 포인터가 있거나 또는 TArray<UObject*>와 같이 컨테이너 내에 UObject* 포인터들이 들어있을때 GC 시스템이 이 참조들을 자동으로 찾아낼 수 없습니다. 이 경우 해당 클래스에 AddReferencedObjects() 함수를 오버라이드하여 수동으로 GC에게 추가적인 UObject 참조들을 알려줘야 합니다.
MarkAsGarbage()는 특정 UObject를 명시적으로 가비지 컬렉션 대상으로 표시하는 함수입니다. 이 함수가 호출되면 해당 객체는 더이상 사용되지 않는 것으로 간주되고 다음 GC 사이클에서 메모리에서 제거될 준비가 됩니다. 일반적으로 액터를 월드에서 제거할 때 Destroy() 함수를 사용하면 내부적으로 MarkAsGarbage()를 호출합니다.
UE의 GC는 UObject의 메모리 관리를 자동화하여 개발자의 부담을 줄이고 안정성을 높이지만 UObject가 아닌 일반 C++ 메모리에 대해서는 여전히 개발자가 스마트 포인터 등을 사용하여 수동으로 관리해야 합니다.

언리얼 엔진 컨테이너의 메모리 동작: TArray와 TMap (또는 TSet) 같은 언리얼 엔진의 컨테이너들이 내부적으로 메모리를 어떻게 관리하는지 (예: TArray의 용량 확장 정책, TMap의 해시 테이블 충돌 처리) 설명하고, 이들이 성능과 메모리 사용량에 미치는 영향을 논하시오.
->
UE의 컨테이너 클래스(TArray, TMap, TSet 등)는 C++ 표준 라이브러리 컨테이너와 유사하지만 UE의 특성과 성능 요구사항에 맞춰 자체적으로 구현되었으며 엔진의 메모리 관리자(FMalloc)을 사용합니다.
TArray는 C++의 std::vector와 유사한 동적 배열입니다. 요소를 추가할 때 현재 용량이 부족하면 TArray는 더 큰 메모리 블록을 힙에 할당하고 기존 요소들을 새 블록으로 복사(또는 이동)한 다음 이전 블록을 해제합니다. TArray는 일반적으로 기존 용량의 1.5배 또는 2배와 같이 점진적으로 용량을 확장합니다. 이는 std::vector가 2배 확장을 선호하는 것과 유사합니다. TArray에 요소를 추가할 때마다 재할당이 발생하는 것을 방지하여 삽입 성능을 최적화합니다. 대규모 데이터에 대해 amortized constant time(분할 상환 분석을 통한 상수 시간)의 삽입 성능을 제공합니다. 재할당 시 기존 요소 복사/이동에 비용이 들고 새로 할당된 메모리 블록이 항상 정확히 필요한 만큼이 아니므로 약간의 내부 단편화가 발생할 수 있습니다.
작은 재할당은 성능 저하를 유발하므로 TArray의 최종 크기를 미리 알 수 있다면 Reserve() 함수를 사용하여 미리 충분한 용량을 확보하는 것이 좋습니다. 적절한 확장 정책은 삽입 성능과 메모리 사용량 사이의 균형을 맞춥니다.
TMap은 키-값 쌍을 저장하는 해시 테이블 기반의 컨테이너이며 TSet은 유일한 값을 저장하는 해시 테이블 기반의 컨테이너입니다.
내부적으로 해시 함수를 사용하여 키를 메모리 배열의 인덱스로 변환합니다. 서로 다른 두 키가 동일한 해시 값을 가질때 충돌이 발생합니다. UE의 TMap은 일반적으로 개방 주소 지정 방식의 한 형태인 선형 조사법 또는 2차 조사법을 사용하여 충돌을 해결합니다. 즉 충돌이 발생하면 다음 빈 슬롯을 찾을 때까지 순차적으로 또는 특정 패턴으로 탐색합니다.
해시 함수의 성능과 충돌 빈도에 따라 TMap/TSet의 삽입, 검색, 삭제 성능이 크게 달라집니다. 좋은 해시 함수는 균일하게 요소를 분포시켜 충돌을 최소화합니다. 로드 팩터는 해시 테이블의 채워진 정도를 나타내는 값으로 로드 팩터가 너무 높으면 충돌이 자주 발생하여 성능이 저하됩니다. TMap은 로드 팩터가 특정 임계값을 초과하면 자동으로 테이블 크기를 확장하고 모든 요소를 다시 해시하여 성능을 유지합니다. 충돌 처리를 위한 추가 슬롯이나 포인터 때문에 TMap은 TArray보다 일반적으로 더 많은 메모리를 사용할 수 있습니다. TMap은 크기 확장 시에도 재할당 및 요소 재해싱 오버헤드가 발생합니다.
UE 컨테이너들은 게임 개발 환경에 최적화된 성능과 메모리 관리를 제공하기 위해 고유한 확장 정책과 충돌 처리방식을 사용합니다. 개발자는 이들의 내부 동작을 이해하고 Reserver() 같은 함수를 적절히 활용하여 성능을 더욱 최적화할 수 있습니다.

메모리 프로파일링 도구 활용: 언리얼 엔진에서 제공하는 메모리 프로파일링 도구(예: Unreal Insights의 Memory Tracker, stat memory 명령어)를 사용하여 메모리 누수, 과도한 메모리 사용량, 그리고 불필요한 메모리 할당/해제를 어떻게 진단하고 최적화할 수 있는지 설명하시오.
->
UE는 메모리 사용량을 분석하고 최적화하기 위한 강력한 내장 프로파일링 도구를 제공합니다.
Unreal Insights의 Memory Tracker는 UE의 통합 프로파일링 도구인 Unreal Insights의 핵심 기능 중 하나입니다. 모든 메모리 할당/해제 이벤트, 현재 메모리 사용량, 할당된 객체의 수, 가비지 컬렉션 활동 등을 실시간으로 상세하게 추적하고 시간화합니다.
시간에 따른 총 메모리 사용량 그래프에서 지속적인 상승 추세를 보이거나 특정 시점에 메모리 사용량이 예상대로 감소하지 않는다면 누수를 의심할 수 있습니다. Memory Tracker는 어떤 종류의 객체가 할당되어 해제되지 않고 남아있는지 구체적으로 보여줍니다. 특정 시점에 메모리 사용량이 급증하는 구간을 파악하고 해당 시점에 어떤 종류의 객체가 가장 많은 메모리를 점유하고 있는지 확인하여 최적화 대상을 식별합니다. 짧은 시간 내에 많은 수의 객체가 생성/파괴되는 패턴을 찾아내어 객체 풀링과 같은 기법을 적용하여 성능 오버헤드를 줄일 수 있는 부분을 개선합니다. 특정 프레임에서 발생하는 미세한 렉의 원인을 분석할 때 유용합니다.
stat memory 명령어는 개발 빌드에서 게임 내 콘솔(~키)을 통해 명령어를 입력하면 현재 시점의 메모리 사용량에 대한 간략한 요약 보고서를 화면에 출력합니다. 현재 사용중인 총 메모리, 가상 메모리, 물리 메모리 사용량, 각 서브 시스템별 메모리 점유량 등을 빠르게 확인할 수 있습니다. 특정 상황에서 메모리 사용량이 급증하는지 여부를 실시간으로 모니터링할 때 유용합니다. stat memory -full은 더 상세한 보고서를 stat memreport는 .csv 또는 .txt 파일로 자세한 메모리 사용량 통계를 저장하여 오프라인 분석을 가능하게 합니다.
이러한 프로파일링 도구들을 통해 개발자는 게임의 메모리 사용 패턴을 깊이 이해하고 잠재적인 메모리 누수나 비효율적인 할당을 식별하여 성능을 최적화하고 안정성을 높일 수 있습니다.

데이터 지향 설계(Data-Oriented Design)와 메모리: 데이터 지향 설계(DOD)가 메모리 접근 패턴(특히 캐시 효율성)을 최적화하여 성능을 향상시키는 데 어떻게 기여하는지 설명하고, 객체 지향 설계(OOD)와 비교하여 메모리 관리 및 성능 관점에서의 장단점을 논하시오.
->
데이터 지향 설계(DOD)는 프로그램의 성능을 최적화하기 위해 데이터의 조직화와 데이터 접근 패턴을 가장 중요하게 고려하는 프로그래밍 패러다임입니다. CPU가 데이터를 효율적으로 처리할 수 있도록 데이터가 메모리에 어떻게 배치되고 접근되는지에 중점을 둡니다. 코드보다 데이터를 우선하라, 데이터를 중심으로 코드를 조직하라는 철학을 가집니다.
데이터 지역성 극대화, DOD는 유사한 타입의 데이터나 함께 처리될 데이터들을 메모리 상에서 최대한 연속적으로 배치하도록 구조화합니다. 데이터가 연속적으로 배치되면 CPU가 한번의 캐시로드로 필요한 여러 데이터를 캐시로 가져올 수 있습니다.(공간적 지역성) 또한 알고리즘이 순차적으로 데이터를 처리하도록 설계하여 시간적 지역성도 높입니다. 이는 캐시미스를 최소화하고 캐시히트율을 극대화하여 CPU의 파이프라인 효율성을 높여 전반적인 성능을 향상시킵니다. 연속적으로 정렬된 데이터는 SSE/AVX와 같은 SIMD 명령어 세트를 사용하여 여러 데이터를 동시에 처리하는데 매우 유리하며 이는 병렬 처리 성능을 향상시킵니다.
객체 지향 설계(OOD)는 재사용성, 확장성, 모듈성, 유지보수성, 추상화, 코드 가독성 등 소프트웨어 공학적 이점이 뛰어납니다. 실제 세계의 개념을 클래스와 객체로 모델링하기 용이합니다. 객체들은 종종 힙의 여기저기에 분산되어 할당되므로 관련 데이터가 메모리 상에서 떨어져 있을 수 있습니다. 이는 캐시 미스를 유발하여 성능 저하로 이어질 수 있습니다. 다형성을 위한 가상 함수 호출은 V-Table 룩업, 분기 예측 실패 등으로 인한 미미한 런타임 오버헤드를 가집니다. 데이터와 로직이 클래스 안에 함께 캡슐화되어있어 데이터만을 효율적으로 처리하기 어렵습니다.
데이터 지향 설계는 데이터가 CPU나 가장 효율적으로 접근하도록 설계하여 캐시 히트율을 높이고 성능을 극대화합니다. 메모리 접근 패턴이 최적화되어 있으므로 성능 예측이 가능하고 안정적입니다. 데이터가 정렬되고 연속적이어서 병렬 처리 및 SIMD 명령어 활용에 유리합니다. 종종 아레나 할당자, 풀링 등 메모리 효율적인 할당 전략과 함께 사용됩니다. 하지만 데이터와 로직이 분리될 수 있어 코드 구조가 직관적이지 않거나 비즈니스 로직을 모델링하기 어려울 수 있습니다. 초기 설계 단계에서부터 메모리 레이아웃과 데이터 흐름을 기핑 고려해야 하므로 개발 복잡도가 높을 수 있습니다. 특정 데이터 구조에 강하게 의존하여 범용적인 재사용이나 확장이 어려울 수 있습니다.
게임 개발에서는 OOD와 DOD를 상호 보완적으로 활용하는 것이 일반적입니다. 고수준의 게임 시스템(게임 매니저, UI 시스템 등)은 OOD의 이점을 활용하여 유연하고 확장 가능하게 설계하고 성능이 매우 중요하고 데이터 처리량이 많은 핵심 게임플레이 로직(렌더링, 물리 시뮬레이션, AI 업데이트 등)에서는 DOD 원칙을 적용하여 메모리 접근을 최적화함으로서 최고의 성능을 끌어냅니다.