C++에서 std::recursive_mutex는 std::mutex와 어떤 차이가 있으며, 언제(예: 동일 스레드 내에서 여러 번 락을 시도하는 경우) std::recursive_mutex를 사용하는 것이 적절한지 설명하시오.
->
std::mutex는 한 스레드가 뮤텍스를 이미 잠근 상태에서 동일 스레드가 다시 잠그려고 시도하면 교착 상태에 빠지는 비재귀적 뮤텍스입니다. std::mutex를 잠근 스레드는 반드시 해당 스레드가 해제해야 합니다.
std::recursive_mutex는 한 스레드가 뮤텍스를 잠근 상태에서 동일 스레드가 여러번 다시 잠글 수 있는 재귀적 뮤텍스입니다. 뮤텍스를 잠근 횟수만큼 해제해야 완전히 풀립니다.
동일 스레드 내에서 중첩된 함수 호출 등으로 인해 동일한 뮤텍스를 여러번 잠그려는 시나리오가 발생할 수 있을 때 사용됩니다.

std::condition_variable은 무엇이며, 다중 스레드 환경에서 스레드 간의 동기화(예: 생산자-소비자 패턴)를 위해 wait()와 notify_one()/notify_all() 메서드가 어떻게 사용되는지 설명하시오.
->
std::condition_variable 다중 스레드 환경에서 특정 조건이 만족될 때까지 스레드를 대기시키거나 조건이 만족되었음을 대기중인 스레드에게 알리는데 사용되는 동기화 프리미티브입니다. 뮤텍스와 함께 사용되어 교착 상태를 방지하고 조건의 원자적 검사를 가능하게 합니다.
wait() 함수는 인자로 받은 std::unique_lock을 원자적으로 해제하고 스레드를 대기 상태로 만듭니다. 다른 스레드로부터 스레드를 깨우는 함수 notify_one() 또는 notify_all() 호출을 받거나 스퓨리어스 웨이크업(Spurious Wakeup)이 발생하면 다시 락을 획득하고 대기에서 깨어납니다.

std::unique_ptr를 사용할 때 사용자 정의 소멸자(Custom Deleter)를 지정하는 방법과 이 기능이 필요한 상황(예: 특정 리소스 핸들을 닫거나 비표준 할당 해제)을 설명하시오.
->
std::unique_ptr 템플릿의 두번째 템플릿 인자로 사용자 정의 소멸자 타입을 전달하고 생성자에 소멸자 객체(람다, 함수 포인터, 함수 객체)를 전달합니다.
리소스 핸들 닫기, 비표준 할당 해제, 오픈 소스 라이브러리 호환성 등 new/delete 가 아닌 다른 방식으로 할당되거나 관리되는 리소스의 해제가 필요할때 사용됩니다.



3D 그래픽스에서 스텐실 버퍼(Stencil Buffer)는 무엇이며, 렌더링 파이프라인에서 어떤 용도(예: 아웃라인 효과, 포털 렌더링, 그림자 볼륨)로 활용될 수 있는지 설명하시오.
->
스텐실 버퍼는 렌더링 파이프라인에서 픽셀 단위의 마스킹 작업을 수행하는데 사용되는 추가적인 버퍼입니다. 각 픽셀에 대해 8비트 정수 값을 저장하며 이 값을 통해 특정 픽셀의 렌더링 여부를 결정합니다.
아웃라인 효과: 먼저 오브젝트의 윤곽선을 그리지 않고 스텐실 버퍼에 마스크를 설정한 후 약간 확대된 모델의 윤곽선을 그리면서 스텐실 테스트를 통과한 픽셀만 렌더링하여 아웃라인 효과를 만듭니다.
포탈 렌더링: 포탈이 있는 영역에 스텐실 마스크를 설정하고 해당 마스크 영역에만 포탈 내부의 장면을 렌더링하여 마치 다른 공간으로 통하는 창문처럼 보이게 합니다.
그림자 볼륨: 오브젝트의 그림자가 드리워지는 영역을 스텐실 버퍼에 표시하여 그림자 영역만 어둡게 렌더링하는데 사용됩니다.
반사 및 굴절: 거울이나 물 같은 표면에서 반사/굴절된 장면을 렌더링할때 해당 표면 영역에만 마스크를 적용하여 효율적으로 렌더링합니다.

운영체제에서 프로세스 동기화(Process Synchronization)를 위해 사용되는 뮤텍스(Mutex)와 세마포어(Semaphore)의 주요 차이점(예: 소유 개념, 카운트 가능 여부)을 설명하시오.
->
뮤텍스는 상호 배제를 목적으로 하는 동기화 도구입니다. 한번에 하나의 스레드/프로세스만이 공유 자원(임계 영역)에 접근하도록 제어합니다. 뮤텍스는 소유 개념이 있습니다. 뮤텍스를 잠근(획득한) 스레드/프로세스만이 해당 뮤텍스를 해제(반납)할 수 있습니다. 이진 세마포어의 특수한 경우로 볼 수 있으며 카운트 기능이 없습니다.
세마포어는 공유 자원에 동시에 접근할 수 있는 스레드/프로세스의 수를 제어하는 동기화 도구입니다. 카운터 변수를 가지고 있으며 카운터가 0보다 크면 자원에 접근을 허용하고 0이 되면 대기시킵니다. 세마포어는 소유 개념이 없습니다. 세마포어를 획득한 스레드가 아닌 다른 스레드도 세마포어를 해제할 수 있습니다. 카운트가 가능한 정수 값을 가지며 여러개의 동일한 자원 인스턴스를 관리할 때 사용됩니다.

게임 개발에서 BFS(Breadth-First Search, 너비 우선 탐색) 또는 DFS(Depth-First Search, 깊이 우선 탐색) 알고리즘이 적용될 수 있는 구체적인 시나리오(예: 길 찾기, 특정 영역 탐색, 미로 생성/해결)를 2가지 제시하시오.
->
길찾기: 그리드 기반의 맵에서 NPC나 플레이어가 시작점에서 목표점까지 최단 경로를 찾는 경우 BFS는 시작점에서부터 모든 인접한 노드를 탐색하여 확장해 나가므로 가중치가 없는 그래프에서 최단 경로를 찾는데 가장 적합합니다. 각 노드 방문 시 이전 노드 정보를 저장하여 경로를 역추적할 수 있습니다.
특정 영역 탐색/연결된 컴포넌트 찾기: 퍼즐 게임에서 동일한 색상의 블록들을 모두 찾아 제거하는 경우 (BFS/DFS), RTS 게임에서 유닛을 클릭했을 때 연결된 모든 아군 유닛을 선택하는 경우(BFS/DFS), 미로 생성/해결 (DFS) 등에 사용됩니다.



언리얼 엔진 애니메이션 시스템에서 "애니메이션 몽타주(Anim Montage)"는 무엇이며, 섹션(Section)과 슬롯(Slot)은 어떤 역할을 하여 복잡한 애니메이션 시퀀스(예: 공격 콤보, 스킬 시전)를 제어하는 데 사용되는지 설명하시오.
->
애니메이션 몽타주는 여러 애니메이션 시퀀스나 블렌드 스페이스를 조합하여 하나의 복잡한 애니메이션 시퀀스를 만들고 제어하는데 사용되는 에셋입니다. 공격 콤보, 스킬 시전, 문 열기 등 고정된 복합 동작에 주로 사용됩니다.
섹션은 몽타주 내에서 특정 애니메이션 구간을 구분하는 마커입니다. 각 섹션은 이름을 가지고 있으며 다른 섹션으로 점프하거나 특정 섹션부터 재생을 시작할 수 있습니다. 공격 콤보의 각 단계를 섹션으로 정의하여 플레이어의 입력에 따라 다음 공격 섹션으로 즉시 전환되도록 제어할 수 있습니다.
슬롯은 애니메이션 몽타주가 특정 신체 부위 또는 전체 몸에 애니메이션을 오버레이하여 재생할 위치를 정의합니다. 애니메이션 블루프린트의 AnimGraph에 Slot 노드를 배치하여 해당 슬롯으로 들어오는 몽타주 애니메이션을 재생합니다.
공격 애니메이션은 상체에만 영향을 미치고 하체는 이동 애니메이션을 계속 재생해야 할 때 공격 몽타주를 UpperBody 슬롯에 할당하고 AnimGraph에 UpperBody 슬롯 노드를 추가하여 해당 부분만 몽타주를 재생하도록 합니다.

언리얼 엔진 UMG(Unreal Motion Graphics)에서 OnPaint 함수는 어떤 용도로 사용되며, 커스텀 위젯의 저수준(low-level) 그리기를 구현하거나 복잡한 UI 요소를 직접 렌더링하는 데 어떻게 활용될 수 있는지 설명하시오.
->
UMG 커스텀 위젯에서 자신만의 저수준 그리기를 구현할 때 사용되는 가상 함수입니다. Slate 렌더링 시스템의 FSlateWindowElementList에 직접 그리기 명령을 추가하여 위젯을 렌더링합니다.
복잡한 UI 요소 직접 렌더링, 성능 최적화된 그리기, 특수 효과 등에 사용되며 매 프레임 호출될 수 있으므로 성능에 민감하여 불필요한 복잡한 연산을 피해야 합니다.

언리얼 엔진 네트워크 복제(Replication)에서 RPC(Remote Procedure Call)의 Server, Client, NetMulticast 접두사가 의미하는 바와 각각의 호출 컨텍스트(어디서 호출되고 어디서 실행되는지)를 설명하시오.
->
Server 접두사는 함수가 클라이언트에서 호출되면 서버에서 실행되어야 함을 나타냅니다. 클라이언트에서 호출하고 서버에서 실행됩니다.
Client 접두사는 함수가 서버에서 호출되면 해당 클라이언트에서 실행되어야 함을 나타냅니다. 서버에서 호출하고 해당 클라이언트에서 실행됩니다.
NetMulticast 접두사는 함수가 서버에서 호출되면 서버 자신을 포함한 모든 연결된 클라이언트에서 실행되어야 함을 나타냅니다. 서버에서 호출하고 서버 자신과 모든 연결된 클라이언트에서 동시에 실행됩니다.

언리얼 엔진에서 TArray의 Shrink() 또는 ShrinkToFit() 함수는 어떤 역할을 하며, 메모리 사용량을 최적화하기 위해 언제(예: 요소 삭제 후, 초기 용량보다 훨씬 작은 수의 요소가 남았을 때) 이 함수들을 호출하는 것을 고려할 수 있는지 설명하시오.
->
TArray는 요소들을 저장할 때 실제 필요한 공간보다 더 많은 메모리를 미리 할당해둘 수 있습니다. 이는 요소 추가 시 빈번한 재할당을 피하여 성능을 높이기 위함입니다. Shrink() 또는 ShrinkToFit() 함수는 현재 TArray가 사용중인 실제 요소 수(Size)만큼만 메모리 용량을 줄여서 할당된 여분의 메모리를 운영체제에 반환하는 역할을 합니다.
요소 삭제 후, 초기 용량보다 훨씬 작은 수의 요소가 남았을 때, 메모리 제약이 심한 환경 등에서 사용되며 Shrink()는 메모리 재할당이 발생할 수 있으므로 잦은 호출은 성능 저하를 야기할 수 있습니다. 메모리 사용량 최적화가 성능 오버헤드보다 중요할 때만 사용해야 합니다.