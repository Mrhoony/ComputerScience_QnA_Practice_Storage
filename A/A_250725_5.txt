데디케이트 서버가 실행될 때 내부적으로 어떤 과정을 거쳐 실행되는지?
->
1. 초기화 (Initialization)
실행 파일 로드: 서버 실행 파일(MyGameServer.exe)이 OS에 의해 로드됩니다.
엔진 초기화: UE의 핵심 모듈들이 초기화됩니다. 이 과정에서 GEngine, GWorld 등의 전역 객체가 생성되고 엔진의 기본 설정(INI 파일)이 로드됩니다.
게임 인스턴스 생성: UGameInstance가 생성되어 게임 전반에 걸친 논리(세션 관리 등)를 담당합니다.
로딩 스크린 비활성화: 클라이언트가 없으므로 로딩 스크린 렌더링 등의 작업은 비활성화됩니다.
네트워크 스택 초기화: 서버는 클라이언트 연결을 수신하기 위해 네트워크 소켓을 열고 리스너를 설정하는 등 네트워크 스택을 초기화합니다.

2. 월드 로딩 (World Loading)
기본 맵 로드: 서버 설정에 지정된 기본 맵 또는 명령줄 인자로 전달된 맵을 로드합니다. 이 과정에서 맵의 모든 액터, 컴포넌트, 레벨 스트리밍 볼륨 등이 메모리에 로드되고 초기화됩니다.
GameMode 및 GameState 생성: 로드된 맵에 설정된 AGameMode 및 AGameState 인스턴스가 생성됩니다. AGameMode는 게임의 규칙을, AGameState는 게임의 전역 상태를 서버 권한으로 관리합니다.

3. 게임 루프 시작 (Game Loop Start)
틱(Tick) 시작: 모든 액터와 컴포넌트의 틱 함수가 활성화되어 게임 로직이 매 프레임 업데이트되기 시작합니다. (물리 계산, AI 업데이트, 게임플레이 로직 등)
클라이언트 연결 대기: 서버는 설정된 포트에서 클라이언트의 연결 요청을 계속 수신 대기합니다.

4. 세션 및 플레이어 관리 준비
UGameSession 인스턴스가 생성되어 플레이어 로그인, 세션 참가/탈퇴, 접속 허용 여부 등을 관리할 준비를 합니다.


플레이어가 데디케이트 서버에 접속하려고 할 때 어떤 흐름에 따라 진행되는지?
->
1. 클라이언트의 접속 요청
플레이어는 게임 클라이언트에서 서버 접속 버튼을 클릭하거나 IP 주소를 입력하는 등의 방법으로 접속을 시도합니다.
클라이언트는 UGameInstance::Travel() 또는 UPlayer::ClientTravel() 함수 등을 통해 서버의 주소(IP:Port)로 접속을 요청합니다.

2. 네트워크 핸드쉐이크 (Network Handshake)
클라이언트는 서버의 지정된 포트로 TCP/UDP 연결을 시도합니다.
서버는 클라이언트의 연결 요청을 수락하고 초기 핸드쉐이크 과정을 거쳐 통신 채널을 설정합니다. 이 과정에서 프로토콜 버전 확인, 초기 패킷 교환 등이 이루어집니다.

[ 네트워크 핸드쉐이크란 ]
두 통신 주체(클라/서버)가 서로 통신을 시작하기 전에 상호 간에 필요한 정보를 교환하고 통신 규칙을 설정하는 일련의 초기 과정을 의미 (UNetConnection, USocket 등)

3. 로그인 및 세션 참여
클라이언트는 서버에 로그인 요청을 보냅니다.
서버는 UGameSession을 통해 플레이어의 로그인 및 세션 참여를 처리합니다. AGameMode::Login() 함수가 호출되어 플레이어를 인증하고 접속을 허용할지 결정합니다.

4. PlayerController 및 Pawn 생성/소유
서버는 접속이 허용된 각 클라이언트에 대해 APlayerController 인스턴스를 생성하고 이를 해당 클라이언트의 APlayer 인스턴스에 할당하여 클라이언트가 게임을 제어할 수 있도록 합니다.
이후 AGameMode::PostLogin() 함수에서 해당 APlayerController에 대응하는 APawn 또는 ACharacter 인스턴스를 생성하고 APlayerController::Possess() 함수를 통해 생성된 Pawn을 소유하게 합니다. 이 Pawn은 클라이언트에도 복제됩니다.

5. 월드 상태 동기화 및 스폰
서버는 클라이언트에게 현재 맵의 상태(액터, 컴포넌트들의 초기 상태 및 위치, 네트워크 복제 변수 등)를 전송하여 동기화합니다.
클라이언트의 Pawn의 BeginPlay()가 호출되고 클라이언트 화면에 Pawn이 스폰되어 보이기 시작합니다.

6. 게임 플레이 시작
이후 서버와 클라이언트 간에 게임 플레이 상태 및 입력 동기화를 위한 지속적인 네트워크 통신이 이루어집니다.


애니메이션 스레드가 병렬 처리를 회피할 수 없는 상황은 무엇인지? 이를 최소화할 수 있는 방법은?
->
[ 병렬 처리를 회피할 수 없는 상황 ]
1. 애니메이션 데이터가 게임 스레드 데이터에 종속될 때
애니메이션 블루프린트나 애님 노티파이 로직 내에서 게임 스레드에서만 접근 가능한 데이터(AActor의 직접적인 멤버 변수, UGameInstance의 데이터, UWorld의 상태)를 읽거나 수정하려고 할 때 발생합니다.
애니메이션 스레드는 이러한 게임 스레드 데이터에 직접 접근할 수 없으므로 해당 로직은 메인 게임 스레드(또는 FAnimInstanceProxy를 통해 동기화된 안전한 방식으로)에서 처리되도록 강제됩니다. 이는 애니메이션 스레드의 병렬 실행을 막고 메인 스레드 대기를 유발합니다.

2. 렌더링 스레드와 동기화가 필요한 경우
애니메이션 결과(스켈레탈 메쉬의 최종 자세 등)는 렌더링 스레드로 전달되어야 합니다. 이 과정에서 데이터 동기화가 필요하며 특정 지점에서는 애니메이션 스레드가 렌더링 스레드의 완료를 기다리거나 렌더링 스레드가 애니메이션 스레드의 완료를 기다려야 할 수 있습니다.

[ 최소화 방안 ]
1. 애니메이션 데이터와 게임 데이터 분리 및 캐싱
애니메이션 블루프린트 내에서 필요한 게임 스레드 데이터는 별도의 데이터 전용 구조체에 복사하여 애니메이션 스레드에서 안전하게 접근할 수 있도록 합니다.
혹은 필요한 게임 데이터의 스냅샷을 PreUpdateAnimation 단계에서 미리 가져와 캐싱하여 실제 UpdateAnimation 단계에서 병렬로 활용하도록 합니다.

2. AnimInstance 내에서 게임 스레드 의존성 최소화
AnimInstance의 이벤트 그래프나 업데이트 로직에서 GetActorLocation(), GetPlayerCharacter()와 같이 게임 스레드에 직접 의존하는 함수 호출을 가능한 한 피합니다.
만약 이러한 데이터가 꼭 필요하다면 해당 데이터를 업데이트하는 로직을 Blueprint Thread Safe Update Animation 속성을 꺼서 메인 게임 스레드에서만 실행되도록 하거나 아니면 NativeUpdateAnimation()과 같이 게임 스레드에서 호출되는 함수에서만 처리하도록 합니다.

3. 애님 노티파이 최적화
애님 노티파이는 일반적으로 게임 스레드에서 처리됩니다. 따라서 애님 노티파이의 로직이 복잡하거나 빈번하게 호출될 경우 성능에 영향을 줄 수 있습니다.
간단한 이벤트 트리거 용도로만 사용하고 복잡한 로직은 해당 액터의 다른 컴포넌트나 매니저에게 델리게이트나 이벤트로 전달하여 처리하도록 위임합니다.

4. AnimInstance의 bUseMultiThreadedAnimationUpdate 설정
대부분의 경우 기본적으로 true 이지만 특정 AnimInstance가 병렬 처리에 문제가 있거나 복잡한 디버깅이 필요할 경우 일시적으로 false로 설정하여 메인 스레드에서만 틱되도록 할 수 있습니다. 그러나 이는 성능 저하로 이어집니다.

5. 캐싱 및 최적화된 노드 사용
애니메이션 블루프린트 내에서 동일한 계산을 반복하지 않도록 포즈 캐싱(Pose Caching)을 적극적으로 활용합니다.
성능에 최적화된 애님 노드를 사용하고 불필요한 노드 연결을 피합니다.


걷거나 뛰는 애니메이션 몽타주에 발자국 소리를 애님 노티파이로 추가했을 때 소리가 들리지 않는 상황은 무엇인지? 이를 해결할 수 있는 방법은?
->
[ 소리가 들리지 않는 상황 ]
1. 기본적인 설정과 에셋에 대한 확인이 필요한 경우
AudioComponent가 없거나 설정이 잘못된 경우, 사운드큐 또는 사운드웨이브가 Null이거나 잘못 지정된 경우, 볼륨이 너무 작거나 감쇠 설정 문제, Audio Listener 위치 문제, 애님 노티파이 타이밍 또는 빈도와 부적절한 사용 문제 등

2. 애니메이션 업데이트 컬링
UE는 성능 최적화를 위해 특정 조건(카메라 시야 밖, 일정 거리 이상 떨어짐, 다른 오브젝트에 가려짐 등)을 만족하는 스켈레탈 메쉬의 애니메이션 업데이트 자체를 스킵하거나 LOD를 낮춥니다.
원인: 애니메이션 업데이트가 스킵되면 해당 애니메이션 블루프린트나 몽타주 내의 애님 노티파이 이벤트 역시 발생하지 않습니다. 노티파이가 발생하지 않으니 그 안에 설정된 발자국 소리 재생 로직이 호출되지 않아 들리지 않게 됩니다. 이는 특히 플레이어 시야 밖의 적 캐릭터나 멀리 있는 NPC의 발자국 소리가 들리지 않는 주된 원인이 됩니다.

2. 렌더링 컬링
스켈레탈 메쉬가 카메라 시야 밖으로 완전히 벗어나 렌더링되지 않을 때 발생합니다.
원인: 애니메이션 업데이트는 계속될 수 있지만 사운드 재생 로직이 렌더링된 위치나 화면 상의 가시성에 의존하는 경우 (일부 비주얼 노티파이와 연동될 때) 문제가 발생할 수 있습니다.

[ 해결 방안 ]
1. 스켈레탈 메쉬 컴포넌트의 컬링 설정 조정
Mesh->SetCullDistance(0.0f) (비권장, 디버깅용): 이 함수는 렌더링 컬링 거리를 0으로 설정하여 해당 메쉬가 항상 렌더링되도록 합니다. 하지만 애니메이션 업데이트 컬링에는 영향을 주지 않으며 성능에 매우 부정적이므로 절대 게임에서는 사용해서는 안됩니다. 디버깅 시에만 일시적으로 사용해볼 수 있습니다.
Mesh->VisibilityBasedAnimTickOption: 이 속성을 조정하여 애니메이션 업데이트 컬링의 기준을 변경할 수 있습니다.
EVisibilityBasedAnimTickOption::AlwaysTickPoseAndRefreshBones: 메시가 화면에 보이지 않아도 항상 포즈를 업데이트하고 뼈대를 새로 고칩니다. 이는 애니메이션 업데이트 컬링을 효과적으로 비활성화하므로, 노티파이가 항상 발생하지만 성능 비용이 매우 큽니다. 발자국 소리처럼 필수적인 소리지만 캐릭터 수가 적은 경우에만 고려해볼 수 있습니다.
EVisibilityBasedAnimTickOption::AlwaysTickPose: 포즈만 항상 업데이트하고 뼈대 새로 고침은 가시성에 따릅니다.
EVisibilityBasedAnimTickOption::OnlyTickMontagesWhenNotRendered: 렌더링되지 않을 때 몽타주만 틱됩니다. (발자국 소리가 몽타주에 있을 때 유용할 수 있지만, 일반 애니메이션은 여전히 컬링됨)

2. 커스텀 애님 노티파이 블루프린트 활용 (차선)
사운드 재생은 Spawn Sound at Location 노드 사용: 이 노드는 AudioComponent에 의존하지 않고 지정된 위치에 독립적으로 사운드를 생성하여 재생합니다.
컬링 여부와 관계없이 소리가 나도록 설계: 커스텀 노티파이에서 Spawn Sound at Location을 사용하면 애니메이션 업데이트가 발생했다는 전제 하에 소리를 낼 수 있습니다.
거리 기반 사운드 재생 조건 추가: 만약 플레이어 시야 밖이더라도 가까이 있는 경우(카메라 뒤편에서 접근해오는 적 등) 소리가 나야 한다면 노티파이 로직 내에서 캐릭터와 플레이어 카메라 사이의 거리를 체크하여 일정 거리 이내일 때만 소리를 재생하도록 조건을 추가할 수 있습니다.

3. 애니메이션 업데이트는 컬링하되 소리/이벤트는 별도 매니저가 관리 (경험 상 권장됨)
사운드 플레이가 게임 내 요소의 한 부분을 담당하는 경우, 매우 많은 수의 캐릭터가 등장하고 성능이 중요한 경우에 고려할 수 있습니다.
모든 캐릭터의 애니메이션 업데이트를 컬링하되 발자국 소리만은 별도의 사운드 매니저 시스템이 관리하도록 설계합니다.
캐릭터가 움직일 때 애니메이션 노티파이가 직접 소리를 재생하는 대신 사운드 매니저에게 지금 이 위치에서 발자국 소리가 나야 한다는 이벤트를 보냅니다.
사운드 매니저는 이 이벤트를 받아 플레이어의 위치와 거리, 해당 이벤트 발생 위치가 실제 들려야 하는 소리 범위 내에 있는지 판단하여 소리를 재생합니다. 이렇게 하면 애니메이션 업데이트가 컬링이 발생해도 사운드 이벤트 자체는 거리 조건에 따라 독립적으로 발생할 수 있습니다.

애니메이션 컬링은 필수적인 최적화이므로 컬링 자체를 끄는 것보다는 컬링되더라도 소리만은 들려야 하는 예외 상황을 처리하는 방식으로 접근하는 것이 중요합니다.


range-for에서 크래쉬가 발생할 수 있는 상황은 무엇인지? 이를 해결할 수 있는 방법은?
->
[ 크래쉬가 발생할 수 있는 상황 ]
1. 순회 중 컨테이너 요소 추가/제거
stl 컨테이너나 UE 컨테이너를 range-for 루프로 순회하는 도중에 컨테이너의 요소를 추가하거나 제거할 때 가장 흔하게 크래쉬가 발생합니다.
이유: range-for 루프는 내부적으로 이터레이터를 사용합니다. 컨테이너의 구조가 변경(추가/제거 외에도 std::vector나 TArray의 재할당이 발생하여 메모리 주소가 변경될 때 등)되면 이터레이터가 무효화됩니다. 무효화된 이터레이터로 다음 요소에 접근하려고 하면 정의되지 않는 동작이 발생하고 이는 종종 메모리 액세스 위반으로 이어져 크래쉬를 유발합니다.

2. const 참조가 아닌 경우 대량 복사
컨테이너가 크고 요소가 복사 비용이 높은 객체인데 값 복사로 순회할 경우 각 요소가 루프마다 복사되면서 심각한 성능 저하를 일으킬 수 있습니다. 이는 직접적인 크래쉬보다는 성능 문제로 이어지지만 경우에 따라 메모리 부족이나 타임아웃 등 간접적인 크래쉬를 유발할 수 있습니다.

3. 임시 객체 순회
함수 반환 값으로 임시 컨테이너 객체가 생성되고 이를 직접 range-for로 순회하려고 할 때 임시 객체의 수명 주기가 루프의 범위를 벗어나 먼저 파괴될 수 있습니다.

[ 해결 방안 ]
1. 순회 중 컨테이너 변경 금지 또는 안전한 패턴 사용
사전 수집 후 처리: 변경해야 할 요소나 추가/삭제할 요소를 별도의 임시 컨테이너에 먼저 수집한 후 루프가 완료된 후에 일괄적으로 컨테이너를 변경합니다.
정방향 이터레이터와 수동 루프: 요소를 제거해야 하는 경우 range-for 대신 index-for 루프와 제거 후 반환되는 이터레이터를 활용하여 안전하게 순회하고 요소를 제거합니다.

2. const 참조 또는 참조 사용
MyObject& 또는 const MyObject&와 같이 참조를 사용하여 불필요한 객체 복사를 피합니다. 요소를 수정할 필요가 없다면 const 참조를 사용합니다.

3. 임시 객체 수명 주의
C++17부터는 range-for의 범위 표현식에 임시 객체가 포함되면 해당 임시 객체의 수명이 루프 전체로 연장됩니다. 이전 버전에서는 명시적으로 변수에 바인딩하는 것이 안전합니다.