C++에서 컴파일 타임 다형성(Compile-time Polymorphism)과 런타임 다형성(Runtime Polymorphism)의 차이점을 설명하고, 각각 템플릿(Templates)과 가상 함수(Virtual Functions)를 사용하여 구현되는 방식과 어떤 상황에 더 적합한지 비교하시오.
->
컴파일 타임 다형성은 컴파일러가 프로그램을 컴파일하는 시점에 호출될 함수가 결정되는 다형성입니다. 함수 오버로딩과 템플릿을 통해 구현됩니다. 템플릿은 다양한 타입에 대해 동일한 코드 구조를 재사용하며 각 타입에 맞는 코드가 컴파일 시점에 생성됩니다. 런타임 오버헤드가 없으며 컴파일 시점에 타입 안정성이 보장됩니다. 타입이 미리 알려져있고 런타임에 행동이 변경될 필요가 없는 경우 적합합니다.
런타임 다형성은 프로그램이 실행되는 런타임 시점에 객체의 실제 타입에 따라 호출될 함수가 결정되는 다형성입니다. 주로 가상함수를 통해 구현됩니다. 기본 클래스 포인터/참조를 통해 파생 클래스 객체를 조작할 때 V-Table을 통해 실제 객체의 함수가 호출됩니다. 코드의 유연성과 확장성이 뛰어나며 새로운 타입을 추가해도 기존 코드를 수정할 필요가 적습니다. 런타임에 다양한 객체 타입의 행동을 일관된 인터페이스로 처리해야 하는 경우 적합합니다.

std::any (C++17)는 무엇이며, 타입이 다른 여러 종류의 데이터를 동일한 컨테이너에 저장하거나 함수 인자로 전달해야 할 때 어떻게 사용될 수 있는지 설명하시오.
->
C++17에 도입된 타입 세이프한 컨테이너로 어떤 타입의 단일 값이라도 저장할 수 있습니다. void*와 유사하지만 std::any는 저장된 값의 타입 정보를 유지하여 안전하게 값을 추출할 수 있습니다. 타입이 다른 여러 종류의 데이터를 동일한 컨테이너에 저장하거나 함수 인자로 다양한 타입의 값을 전달해야 할 때 유용합니다.

C++에서 "Copy-and-Swap" idiom은 무엇이며, 이 관용구를 사용하여 클래스의 할당 연산자(Assignment Operator)를 구현할 때 어떤 방식으로 예외 안전성(Exception Safety)이 보장되는지 설명하시오.
->
클래스의 할당 연산자(operator=)를 구현할 때 사용되는 관용구입니다. 주로 강력한 예외 안전성을 보장하기 위해 사용됩니다. 핵심은 임시 객체를 복사하고 그 임시 객체와 현재 객체의 내용을 교환한 다음 임시 객체가 스코프를 벗어나면서 자동으로 소멸되도록 하는 것입니다.
할당할 rhs 객체의 복사본을 먼저 생성합니다. 이 과정에서 예외가 발생하더라도 원본 객체는 전혀 변경되지 않습니다. 복사가 성공적으로 완료된 후에만 *this와 임시 객체의 내부 지원을 std::swap 같은 예외 없는 함수를 사용하여 안전하게 교환합니다. 이 단계는 예외가 발생하지 않습니다. 임시 객체는 스코프를 벗어나면서 자동으로 소멸되며 이때 *this가 원래 가지고 있던 자원들이 해제됩니다. 이 과정을 통해 복사 도중 예외가 발생하더라도 원본 객체의 상태가 항상 유효하게 유지되어 강력한 예외 안전성을 보장합니다.

3D 그래픽스에서 드로우 콜(Draw Call) 배칭(Batching)이란 무엇이며, 왜 성능 최적화에 중요한지 설명하고, 스태틱(Static) 배칭과 다이내믹(Dynamic) 배칭의 기본적인 개념을 설명하시오.
->
드로우콜 배칭은 CPU가 GPU에게 렌더링 명령을 내릴 때 여러개의 개별적인 드로우콜을 하나의 큰 드로우콜로 묶어서 보내는 최적화 기법입니다. 드로우콜은 CPU 오버헤드가 매우 큰 작업입니다. 드로우콜 수를 줄이면 CPU 부담을 감소시켜 렌더링 성능을 크게 향상시킬 수 있습니다.
스태틱 배칭은 런타임에 위치나 형태가 변하지 않는 정적 오브젝트들에 대해 미리 지오메트리 데이터를 병합하여 단일 메시로 만든 후 렌더링하는 방식입니다. 가장 효과적인 드로우콜 감소 방법 중 하나로 런타임 오버헤드가 거의 없습니다.
다이나믹 배칭은 런타임에 움직이거나 변경되는 오브젝트들에 대해 매 프레임 CPU에서 지오메트리 데이터를 조합하여 동적으로 하나의 버퍼로 만든 후 렌더링하는 방식입니다. 특정 조건을 만족하는 작은 메시들에 적용됩니다. 동적인 오브젝트에도 드로우콜 최적화를 적용할 수 있지만 CPU에서 매 프레임 데이터를 복사하고 조합하는 추가적인 오버헤드가 발생할 수 있습니다.

온라인 게임에서 네트워크 지연(Latency)에 의한 상태 불일치(State Mismatch)를 해결하기 위한 "데드 레코닝(Dead Reckoning)"과 "풀 상태 동기화(Full State Synchronization)"의 개념을 설명하고, 각각의 장단점을 비교하시오.
->
온라인 게임에서 클라이언트-서버 간의 네트워크 지연은 플레이어의 입력과 실제 게임 월드 상태 간의 불일치를 야기합니다.
데드 레코닝은 클라이언트와 서버 모두가 이전 상태와 마지막으로 수신한 움직임 정보를 기반으로 미래의 움직임을 예측하는 기법입니다. 클라이언트는 자신의 입력을 즉시 적용하여 즉각적인 반응을 느끼게 하고 서버는 자신의 예측과 실제 클라이언트의 업데이트가 크게 다를 경우에만 보정 정보를 보냅니다. 네트워크 대역폭 사용량이 매우 적습니다. 대부분의 예측이 정확하면 보정 패킷만 주고받으므로 효율적입니다. 클라이언트의 즉각적인 반응성을 보장합니다. 예측이 틀릴 경우 갑작스러운 캐릭터 순간이동이 발생할 수 있습니다. 예측 모델의 정확성이 중요합니다.
풀 상태 동기화는 서버가 모든 액터의 현재 상태를 주기적으로 모든 클라이언트에게 전송하여 클라이언트가 서버의 상태에 맞춰 자신의 월드를 업데이트하는 방식입니다. 가장 높은 정확성을 보장합니다. 서버가 모든 상태의 권한을 가지므로 치트 방지에 유리합니다. 네트워크 대역폭 사용량이 매우 많습니다. 특히 액터 수가 많거나 업데이트 빈도가 높을수록 심화됩니다. 클라이언트의 반응성이 떨어질 수 있습니다.

컴퓨터 캐시 메모리 시스템에서 LRU(Least Recently Used) 알고리즘은 무엇이며, 어떤 상황에서 이 알고리즘이 효율적인 캐시 관리 전략으로 사용되는지 설명하시오.
->
캐시에서 새로운 데이터를 저장할 공간이 부족할 때 가장 오랫동안 사용되지 않은 데이터를 캐시에서 제거하는 캐시 교체 정책입니다.
데이터 접근에 강한 시간 지역성이 있을 때 효율적입니다. 즉 최근에 사용된 데이터가 가까운 미래에 다시 사용될 가능성이 높고 오랫동안 사용되지 않은 데이터는 다시 사용될 가능성이 낮다는 가정을 바탕으로 합니다. 실제 시스템에서 가장 널리 사용되는 캐시 정책 중 하나입니다.

언리얼 엔진 5(UE5)에 도입된 "머티리얼 레이어링(Material Layering)" 시스템의 기본적인 개념과 복잡한 머티리얼을 모듈화하고 재사용하는 데 어떤 이점을 제공하는지 설명하시오.
->
복잡한 머터리얼을 여러개의 독립적인 머터리얼 레이어로 분리하여 정의하고 이를 스택처럼 쌓아올려 최종 머터리얼을 구성하는 시스템입니다. 각 레이어는 자신만의 텍스처, 파라미터, 블렌딩 방식을 가질 수 있습니다.
하나의 거대한 머터리얼 대신 표면의 특성을 나타내는 작은 단위의 레이어들로 분리하여 관리할 수 있습니다. 한번 만든 머터리얼 레이어는 다양한 마스터 머터리얼이나 다른 레이어와 조합하여 재사용할 수 있으므로 에셋 제작 시간을 단축하고 일관된 비주얼을 유지할 수 있습니다. 레이어를 추가/제거/순서 변경해도 원본 레이어에 영향을 주지 않아 유연한 작업이 가능합니다. 아티스트가 쉽게 새로운 머터리얼 변형을 만들 수 있습니다. 필요한 레이어만 활성화하고 불필요한 레이어는 컴파일 단계에서 제거하여 성능에 미치는 영향을 최소화합니다.

언리얼 엔진에서 TUniquePtr, TSharedPtr와 같은 C++ 표준 스마트 포인터 대신 언리얼 엔진 자체의 스마트 포인터(TUniquePtr<UObject>, TSharedPtr<FObject>)를 사용하는 주된 이유를 설명하시오.
->
언리얼 엔진의 UObject 시스템은 독자적인 메모리 관리(GC) 및 리플렉션 시스템을 사용하기 때문입니다. C++ 표준 스마트 포인터는 이러한 엔진 내부의 매커니즘과 직접적으로 호환되지 않습니다.
UE는 자체적인 TSharedPtr을 제공합니다. 이는 UE의 다른 컨테이너나 모듈 시스템과의 통합을 고려한 것입니다. shared_ptr은 일반 C++ 객체에는 사용할 수 있지만 UObject와의 상호작용에서는 GC의 대상이 되지 않는 등의 문제가 발생합니다.
UObject는 GC에 의해 생명 주기가 관리됩니다. weak_ptr은 shared_ptr가 관리하는 객체에 대한 약한 참조를 제공하지만 UObject는 shared_ptr이 아닌 GC가 관리하므로 weak_ptr을 사용할 수 없습니다. TWeakObjectPtr은 UObject가 GC에 의해 파괴될 때 자동으로 nullptr이 되어 댕글링 포인터를 방지하는 GC 안전성을 제공합니다.
UE의 UObject를 다룰 때는 TWeakObjectPtr이나 UPROPERTY()를 사용하고 일반 C++ 객체에는 UE의 TSharedPtr, TUniquePtr을 사용하는 것이 UE의 메모리 관리 및 리플렉션 시스템과 호환성을 유지하는 안전한 방법입니다.

언리얼 엔진의 "Replication Graph(복제 그래프)"는 무엇이며, 복잡한 대규모 멀티플레이어 게임에서 액터 복제 성능을 최적화하고 네트워크 대역폭을 효율적으로 관리하는 데 어떤 이점을 제공하는지 설명하시오.
->
복잡하고 대규모 멀티플레이어 게임에서 액터들의 네트워크 복제를 보다 효율적이고 유연하게 제어하기 위해 사용되는 고급 시스템입니다. 기존에는 모든 액터를 단순히 거리 기반으로 복제 여부를 판단하는 방식이었으나 복제 그래프는 액터들을 계층 구조로 분류하고 관리하여 맞춤형 복제 로직을 적용할 수 있게 합니다.
액터들은 복제 그룹으로 묶거나 특정 구역에 따라 관리하여 불필요한 액터의 복제를 줄입니다. 클라이언트마다 다른 복제 규칙을 적용하거나 특정 상황에서만 복제를 활성화하여 네트워크 대역폭 사용량을 크게 줄입니다. 복잡한 게임 로직을 쉽게 통합하고 확장할 수 있는 프레임워크를 제공합니다. 복제 로직을 별도의 그래프 시스템으로 분리하여 게임플레이 코드의 복잡성을 줄입니다.

언리얼 엔진의 성능 프로파일링 도구인 "Unreal Insights"의 기본적인 사용 흐름과 주요 기능(예: CPU/GPU 프레임 분석, 메모리 트래킹)에 대해 간략히 설명하시오.
->
실시간 성능 분석 및 시각화 도구입니다. 게임 실행 중 발생하는 다양한 엔진 이벤트 데이터를 수집하고 이를 시각적으로 상세하게 분석할 수 있게 합니다.
게임을 실행하거나 에디터에서 데이터를 수집하고 수집된 .trace 파일을 Unreal Insight 애플리케이션을 통해 시간 흐름에 따른 다양한 성능 지표를 시각적으로 확인하고 분석합니다.
각 프레임에서 CPU와 GPU가 어떤 작업을 얼마나 수행했는지 상세한 계층 구조로 보여주어 병목지점을 파악할 수 있습니다. 스레드별 활동도 시각화됩니다. UE의 메모리 할당/해제 패턴, 현재 사용중인 메모리 양, 특정 객체/에셋의 메모리 사용량 등을 실시간으로 추적하여 메모리 누수나 과도한 메모리 사용을 진단할 수 있습니다. 네트워크 패킷 송신/수신량, 복제되는 액터 및 프로퍼티 정보 등을 분석하여 네트워크 대역폭 사용량을 최적화하는데 도움을 줍니다. 에셋이 언제 로드되고 언로드되는지 로딩 시간이 얼마나 걸리는지 분석하여 히치 현상의 원인을 찾을 수 있습니다. 모든 이벤트가 시간 순서대로 시각화되어 특정 순간에 어떤 작업들이 동시에 또는 순차적으로 발생하는지 직관적으로 이해할 수 있습니다.