RAII(Resource Acquisition Is Initialization) 패턴이 std::unique_lock 또는 std::scoped_lock과 같은 뮤텍스 가드(Mutex Guard)에 어떻게 적용되며, 이를 통해 어떤 종류의 자원 관리 문제가 해결되는지 설명하시오.
->
뮤텍스 가드는 RAII 패턴을 사용하여 뮤텍스 잠금 및 해제를 자동으로 관리합니다. 생성자에서 뮤텍스를 잠그고 소멸자에서 뮤텍스를 해제합니다. 잠금 해제를 자동화하여 데드락이나 교착 상태를 방지하고 예외의 대한 안전성을 제공합니다.

C++11에 도입된 std::move와 std::forward의 차이점을 설명하고, 각각 어떤 용도(예: rvalue 레퍼런스 강제 캐스팅, 완벽한 전달)로 사용되는지 설명하시오.
->
std::move는 인자로 받은 값을 항상 rvalue 레퍼런스로 강제 캐스팅합니다. 이동 생성자 또는 이동 대입 연산자를 호출하여 자원의 소유권을 효율적으로 이전하고자 할 때 사용됩니다.
std::forward는 템플릿 함수에서 인자의 lvalue, rvalue 속성을 그대로 유지하여 다른 함수로 완벽하게 전달할 때 사용됩니다. 유니버설 레퍼런스 (T&&)와 함께 사용되어 인자의 속성에 따라 그대로 전달됩니다. 이를 통해 불필요한 복사 없이 원래 인자의 속성을 유지하며 함수 호출을 전달할 수 있습니다.

C++에서 explicit 키워드가 단일 인자 생성자 외에 변환 연산자(Conversion Operator)에도 사용될 때 어떤 의미를 가지며, 어떤 종류의 암시적 변환을 방지하는지 설명하시오.
->
explicit 키워드가 변환 연산자에 사용되면 해당 변환 연산자를 통한 암시적 타입 변환을 방지합니다. 복사 초기화, 함수 인자 전달, 조건식 등의 암시적 변환을 방지합니다.



3D 그래픽스에서 노멀 맵(Normal Map)이 필요한 이유와 렌더링 시 어떤 방식으로 표면의 디테일을 표현하는지 설명하시오.
->
3D 모델의 폴리곤 수를 늘리지 않고도 표면의 미세한 디테일(주름, 질감, 요철 등)을 표현하기 위해 필요합니다. 이는 렌더링 성능을 저하시키지 않으면서 시각적 품질을 향상시키는 효과적인 방법입니다.
노멀 맵은 각 픽셀 또는 텍셀의 표면 법선 정보를 RGB 채널에 저장합니다. (각각 XYZ축 방향의 법선 벡터) 렌더링 시 픽셀 쉐이더에서 노멀 맵에서 읽어온 법선 벡터로 기존 표면 법선을 대체하거나 변형합니다. 이 변형된 법선 벡터를 사용하여 광원 계산을 수행하므로 빛이 표면에 닿는 방식이 미세하게 달라져 마치 실제로 디테일이 있는 것처럼 보이게 합니다.

멀티코어 환경에서 동시성 제어(Concurrency Control)를 위해 사용되는 스핀락(Spinlock)과 뮤텍스(Mutex)의 차이점을 설명하고, 각각 어떤 상황에 더 적합하며 성능상 어떤 특성을 가지는지 설명하시오.
->
스핀락은 임계 영역 진입을 시도할 때 잠금이 해제될때까지 바쁜 대기상태로 CPU를 계속 사용하며 반복적으로 잠금 상태를 확인합니다. 잠금이 짧은 시간 동안 유지될 것으로 예상될 때 적합하며 컨텍스트 스위칭 오버헤드가 없어 잠금 획득/해제 비용이 낮지만 잠금이 오래 유지될 경우 CPU 자원을 낭비하고 다른 작업에 CPU를 사용할 수 없게 되어 성능 저하를 초래할 수 있습니다.
뮤텍스는 임계 영역 진입을 시도할 때 잠금이 이미 걸려있으면 해당 스레드를 대기 상태로 전환하고 CPU를 다른 스레드에게 양보합니다. 잠금이 해제되면 운영체제의 스케줄러에 의해 해당 스레드가 다시 실행될 기회를 얻습니다. 잠금이 비교적 긴 시간 동안 유지될 경우 적합하며 CPU 자원 낭비를 줄이고 대기중인 스레드가 CPU를 다른 작업에 활용할 수 있게 하지만 컨텐스트 스위칭 오버헤드가 발생하여 잠금 획득/해제 비용이 스핀락보다 높습니다.

데이터베이스나 파일 시스템에서 B-트리(B-Tree) 또는 B+트리(B+Tree) 자료구조가 주로 사용되는 이유와 디스크 I/O 효율성 측면에서의 장점을 설명하시오.
->
데이터베이스나 파일 시스템에서 대용량 데이터를 효율적으로 저장하고 검색하기 위해 주로 사용됩니다. 이는 이들이 디스크 기반의 데이터 접근에 최적화되어 있기 때문입니다.
B-트리와 B+트리는 자식 노드를 많이 가질 수 있어(높은 차수) 트리의 높이가 낮습니다. 이는 특정 데이터를 찾기 위해 필요한 디스크 블록(페이지) 읽기 횟수(디스크 I/O)를 최소화합니다.
페이지 기반 구조로 노드(페이지)의 크기가 디스크 블록 크기와 일치하도록 설계되어 있습니다. 한번의 디스크 I/O로 하나의 노드 전체를 메모리로 가져올 수 있어 효율적입니다.
인접한 데이터 영역으로 B+트리의 경우 모든 리프 노드에 데이터가 순차적으로 연결되어 있어 범위 검색 시에도 디스크 I/O를 최소화하여 빠르게 데이터를 순회할 수 있습니다.



언리얼 엔진의 UMG(Unreal Motion Graphics)에서 다양한 화면 해상도나 DPI(Dots Per Inch)에 대응하여 UI 요소들이 올바르게 스케일링되고 배치되도록 하는 방법을 설명하시오.
->
Anchor를 이용해 UI 요소의 위치와 크기가 부모 위젯에 상대적으로 유지되도록 설정합니다. 화면 크기 변화에 따라 요소들이 비율에 맞춰 자동으로 조정됩니다.
SizeBox, ScaleBox, AspectRatio 위젯을 사용하여 크기를 강제하거나 최소/최대 크기를 지정하고 부모 위젯에 맞게 확대/축소할 수 있으며 특정 종횡비를 유지하도록 강제하여 UI 요소의 왜곡을 방지합니다.
Padding 및 Margin을 이용해 위젯 간의 간격이나 테두리를 설정하여 다양한 해상도에서 레이아웃이 깨지지 않도록 합니다.
DPI 스케일링 설정을 통해 프로젝트 설정에서 DPI 스케일링 규칙을 정의하고 고DPI 환경에서 UI 요소들이 너무 작게 보이지 않도록 적절히 확대되게 합니다.

언리얼 엔진 애니메이션 블루프린트(Animation Blueprint)의 이벤트 그래프와 애니메이션 스테이트 머신(Animation State Machine)이 서로 어떻게 상호작용하며, 실행 순서(Lifecycle)는 어떻게 되는지 간략히 설명하시오.
->
상호작용은 이벤트 그래프와 애니메이션 스테이트 머신을 통해 이루어집니다. 이벤트 그래프를 통해 주로 캐릭터의 입력, 게임 상태 변화, 노티파이 이벤트 등 게임 플레이와 관련된 로직을 처리합니다. 이 로직은 캐릭터의 속성을 업데이트하고 이 업데이트된 속성을 애니메이션 스테이트 머신으로 전달하여 어떤 애니메이션 상태로 전환할지 결정하는 데 사용됩니다. 애니메이션 스테이트 머신을 통해 캐릭터의 애니메이션 상태를 관리하고 각 상태 간의 전환 규칙을 정의합니다. 이벤트 그래프에서 전달받은 값을 기반으로 적절한 애니메이션 상태로 전환됩니다.
매 프레임마다 호출되는 애니메이션 블루프린트의 업데이트 시작 진입점을 통해 이벤트 그래프가 실행되고 내부에서 애니메이션의 업데이트가 진행된 후 애니메이션 스테이트 머신을 평가하여 블렌딩 과정을 거치며 최종 애니메이션이 출력됩니다.

언리얼 엔진 네트워크 환경에서 클라이언트가 특정 액션(예: 상호작용 가능한 오브젝트 활성화)을 수행할 때, 서버-클라이언트 간의 권한(Authority) 처리를 어떻게 구현해야 하는지 구체적인 예시를 들어 설명하시오.
->
상호작용 키 F에 대한 입력을 클라이언트에서 감지합니다. 입력이 감지되면 클라이언트에서는 해당 오브젝트와의 상호작용을 위한 함수를 서버 RPC로 호출하여 전송합니다. 서버에서는 권한을 확인하고 해당 로직을 수행한 후 서버의 상태를 클라이언트로 복제해줍니다. 복제값을 받은 클라이언트는 머신 내 상태를 반영합니다.
핵심은 클라이언트는 요청만 하고 실제 권한을 가진 서버가 유효성을 검증하고 실제 변경을 수행한 후 그 결과를 복제하여 필요한 클라이언트가 동기화받을 수 있도록 합니다.

언리얼 엔진 에디터 유틸리티 블루프린트(Editor Utility Blueprint)를 사용하여 개발 워크플로우에서 반복적이거나 복잡한 작업을 자동화할 수 있는 구체적인 예시 2가지를 제시하시오.
->
대량 에셋의 속성을 일괄 변경하고자 할 경우 필요합니다. 예를 들어 스태틱 메시를 NavMesh에 적용하기 위해 설정값을 Walkable로 변경해야 할 경우 특정 스태틱 메시 에셋의 설정값을 Walkable로 변경해주는 기능을 만들어 활용할 수 있습니다.
프로젝트 내에서 사용되지 않는 에셋이나 에셋 명명 규칙을 따르지 않는 에셋을 찾아내고자 할 경우에도 모든 에셋을 불러와서 검사를 수행하여 문제점을 확인하도록 돕는 기능을 만들 수 있습니다.
