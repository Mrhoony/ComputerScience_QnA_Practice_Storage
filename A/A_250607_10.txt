C++의 std::vector에서 capacity()와 size()의 차이점을 설명하고, reserve() 함수가 메모리 관리 및 성능에 미치는 영향을 설명하시오.
->
size()는 std::vector에 현재 저장되어 있는 실제 요소의 개수를 반환합니다.
capacity()는 std::vector가 재할당 없이 현재 할당된 메모리에 저장할 수 있는 최대 요소의 개수를 반환합니다.
reserve(n) 함수는 std::vector의 내부 저장 공간을 최소 n개의 요소를 담을 수 있도록 미리 할당합니다.
요소를 추가할 때 capacity가 부족해지면 std::vecotr는 더 큰 메모리 공간을 할당하고 기존 요소들을 복사한 후 이전 메모리를 해제하는 재할당 작업을 수행합니다. 이 재할당은 비용이 큰 작업이며 reserve()를 미리 호출하여 충분한 공간을 확보해두면 불필요한 재할당을 방지하여 요소 추가 성능을 크게 향상시킬 수 있습니다.

C++에서 클래스에 사용자 정의 new와 delete 연산자를 오버로드하는 경우가 언제이며, 어떤 목적(예: 커스텀 메모리 풀 사용)을 가지는지 설명하시오.
->
전역 또는 클래스 범위에서 operator new, new[], delete, delete[] 함수를 재정의하여 사용자 정의 메모리 할당/해제 로직을 적용할 때 오버로드합니다.
운영체제의 기본 할당자 대신 게임처럼 특정 크기의 객체가 반복적으로 생성/소멸되는 환경에서 커스텀 메모리 풀을 사용하여 메모리 단편화를 줄이고 효율성을 높일 수 있습니다. 작은 객체의 빈번한 할당/해제 시 운영체제 호출 없이 메모리 풀에서 빠르게 메모리를 얻고 반환하여 성능 오버헤드를 줄일 수 있습니다. 할당/해제 로직을 커스터마이징하여 메모리 사용량을 추적하거나 누수를 감지하는 디버깅 도구를 쉽게 통합할 수 있습니다. 그 외 특정 정렬 요구사항이 있는 메모리를 할당해야 할 때 사용합니다.

std::shared_ptr<BaseClass> base_ptr = std::make_shared<DerivedClass>();와 같이 다형적(Polymorphic) 스마트 포인터를 사용하는 예시를 들고, 이 경우 소멸자 호출 메커니즘과 관련된 주의점을 설명하시오.
->
std::shared_ptr은 내부적으로 타입 이레이저를 사용하여 make_shared를 통해 생성된 실제 객체의 타입에 대한 정보를 유지합니다. 따라서 base_ptr의 참조 카운트가 0이 되어 객체가 소멸될 때 BaseClass의 소멸자가 아닌 실제 객체인 DerivedClass의 소멸자가 호출됩니다.
std::shared_ptr을 통해 다형성을 사용할 때는 기본 클래스의 소멸자가 반드시 virtual로 선언되어야 합니다. 만약 BaseClass의 소멸자가 virtual이 아니라면 base_ptr이 가리키는 DerivedClass 객체가 소멸될 때 BaseClass의 소멸자만 호출되고 DerivedClass의 소멸자는 호출되지 않습니다. 이는 부분 소멸로 이어져 DerivedClass에서 할당된 리소스가 해제되지 않아 메모리 누수나 정의되지 않은 동작을 유발합니다.



3D 그래픽스에서 HDR(High Dynamic Range) 렌더링이란 무엇이며, LDR(Low Dynamic Range) 렌더링과 비교했을 때 어떤 시각적 이점(예: 더 넓은 명암비 표현)을 제공하는지 설명하시오.
->
LDR 렌더링은 빛의 밝기 값을 0~1 범위로 제한하여 처리합니다.
HDR 렌더링은 실제 세계의 빛의 범위처럼 0~1을 넘어서는 넓은 범위의 밝기 값을 사용하여 장면의 빛을 계산하고 렌더링하는 기술입니다. 최종적으로 디스플레이에 출력하기 전에 톤 매핑 과정을 거쳐 LDR 범위로 압축합니다. 더 넓은 명암비 표현, 더 사실적인 빛 효과, 현실적인 색상 표현의 시각적 이점을 지닙니다.

게임 네트워크 통신에서 신뢰성 있는(Reliable) UDP를 구현하기 위한 기본적인 메커니즘(예: ACK(확인 응답), 시퀀스 번호, 재전송)에 대해 설명하시오.
->
UDP는 비연결형 프로토콜로 패킷의 순서, 도착 보장, 중복 제거를 제공하지 않습니다. 그러나 게임에서는 UDP의 낮은 지연 시간 이점을 활용하면서도 중요한 데이터는 신뢰성 있게 전달되어야 합니다.
TCP의 기능을 UDP 위에 직접 구현하여 신뢰성을 확보합니다. 수신자로부터 해당 데이터가 잘 도착했다는 확인 응답(ACK), 모든 전송 패킷에 고유한 순서 번호를 부여(시퀀스 번호), ACK를 받지 못했을 시 일정 시간 후에 해당 패킷을 다시 전송(재전송), 수신자의 처리 속도에 맞춰 송신 속도를 조절(흐름 제어), 네트워크 혼잡 상황에서 전송 속도를 조절(혼잡 제어) 등의 기능을 구현합니다.

운영체제에서 페이지 폴트(Page Fault)가 발생하는 주된 원인과 이것이 시스템 성능에 미치는 영향에 대해 설명하시오.
->
운영체제에서 프로세스가 접근하려는 메모리 페이지가 현재 물리 메모리에 로드되어 있지 않고 디스크의 스왑 공간에 있을 때 발생하는 인터럽트입니다.
프로세스가 실행될 때 필요한 페이지만 메모리에 로드하고 나머지 페이지는 디스크에 두는 전략(요구 페이징), 메모리 부족, 잘못된 메모리 접근으로 인해 발생합니다.
페이지 폴트가 발생하면 CPU는 즉시 현재 작업을 중단하고 운영체제가 디스크에서 필요한 페이지를 찾아 물리 메모리로 로드하는 디스크 I/O 작업을 수행해야 합니다. 디스크 I/O는 CPU 작업에 비해 매우 느리므로 페이지 폴트가 빈번하게 발생하면 시스템 성능이 크게 저하됩니다. 페이지 폴트 발생률이 너무 높으면 CPU 시간의 대부분이 페이지 스왑에 소모되고 실제 유용한 작업은 거의 수행되지 못하는 심각한 성능 저하 현상(스래싱, Thrashing)이 발생합니다.



언리얼 엔진 애니메이션 시스템에서 "동기화 그룹(Sync Group)"은 무엇이며, 여러 캐릭터나 애니메이션이 특정 기준(예: 동일한 애니메이션 시작점)에 맞춰 동기화되도록 하는 데 어떻게 사용되는지 설명하시오.
->
여러 애니메이션 재생을 특정 기준(동기화 소스)에 맞춰 동기화하여 독립적으로 재생되던 애니메이션들이 마치 하나의 큰 애니메이션처럼 보이도록 하는 언리얼 엔진 애니메이션 시스템의 기능입니다.
여러 캐릭터가 정확히 동시에 같은 춤을 추도록 시작하는 경우 등 동일한 애니메이션 시작점 동기화와 협력 애니메이션에서 각 캐릭터의 애니메이션이 서로의 움직임과 타이밍에 맞춰 부드럽게 이어지도록 하는 경우 등 애니메이션 속도/위치 동기화가 필요한 경우에 활용됩니다.

언리얼 엔진 네트워크 환경에서 IsNetRelevantFor() 함수는 어떤 역할을 하며, 액터의 네트워크 복제(Replication) 여부 및 효율성을 결정하는 데 어떻게 사용되는지 설명하시오.
->
AActor 클래스의 가상 함수로 해당 액터가 특정 원격 클라이언트에게 네트워크 복제될 필요가 있는지 여부를 결정하는데 사용됩니다. 서버에서 주기적으로 이 함수를 호출하여 각 클라이언트에게 어떤 액터를 복제할지 판단합니다.
기본 구현은 플레이어의 시야 거리를 기반으로 액터가 너무 멀리 떨어져 있으면 복제하지 않습니다. 개발자는 이 함수를 오버라이드하여 플레이어 시야 내에 있는 경우 복제, 특정 팀원에게만 복제, 액터의 상태에 따른 복제 등 커스텀 복제 관련성 로직을 구현할 수 있습니다. 이 함수를 통해 불필요한 네트워크 트래픽을 줄이고 서버의 부하를 경감시켜 대규모 멀티플레이어 게임의 성능을 최적화할 수 있습니다.

언리얼 엔진에서 UObject의 메모리 관리 및 가비지 컬렉션(Garbage Collection)과 관련하여 MarkAsGarbage() 함수는 언제 사용되며 어떤 의미를 가지는지 설명하시오.
->
UObject 인스턴스를 명시적으로 GC 대상임을 표시할 때 사용됩니다. 일반적으로는 UObject에 대한 모든 강한 참조가 사라지면 GC가 자동으로 해당 객체를 회수합니다. 하지만 때로는 개발자가 수동으로 특정 객체를 GC 대상으로 만들고 싶을 때가 있습니다.
MarkAsGarbage()가 호출된 UObject는 펜딩킬 상태가 되어 다음 GC 사이클에 삭제됩니다. 이 함수가 호출되면 해당 객체는 더 이상 유효한 객체로 간주하지 않도록 내부적으로 처리됩니다.
동적으로 생성된 UI 위젯, 게임플레이 중 생성/파괴되는 임시 객체, CDO 초기화 문제 등의 경우에 사용됩니다.

언리얼 엔진에서 특정 UProperty의 디테일 패널(Details Panel)을 커스터마이징(Customizing)하는 일반적인 방법(예: IPropertyTypeCustomization 사용)과 이것이 필요한 주된 이유를 설명하시오.
->
UE에서 특정 UProperty의 디테일 패널을 커스터마이징하려면 주로 IPropertyTypeCustomization 인터페이스를 구현하는 클래스를 생성해야 합니다. 이 커스터마이징 클래스는 FPropertyEditorModule에 등록되어 특정 프로퍼티를 에디터에서 그릴 때 기본 위젯 대신 사용자 정의된 UI를 사용하도록 만듭니다. 개발자는 이 인터페이스의 CustomizeHeader와 CustomizeChildren 함수를 오버라이드하여 프로퍼티의 표시 방식, 드래그 앤 드롭 기능, 추가 버튼 등을 세밀하게 제어할 수 있습니다.
개발자 경험 향상, 유효성 검사 및 오류 방지, 워크플로우 통합, 엔진 기능 확장 등의 이유로 필요할 수 있습니다.