C++17에서 보장된 복사 생략(Guaranteed Copy Elision), 특히 NRVO(Named Return Value Optimization)는 무엇이며, 코드를 어떻게 최적화하는지 설명하시오.
->
보장된 복사 생략은 컴파일러가 객체의 복사 또는 이동 생성자를 호출하지 않고 직접 대상 객체에 생성하도록 보장하는 최적화 기법입니다.
NRVO는 함수 내에서 이름을 가진 지역 객체를 생성하여 반환할 때 해당 지역 객체를 반환값으로 복사/이동하지 않고 호출자의 스택 프레임에 직접 생성하도록 최적화하는 것입니다.
불필요한 객체 복사/이동 연산(생성자, 소멸자 호출 포함)을 제거하여 성능을 향상시키고 메모리 사용량을 줄입니다. 무거운 객체를 값으로 반환할 때 효과적입니다.

std::vector에서 emplace_back()과 push_back()의 차이점을 설명하고, 성능 측면에서 어떤 상황에 emplace_back()이 더 유리한지 설명하시오.
->
push_back(value)은 인자로 받은 value를 복사하여 std::vector()의 끝에 추가합니다. value가 이미 존재하는 객체일 경우 value 생성 -> push_back으로 복사/이동하는 2단계 과정이 될 수 있습니다.
emplace_back(args...)은 std::vector의 끝에 새로운 원소를 직접 생성합니다. args는 원소의 생성자에 직접 전달되어 객체가 제자리에서 생성됩니다.
emplace_back()은 불필요한 임시 객체 생성 및 복사/이동 오버헤드를 제거합니다. 비용이 많이 드는 복사/이동 생성자를 가진 복잡한 객체나 임시 객체를 구성할 필요가 없을 때 emplace_back()이 더 효율적입니다.

C++의 std::atomic 사용 시 std::memory_order_relaxed는 어떤 의미를 가지며, 언제(예: 의존성 없는 원자적 연산) 사용될 수 있는지 설명하시오.
->
std::atomic 연산에 사용되는 가장 약한 메모리 정렬입니다. 이는 오직 해당 원자적 연산 자체의 원자성만을 보장하며 다른 메모리 연산과의 순서 제약 조건은 전혀 부과하지 않습니다. 컴파일러나 CPU가 이 원자적 연산과 다른 비원자적 연산들의 순서를 자유롭게 재배열할 수 있도록 허용합니다.
다른 스레드와의 동기화나 특정 순서 보장이 전혀 필요없는 경우에 사용됩니다. 주로 카운터 증가/감소와 같이 오직 최종 값만이 중요하고 중간 과정의 순서는 중요하지 않으며 특정 값에 대한 의존성이 없는 원자적 연산에 사용될 수 있습니다. 가장 빠르지만 가장 위험한 순서입니다.



3D 그래픽스에서 알파 정렬(Alpha Sorting) 문제가 발생하는 주된 이유(예: 투명 오브젝트 렌더링 순서)와 이를 해결하기 위한 일반적인 방법(예: 투명 오브젝트 후면 렌더링)에 대해 설명하시오.
->
반투명 오브젝트는 깊이 버퍼에 깊이 값을 쓰지 않거나 쓰더라도 불완전하게 쓰기 때문에 발생합니다. 따라서 렌더링 파이프라인에서 불투명 오브젝트는 깊이 테스트로 순서가 결정되지만 반투명 오브젝트는 렌더링 순서에 따라 결과가 달라지는 순서 의존적 투명도 문제가 생깁니다. 카메라에 가까운 투명 오브젝트가 나중에 그려져서 뒤의 오브젝트를 가려야 하는데 렌더링 순서가 뒤섞이면 잘못된 결과가 나옵니다.
투명 오브젝트 후면 렌더링은 모든 불투명 오브젝트를 먼저 렌더링한 후 카메라에서 멀리 있는 투명 오브젝트부터 가까이 있는 투명 오브젝트 순서로 정렬하여 렌더링합니다. 이는 각 픽셀의 투명도가 누적되어 올바른 결과를 얻기 위함입니다.
Order Independent Transparency(OIT) 기술은 특정 순서에 의존하지 않고 투명도를 정확히 표현하는 고급 기술(A-Buffer, Depth Peeling)이지만 연산 비용이 매우 높습니다.

네트워크 게임에서 패킷 우선순위(Packet Prioritization)를 부여하는 것이 왜 중요하며, 어떤 종류의 데이터(예: 캐릭터 이동, 스킬 사용, 채팅 메시지)에 높은 우선순위를 부여할 수 있는지 설명하시오.
->
네트워크 대역폭은 한정되어 있고 모든 패킷이 동일하게 중요하지 않기 때문입니다. 중요한 데이터를 더 빠르게 전송하고 덜 중요한 데이터는 지연시키거나 버려서 제한된 대역폭 내에서 게임의 핵심적인 반응성과 플레이 경험을 유지하기 위해 중요합니다. 특히 네트워크 지연이나 혼잡 상황에서 게임의 핵심 기능이 정상적으로 작동하도록 보장합니다.
캐릭터 이동 및 위치 업데이트, 스킬 사용 및 공격 판정, 생명력/자원 업데이트, 주요 게임 이벤트 트리거 등이 높은 우선순위 데이터로 분류됩니다.
채팅 메세지, 게임 통계 업데이트, 월드 오브젝트의 환경 변화 등이 낮은 우선순위 데이터로 분류됩니다.

컴퓨터 성능 분석 시 "캐시 미스(Cache Miss)"의 주요 유형(예: Compulsory Miss, Capacity Miss, Conflict Miss)을 설명하고, 각각이 발생하는 원인을 간략히 설명하시오.
->
CPU가 필요한 데이터를 캐시에서 찾지 못하고 더 느린 메모리 계층에서 가져와야 할때 발생하는 현상입니다.
Compulsory Miss(Cold Miss)는 캐시가 비어있거나 해당 데이터가 처음으로 접근될 때 발생합니다. 이전에 캐시에 한번도 로드된 적이 없기 때문에 무조건 발생합니다.
Capacity Miss는 캐시가 데이터를 저장하기에 충분히 크지 않아서 이전에 캐시되었던 데이터가 다른 데이터로 교체되어 쫓겨난 후 다시 해당 데이터에 접근할 때 발생합니다. 캐시의 용량 부족이 원인입니다.
Conflict Miss는 캐시에 충분한 공간이 있음에도 불구하고 여러 데이터가 캐시와 동일한 위치(세트)에 매핑되어 서로를 덮어쓸 때 발생합니다. 즉 캐시의 매핑 정책으로 인해 발생하는 충돌입니다.



언리얼 엔진 5(UE5)에 도입된 Nanite(나나이트)와 Lumen(루멘)의 기본적인 개념과 각각이 렌더링 파이프라인(특히 지오메트리 처리 및 전역 조명)에서 어떤 혁신을 가져왔는지 간략히 설명하시오.
->
나나이트는 가상화된 마이크로폴리곤 지오메트리 시스템입니다. 수억개 또는 수십억개의 폴리곤으로 이루어진 매우 복잡한 고해상도 모델을 실시간으로 효율적으로 렌더링할 수 있게 합니다. 고품질 에셋을 사용하면서도 지오메트리 처리를 고민할 필요가 없습니다.
루멘은 완전히 동적인 글로벌 일루미네이션 및 리플렉션 시스템입니다. 전역 조명을 완전히 실시간으로 처리하며 아티스트 워크플로우를 향상시켰습니다.

언리얼 엔진 UMG(Unreal Motion Graphics)에서 C++ 커스텀 위젯을 생성할 때, NativeConstruct()와 NativeTick() 함수는 각각 위젯의 어떤 생명주기 단계에 호출되며 어떤 용도로 사용되는지 설명하시오.
->
NativeConstruct()는 위젯이 생성되고 초기화될 때 한번 호출됩니다. 블루프린트의 Construct와 유사하지만 코드레벨에서 호출됩니다.
NativeTick()은 매 프레임마다 호출됩니다. 블루프린트의 Tick과 유사합니다. 프레임마다 지속적으로 업데이트 되어야하는 로직에 사용됩니다.

언리얼 엔진 애니메이션 블루프린트(Animation Blueprint)의 AnimGraph에서 "블렌드 노드(Blend Node, 예: Blend Poses by Bool, Blend Poses by Enum)"는 무엇이며, 여러 애니메이션을 자연스럽게 전환하는 데 어떻게 사용되는지 설명하시오.
->
두개 이상의 애니메이션 포즈를 입력으로 받아 특정 조건이나 값에 따라 서로 자연스럽게 혼합하여 하나의 출력 포즈를 생성하는 노드입니다. 상반신과 하반신의 애니메이션을 다르게 적용할 때 사용될 수 있습니다.

언리얼 엔진 네트워크에서 클라이언트 또는 서버의 네트워크 대역폭 사용량을 제어하기 위한 "네트워크 스로틀링(Network Throttling)" 기법은 무엇이며, 어떻게 구현될 수 있는지 설명하시오.
->
네트워크 통신에서 클라이언트 또는 서버가 초당 보낼 수 있는 데이터의 양(대역폭)을 의도적으로 제한하는 기법입니다. 네트워크 혼잡을 줄이고 특정 연결이 과도하게 대역폭을 소비하는 것을 방지하여 안정적인 게임 경험을 유지하는데 사용됩니다.
EngineConfig에서 NetServerMaxtickRate, NetClientMaxTickRate 등의 값을 조정하여 네트워크 업데이트 빈도를 제한할 수 있습니다. UNetConnection 클래스의 SetBandwidthLimit()와 같은 함수를 사용하여 특정 연결에 대한 최대 대역폭을 설정할 수 있습니다.
해당 기법을 통해 느린 연결을 가진 사용자도 최소한의 게임 플레이 경험을 할 수 있도록 보장하고 서버 과부하를 방지하여 전체적인 네트워크 안정성을 높입니다.
