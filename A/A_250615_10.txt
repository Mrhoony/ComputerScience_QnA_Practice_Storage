객체 지향 프로그래밍(OOP)의 네 가지 핵심 기둥(Pillars)은 무엇인지 각각의 개념을 간략하게 설명하시오.
->
캡슐화: 데이터(속성)와 데이터를 다루는 함수(메소드)를 하나의 단위(객체)로 묶고 외부에서는 객체 내부의 구현을 직접 볼 수 없도록 숨기는 원리입니다. 데이터는 보호되고 외부에서는 정의된 인터페이스를 통해서만 접근할 수 있습니다.
상속: 기반 클래스의 속성과 메소드를 파생 클래스가 물려받아 재사용하거나 확장하는 매커니즘입니다. 코드 재사용성을 높이고 계측적인 관계를 모델링하는데 사용됩니다.
다형성: 많은 형태를 의미하며 동일한 인터페이스나 함수 호출이 객체의 타입에 따라 다른 동작을 하도록 하는 능력입니다. 이를 통해 유연하고 확장 가능한 코드를 작성할 수 있습니다.
추상화: 복잡한 시스템의 세부 사항을 숨기고 사용자가 필요로하는 가장 본질적이고 중요한 정보만을 드러내는 과정입니다. 문제의 핵심을 파악하고 불필요한 복잡성을 제거하여 시스템을 단순화합니다.

**캡슐화(Encapsulation)**란 무엇이며, 객체 지향 설계에서 캡슐화가 코드의 유지보수성, 안정성 및 재사용성을 어떻게 향상시키는지 설명하시오. C++에서 캡슐화를 구현하는 주요 방법(예: 접근 제어자)을 제시하시오.
->
캡슐화는 데이터와 해당 데이터를 조작하는 메소드를 하나의 단위(클래스/객체)로 묶고 객체의 내부 구현 세부 사항을 외부에 숨기는 객체 지향 원칙입니다. 외부에서 객체의 공개된 인터페이스(Public API)를 통해서만 객체와 상호작용할 수 있습니다.
내부 구현이 변경되어도 외부 인터페이스가 그대로 유지된다면 해당 객체를 사용하는 외부 코드를 수정할 필요가 없습니다. 이는 코드 변경의 파급 효과를 줄여 유지보수를 용이하게 합니다. 데이터가 외부로부터 직접적인 접근 및 오염되는 것을 방지하여 객체의 상태를 일관되고 유효하게 유지할 수 있습니다. 이는 시스템의 안정성을 높입니다. 잘 캡슐화된 객체는 특정 컨텍스트에 덜 종속되므로 다른 프로젝트나 시스템에서도 독립적으로 재사용하기 용이합니다.
private, protected, public 접근지정자 키워드를 사용하여 클래스 멤버의 접근 수준을 제어합니다.
private: 동일 클래스 내에서만 접근 가능
protected: 동일 클래스 및 파생 클래스 내에서 접근 가능
public: 모든 곳에서 접근 가능
Getter/Setter 메소드: private 데이터 멤버에 직접 접근하는 대신 public getter 및 setter 메소드를 제공하여 데이터 접근 및 변경을 제어하고 유효성 검사 로직을 추가할 수 있습니다.

**상속(Inheritance)**과 **합성(Composition)**은 객체 간의 관계를 모델링하는 두 가지 주요 방법입니다. "상속보다는 합성을 선호하라(Prefer composition over inheritance)"는 원칙의 의미를 설명하고, 각각 어떤 상황에 더 적합한지 장단점을 비교하시오.
->
상속보다는 합성을 선호하라는 원칙은 객체 간의 관계를 모델링할때 is-a(상속)관계가 아닌 has-a(합성)관계를 우선적으로 고려하라는 의미입니다. 즉 A는 B이다라는 명확한 계층적 관계가 아닐 경우 A는 B를 가지고 있다는 방식으로 기능을 재사용하고 확장하는 것이 더 유연하고 견고한 설계를 유도한다는 것입니다. 상속은 강력한 결합을 만들고 유연성을 저해할 수 있는 반면 합성은 느슨한 결합을 통해 더 나은 모듈성과 재사용성을 제공하기 때문입니다.
상속 - is-a 관계는 부모 클래스의 구현을 자식 클래스가 물려받아 재사용하고 확장합니다.
공통 기능을 부모 클래스에 정의하여 자식 클래스에서 중복 코드를 줄일 수 있습니다. 부모 클래스 포인터/참조로 자식 객체를 다룰 수 있어 다형성을 구현하기 용이합니다.
부모 클래스와 자식 클래스 사이에 강한 의존성이 형성되어 부모 클래스 변경 시 자식 클래스에 영향을 미칠 수 있습니다. 런타임에 부모 클래스의 구현을 변경하거나 새로운 기능을 추가하기 어렵습니다. 다중 상속의 복잡성 문제도 있습니다. 한번 정의된 계층은 변경하기 어려워 미래의 요구사항 변화에 대응하기 어렵습니다.
클래스 간에 명확한 계층적 is-a관계가 존재하며 부모 클래스의 모든 기능이 자식 클래스에 자연스럽게 계승되어야 할 때 적합합니다.
합성 - has-a 관계는 클래스가 다른 클래스의 객체를 멤버 변수로 포함하여 해당 객체의 기능을 사용하는 방식입니다.
객체 간의 의존성이 낮아져 한 객체의 변경이 다른 객체에 미치는 영향이 적습니다. 런타임에 포함된 객체를 변경하거나 다른 구현을 가진 객체로 교체할 수 있어 유연성이 높습니다. 포함되는 객체를 독립적으로 설계하고 여러 클래스에 재사용하기 용이합니다.
포함된 객체의 기능을 외부로 노출하려면 해당 기능을 호출하는 별도의 위임 메소드를 작성해야 할 수 있습니다. 매우 작은 객체를 많이 포함할 경우 메모리 오버헤드가 발생할 수 있습니다.
클래스가 특정 기능을 가지고 있는(has-a) 관계일 때 또는 특정 기능을 유연하게 변경하거나 교체해야할 때 적합합니다.

**다형성(Polymorphism)**은 객체 지향의 중요한 특징입니다. C++에서 런타임 다형성(예: 가상 함수) 외에 컴파일 타임 다형성(예: 템플릿, 함수 오버로딩)은 어떻게 구현되는지 설명하고, 이들의 차이점을 설명하시오.
->
다형성은 하나의 인터페이스나 함수 호출이 객체의 타입에 따라 다른 동작을 하도록 하는 객체 지향의 중요한 특징입니다.
런타임 다형성은 주로 가상함수와 포인터/참조를 통한 기반 클래스 접근을 통해 구현됩니다. 함수 호출이 프로그램 실행 시점에 객체의 실제 타입에 따라 결정됩니다. 가상함수 테이블을 사용하여 호출할 메소드를 찾습니다. 가상함수 테이블 조회 등의 약간의 런타임 오버헤드가 있습니다. 상속 계층 내에서 다양한 파생 클래스를 동일한 기반 클래스 타입으로 다룰 수 있어 유연성이 높습니다. 새로운 파생 클래스가 추가되어도 기존 코드를 수정할 필요가 없습니다.
컴파일 타임 다형성은 주로 템플릿과 함수 오버로딩을 통해 구현됩니다. 함수 호출이 프로그램 컴파일 시점에 결정됩니다. 컴파일러가 인자 타입에 따라 적절한 함수를 선택하거나(오버로딩) 템플릿 인스턴스화를 통해 코드를 생성합니다. 런타임 오버헤드가 없으므로 런타임 다형성보다 빠릅니다. 컴파일 시점에 타입이 결정되므로 타입 불일치 오류를 쉽게 감지할 수 있습니다. 템플릿의 경우 각 타입별로 코드를 생성하므로 코드 크기가 커질 수 있습니다.
런타임 다형성은 동적 바인딩, 컴파일 타임 다형성은 정적 바인딩입니다. 런타임 다형성은 약간의 런타임 오버헤드가 있지만 컴파일 타임 다형성은 없습니다. 런타임 다형성은 실행 중 타입 변경에 유연하지만 컴파일 타입 다형성은 컴파일 전 타입이 고정됩니다. 런타임 다형성은 주로 상속 관계의 클래스에 컴파일 타임 다형성은 모든 타입에 적용될 수 있습니다.

**추상화(Abstraction)**란 무엇이며, C++에서 추상 클래스(Abstract Class)와 순수 추상 클래스(Pure Abstract Class, 즉 인터페이스 역할)를 통해 어떻게 추상화를 달성할 수 있는지 설명하시오. 둘의 주요 차이점은 무엇인가요?
->
추상화는 복잡한 시스템의 세부 구현을 숨기고 사용자가 필요로 하는 가장 중요하고 본질적인 기능이나 개념만을 드러내는 과정입니다. 문제의 핵심을 파악하고 불필요한 복잡성을 제거하여 시스템을 단순화하고 모델링하는데 사용됩니다.
추상 클래스는 하나 이상의 순수 가상함수를 포함하는 클래스입니다. 순수 가상함수는 virtual void func() = 0;과 같이 선언되며 파생 클래스에서 반드시 구현(오버라이드)되어야 합니다. 추상 클래스 자체는 객체를 직접 생성할 수 없습니다. 오직 파생 클래스만이 추상 클래스의 모든 순수 가상함수를 구현해야만 객체로 생성될 수 있습니다. 파생 클래스들이 공통적으로 가져야 할 인터페이스를 정의하고 동시에 일부 공통적인 구현도 포함할 수 있도록 하여 추상화를 달성합니다.
순수 추상 클래스는 모든 멤버 함수가 순수 가상함수로만 구성되어 있고 데이터 멤버나 일반 멤버 함수가 없는 추상 클래스입니다. C++에서는 별도의 interface 키워드가 없으므로 이러한 형태의 추상 클래스가 인터페이스 역할을 합니다. 추상 클래스와 마찬가지로 직접 인스턴스화하여 객체로 사용할 수 없습니다. 구현이 전혀 없는 계약만을 정의하여 이를 구현하는 모든 파생 클래스들이 특정 인터페이스를 준수하도록 강제합니다.
구현에 있어서 추상 클래스는 순수 가상함수 외에 일반 멤버 함수와 데이터 멤버를 포함하여 일부 구현을 제공할 수 있습니다. 순수 추상 클래스는 오직 순수 가상함수만 포함하며 어떤 구현도 제공하지 않습니다. 모든 것이 추상적입니다.
목적에 있어서 추상 클래스는 공통적인 행동과 상태를 가진 계층 구조의 기반 클래스로 사용되어 파생 클래스들이 공유하는 부분적인 구현을 제공합니다. 순수 추상 클래스는 특정 행동의 명세만을 정의하여 서로 다른 계층 구조에 속한 클래스들이 동일한 기능을 제공하도록 강제하고 is-a관계보다는 can-do-that관계를 모델링합니다.

SOLID 원칙은 객체 지향 설계의 핵심 원칙입니다. 이 중 세 가지 이상의 원칙(예: 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존성 역전 원칙)을 선택하여 간략히 설명하고, 이들이 유연하고 확장 가능한 시스템을 만드는 데 어떻게 기여하는지 설명하시오.
->
SOLID 원칙은 로버트 마틴이 제시한 객체 지향 설계의 5가지 핵심 원칙으로 유연하고 유지보수하기 쉬운 소프트웨어 시스템을 구축하는데 지침을 제공합니다.
단일 책임 원칙(SRP, Single Responsibility Principle)은 클래스는 오직 하나의 변경 이유만 가져야 한다로 클래스는 단 하나의 책임만 가져야하며 그 책임은 완전히 캡슐화되어야 합니다. 한 클래스가 여러 책임을 가지면 한 책임의 변경이 다른 책임에 영향을 미쳐 예상치 못한 부작용을 일으킬 수 있습니다. SRP를 지키면 각 클래스가 독립적으로 변경될 수 있어 응집도가 높아지고 결합도가 낮아져 시스템의 유지보수성과 재사용성이 향상됩니다.
개방-폐쇄 원칙(OCP, Open Closed Principle)은 소프트웨어 개체는 확장에는 열려있어야 하지만 변경에는 닫혀있어야 한다로 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있어야 합니다. 주로 상속, 다형성, 인터페이스, 전략 패턴 등을 사용하여 구현됩니다. 새로운 요구사항이 발생했을 때 기존 코드를 건드리지 않고 새로운 클래스를 추가하거나 기존 클래스를 확장함으로서 기능을 추가할 수 있습니다. 이는 시스템의 유연성과 확장성을 극대화하고 변경으로 인한 오류 발생 위험을 줄입니다.
리스코프 치환 원칙(LSP, Liskov Substitution Principle)은 서브타임은 언제나 슈퍼타입으로 대체될 수 있어야 한다로 파생 클래스의 객체는 기반 클래스의 객체를 사용하는 코드에서 아무 문제 없이 사용될 수 있어야 합니다. 다형성의 올바른 사용을 보장합니다. 이 원칙을 지키면 상속 관계가 단순히 코드 재사용이 아닌 의미론적인 is-a관계를 올바르게 모델링했음을 의미합니다. 이는 시스템의 견고성과 예측 가능성을 높여 예기치 않은 동작이나 버그 발생을 줄입니다.
인터페이스 분리 원칙(ISP, Interface Segregation Principle)은 클라이언트는 자신이 사용하지 않는 인터페이스에 의존해서는 안된다로 거대한 인터페이스 하나보다는 클라이언트별로 특화된 작고 여러개의 인터페이스를 사용하는 것이 좋습니다. 특정 인터페이스를 구현하는 클래스가 불필요한 메소드를 강제로 구현하지 않도록 하여 클래스의 책임을 명확히 하고 응집도를 높입니다. 이는 시스템의 결합도를 낮추고 유연성을 향상시킵니다.
의존성 역전 원칙(DIP, Dependency Inversion Principle)은 고수준 모듈은 저수준 모듈에 의존해서는 안된다. 이들 모두 추상화에 의존해야 한다. 추상화는 세부 사항에 의존해서는 안된다. 세부 사항이 추상화에 의존해야 한다는 의미로 직접적인 구현체에 의존하는 대신 인터페이스에 의존하도록 하여 시스템의 유연성과 테스트 용이성을 극대화합니다. 이는 결합도를 낮추고 코드 재사용성을 높여 변경에 강한 시스템을 만듭니다.

객체 지향 설계에서 **결합도(Coupling)**와 **응집도(Cohesion)**는 무엇이며, 좋은 설계가 높은 응집도와 낮은 결합도를 지향해야 하는 이유를 설명하시오.
->
결합도는 모듈 간의 의존성 정도를 나타냅니다. 한 모듈이 다른 모듈의 내부 구현이나 변경에 얼마나 밀접하게 연결되어 있는지 보여줍니다. 낮은 결합도를 지향하는 것이 좋은 설계로 모듈들이 서로 독립적일수록 한 모듈의 변경이 다른 모듈에 미치는 영향이 적어 유지보수와 재사용이 용이합니다.
응집도는 모듈 내부의 요소들이 얼마나 밀접하게 관련되어 있는지를 나타냅니다. 즉 한 모듈 내의 기능들이 얼마나 하나의 목적을 위해 잘 묶여 있는지를 의미합니다. 높은 응집도를 지향하는 것이 좋은 설계로 한 모듈이 단일하고 명확한 책임을 가질수록 이해하기 쉽고 테스트하기 용이하며 재사용성이 높아집니다.
모듈 간 결합도가 낮고 각 모듈의 응집도가 높으면 특정 기능을 변경할 때 해당 모듈 내부만 수정하면 되고 다른 모듈에 미치는 영향이 최소화됩니다. 이는 버그 발생 위험을 줄이고 유지보수 비용을 절감합니다. 독립적이고 명확한 책임을 가진 모듈은 다른 프로젝트나 시스템에서 쉽게 가져다 재사용할 수 있습니다. 새로운 기능을 추가할 때 기존 모듈에 영향을 주지 않고 새로운 모듈을 추가하거나 기존 모듈을 확장하기 용이합니다.

객체 지향 패러다임을 사용하여 대규모 소프트웨어(예: 게임 엔진)를 개발할 때 얻을 수 있는 주요 이점(예: 모듈성, 재사용성, 확장성)은 무엇이며, 반대로 잠재적인 단점(예: 성능 오버헤드, 복잡성)은 무엇이 있을 수 있는지 설명하시오.
->
주요 이점은 다음과 같습니다.
모듈성: 시스템을 독립적인 객체 단위로 분할하여 관리할 수 있습니다. 각 객체는 고유한 책임과 인터페이스를 가지므로 대규모 시스템의 복잡성을 관리하고 개발 팀원 간의 협업을 용이하게 합니다.
재사용성: 이미 개발된 클래스와 객체를 다른 부분이나 다른 프로젝트에서 재사용할 수 있습니다. 이는 개발 시간과 비용을 절감합니다.
확장성: 기존 코드를 수정하지 않고도 새로운 기능을 추가하거나 시스템을 확장하기 용이합니다.
유지보수성: 캡슐화와 낮은 결합도를 통해 변경으로 인한 파급 효과를 줄이고 문제 발생 시 해당 객체만 수정하면 되므로 유지보수가 용이합니다.
생산성 향상: 잘 정의된 객체는 개발자가 특정 문제 영역에 집중할 수 있게 하여 개발 생산성을 높입니다.
잠재적인 단점은 다음과 같습니다.
성능 오버헤드: 런타임 다형성 사용 시 가상함수 테이블 조회 비용, 동적 메모리 할당/해제 비용 등으로 인해 절차 지향 방식보다 약간의 성능 오버헤드가 발생할 수 있습니다.
복잡성: 너무 많은 클래스와 복잡한 상속 계층, 관계는 오히려 시스템을 이해하고 디버깅하기 어렵게 만들 수 있습니다. 과도한 추상화는 불필요한 복잡성을 초래할 수 있습니다.
학습 곡선: 객체 지향의 개념과 원칙(SOLID, 디자인 패턴 등)을 제대로 이해하고 적용하는 데 시간이 필요하며 초보자에게는 어렵게 느껴질 수 있습니다.
메모리 사용량: 각 객체는 추가적인 메타데이터(가상 테이블 포인터 등)를 가질 수 있으며 작은 객체들이 많아지면 메모리 단편화 문제나 캐시 미스 발생 가능성이 높아질 수 있습니다.

C++에서 **추상 클래스(Abstract Class)**와 인터페이스(Interface) 역할을 하는 순수 추상 클래스를 설계할 때의 주요 고려 사항과 각각의 전형적인 사용 시나리오를 설명하시오.
->
추상 클래스는 순수 가상함수 외에 일반 멤버 함수와 데이터 멤버를 가질 수 있으므로 파생 클래스들이 공유하는 공통적인 행동이나 상태를 미리 정의할 것인지 고려해야 합니다. 생성자는 가질 수 있지만 일반적으로 외부에서 직접 객체를 생성할 수 없으므로 protected 생성자를 사용하여 파생 클래스에서만 호출되도록 할 수 있습니다. 소멸자는 반드시 virtual로 선언하여 파생 클래스 객체 소멸 시 올바른 소멸자 체인이 호출되도록 해야 합니다. is-a관계를 명확히 모델링하며 너무 깊은 상속 계층은 복잡성을 증가시키므로 피해야합니다.
추상 클래스는 템플릿 메소드 패턴으로 알고리즘의 골격을 추상 클래스에 정의하고 구체적인 단계는 순수 가상함수로 파생 클래스에 위임할 때 사용합니다.
인터페이스 역할을 하는 순수 추상 클래스 설계시 모든 함수를 순수 가상함수로 선언하고 소멸자는 반드시 virtual 키워드를 선언하며 모든 멤버 함수는 일반적으로 public으로 접근지정합니다.
순수 추상 클래스는 플러그인/확장성, 콜백 매커니즘, 다형적 행동을 강제하는 경우에 사용됩니다.

언리얼 엔진의 액터(Actor)-컴포넌트(Component) 모델에서 객체 지향의 주요 원리(예: 합성, 다형성)가 어떻게 적용되어 게임 로직을 구성하고 확장하는 데 활용되는지 구체적인 예시와 함께 설명하시오.
->
액터-컴포넌트 모델은 UE에서 게임 세계의 모든 오브젝트는 AActor 클래스의 인스턴스이며 이 AActor는 하나 이상의 UActorComponent를 가질 수 있는 구조입니다. AActor는 게임 세계에 존재하고 이동할 수 있는 기본 단위이며 UActorComponent는 액터에 특정 기능과 행동을 추가하는 모듈화된 블록입니다.
객체 지향의 원리가 적용되어 있으며 합성의 적용으로 액터는 컴포넌트를 포함(has-a)하여 기능을 확장합니다. 예를 들어 APlayerCharacter 액터는 USkeletalMeshComponent, UCharacterMovementComponent, UCameraComponent, UInputComponent 등 다양한 컴포넌트를 합성하여 하나의 플레이어 캐릭터로서의 완전한 기능을 수행합니다. 상속 계층의 제약 없이 액터에 필요한 기능을 유연하게 추가하고 제거할 수 있습니다.
다형성의 적용으로 모든 컴포넌트는 UActorComponent라는 공통된 기반 클래스를 가집니다. 따라서 엔진은 다양한 종류의 컴포넌트들을 UActorComponent* 포인터로 일관되게 처리할 수 있습니다. 예를 들어 액터는 자신의 모든 컴포넌트들을 순회하며 TickComponent() 함수를 호출하는데 이때 각 컴포넌트의 실제 타입에 맞는 TickComponent() 구현이 실행됩니다. 엔진 코드가 특정 컴포넌트의 타입에 얽매이지 않고 일반적인 방식으로 컴포넌트를 관리할 수 있게 합니다. 개발자는 새로운 유형의 컴포넌트를 추가해도 기존 엔진의 컴포넌트 처리 로직을 수정할 필요 없이 쉽게 확장할 수 있습니다.