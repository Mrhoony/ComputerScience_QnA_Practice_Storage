C++17에 도입된 std::string_view는 무엇이며, 문자열 데이터를 참조할 때 const std::string&를 사용하는 것보다 어떤 성능상 이점(예: 복사 방지)을 가지는지 설명하시오.
->
std::string_view는 문자열 데이터의 뷰를 제공하는 비소유 타입입니다. 문자열의 시작 주소와 길이를 저장하며 원본 데이터의 복사본을 만들지않고 참조합니다.
const std::string&도 복사를 피하지만 std::string 객체 자체가 생성/소멸되어야 할 경우 오버헤드가 있습니다. std::string_view는 std::string으로부터 생성될 때 데이터의 복사나 메모리 할당 없이 O(1) 시간에 뷰만 생성합니다. 다양한 문자열 타입에 대해 일관된 인터페이스로 참조할 수 있어 불필요한 타입 변환을 피할 수 있습니다.

C++17의 std::filesystem 라이브러리를 사용하여 파일이나 디렉터리 경로를 다루는 기본적인 방법(예: 파일 존재 여부 확인, 디렉터리 생성)에 대해 설명하시오.
->
std::filesystem::exists(path) 함수를 사용하여 특정 경로에 파일이나 디렉터리가 존재하는지 bool값을 반환합니다.
std::filesystem::create_directory(path) 함수를 사용하여 새로운 디렉터리를 생성합니다. 상위 디렉터리가 없으면 실패하며 create_directories(path)를 사용하면 상위 디렉터리도 함께 생성합니다.
파일 크기 확인(file_size), 파일 삭제(remove), 디렉터리 순회(directory_iterator) 등 다양한 기능이 제공됩니다.

PIMPL(Pointer to IMPLementation) idiom은 무엇이며, C++에서 컴파일 시간 의존성(Compile-time Dependencies)을 줄이고 라이브러리의 ABI(Application Binary Interface) 안정성을 향상시키는 데 어떻게 기여하는지 설명하시오.
->
클래스의 구현 세부 사항(private 멤버 변수 및 함수)을 별도의 내부(impl) 클래스로 분리하고 public 클래스에서는 이 내부 클래스의 포인터만 멤버 변수로 가지는 디자인 패턴입니다.
컴파일 시간 의존성이 감소하며 라이브러리의 바이너리 호환성(ABI 안정성)을 유지하는데 크게 기여합니다.



3D 그래픽스에서 텍스처 압축(Texture Compression)이 필요한 주된 이유(메모리 절약, 대역폭 감소)와 DXT(또는 BC) 형식과 같은 블록 기반 압축 방식의 기본적인 원리를 설명하시오.
->
고해상도 텍스처는 많은 GPU 메모리를 차지하므로 압축을 통해 메모리를 절약할 수 있으며 텍스처를 압축하면 GPU와 VRAM 간의 데이터 전송에 필요한 대역폭이 감소되어 렌더링 성능을 향상시킵니다.
DXT 형식의 기본적인 원리는 블록 기반 압축으로 텍스처를 일정한 작은 블록(예: 4x4 픽셀) 단위로 나눕니다. 각 블록에 대해 두개의 기준 색상과 각 픽셀에 대한 2비트 인덱스를 저장합니다. 렌더링 시 두 기준 색상과 인덱스를 사용하여 픽셀의 최종 색상을 보간합니다. 사람의 눈이 색상 변화에 덜 민감한 점을 이용하여 시각적으로 큰 차이 없이 데이터의 크기를 줄이는 손실 압축 방식입니다.

네트워크 게임에서 "QoS(Quality of Service)"란 무엇이며, 패킷 손실이나 지터(Jitter)가 심한 환경에서 플레이어 경험을 개선하기 위해 어떤 QoS 전략(예: 대역폭 제한, 패킷 우선순위)을 고려할 수 있는지 설명하시오.
->
네트워크 통신에서 데이터 전송의 품질을 보장하기 위한 다양한 기술 및 정책을 의미합니다. 패킷 손실, 지연, 지터 등 네트워크 불안정성 문제를 완화하여 사용자 경험을 개선하는 것이 목표입니다.
대역폭 제한, 패킷 우선순위 부여, 오류 은닉, 지터 버퍼, 적응형 전송률 등의 QoS 전략이 있습니다.

컴퓨터 성능 분석 시 CPU 캐시 메모리 계층(L1, L2, L3 캐시)의 일반적인 특성(속도, 크기)을 설명하고, 캐시의 지역성(Locality)이 프로그램 성능에 어떤 영향을 미치는지 설명하시오.
->
L1 캐시는 가장 빠르고 가장 작습니다. 각 CPU 코어마다 전용으로 존재합니다.
L2 캐시는 L1보다 느리지만 크고 각 CPU 코어마다 전용이거나 여러 코어가 공유합니다.
L3 캐시는 L2보다 느리지만 가장 크고 모든 CPU 코어가 공유하는 경우가 많습니다.
CPU는 필요한 데이터를 L1부터 계층순으로 찾아보고 없으면 메인 메모리로 이동합니다.
캐시 지역성은 프로그램이 캐시의 특성을 잘 활용하는 정도를 말하며 최근에 접근했던 데이터가 다시 접근될 가능성인 시간 지역성과 최근 접근한 데이터의 주변 데이터가 접근될 가능성인 공간 지역성이 있습니다. 높은 캐시 지역성은 CPU가 필요한 데이터를 빠르게 찾아 사용함을 의미하며 메인 메모리의 접근을 최소화하고 CPU의 유휴 시간을 줄여 전반적인 프로그램 성능을 크게 향상시킵니다. 캐시미스가 줄어들수록 성능은 좋아집니다.



언리얼 엔진에서 머티리얼 인스턴싱(Material Instancing)은 무엇이며, 동적 머티리얼 인스턴스(Dynamic Material Instance) 생성 시 머티리얼 파라미터를 변경하는 방식이 어떤 성능적 이점을 제공하는지 설명하시오.
->
기본 마스터 머터리얼을 기반으로 특정 파라미터만 다르게 설정된 재사용 가능한 머터리얼 인스턴스를 생성하는 기능입니다. 마스터 머터리얼의 복사본이 아니라 파라미터 값만 변경 가능한 참조입니다.
동일한 마스터 머터리얼을 사용하는 여러 오브젝트는 파라미터만 다르더라도 엔진이 이를 동일한 드로우콜로 묶어 처리할 수 있는 경우가 많아 CPU 오버헤드를 줄여 드로우콜 배치 최적화 효과를 보입니다.
마스터 머터리얼은 한번만 컴파일되고 인스턴스는 런타임에 파라미터만 변경하므로 머터리얼 쉐이더를 다시 컴파일할 필요가 없어 컴파일 시간을 절약합니다.
인스턴스는 마스터 머터리얼의 쉐이더 코드를 공유하므로 메모리 사용량이 훨씬 적습니다.
매번 새로운 머터리얼을 생성하는 대신 동적 머터리얼 인스턴스의 파라미터만 효율적으로 변경할 수 있어 런타임 파라미터의 변경 효율성이 높습니다.

언리얼 엔진에서 Stat 명령(예: Stat Unit, Stat FPS, Stat Game)을 사용하여 게임의 성능을 프로파일링할 때, 각 명령이 보여주는 주요 지표는 무엇이며 어떤 정보를 제공하는지 설명하시오.
->
stat unit: 프레임 시간
stat fps: 현재 프레임레이트
stat game: 게임스레드 처리시간

언리얼 엔진 애니메이션 시스템에서 "Layered Blend per Bone" 노드는 무엇이며, 캐릭터의 특정 신체 부위(예: 상체, 하체)에만 애니메이션을 블렌딩하거나 겹칠 때 어떻게 사용되는지 설명하시오.
->
AnimGraph에서 여러 애니메이션 포즈를 특정 본 계층 구조를 기반으로 계층적으로 블렌딩하는 노드입니다. 지정된 본과 그 자식 본에는 상위 레이어의 애니메이션이 적용되고 그 외 본에는 하위 레이어의 애니메이션이 적용됩니다.
캐릭터 이동 중 상체가 조준 사격과 같은 특정 행동을 취할 때 사용되고 앉아서 조준 사격으로 이동하는 중 아이템을 집을 때 손이나 팔 등의 특정 신체부위에 부분 애니메이션을 오버레이할때 유용합니다.

언리얼 엔진 네트워크 복제(Replication)에서 액터의 bAlwaysRelevant 플래그는 어떤 의미를 가지며, 이 플래그를 언제(예: 항상 모든 클라이언트에 보여야 하는 액터) 사용하는 것이 적절한지 설명하시오.
->
해당 액터가 네트워크 복제과정에서 항상 모든 클라이언트에게 관련성 있음으로 간주되도록 설정하는 플래그입니다. 액터가 멀리 있거나 플레이어의 시야 밖에 있더라도 항상 네트워크를 통해 복제 대상이 됨을 의미합니다.
AGameState와 같이 항상 모든 클라이언트에 보여야 하는 액터나 원거리에서도 상호작용해야 하는 액터에 사용됩니다. 불필요하게 대역폭이 소비되지 않도록 사용 시 주의가 필요합니다.
