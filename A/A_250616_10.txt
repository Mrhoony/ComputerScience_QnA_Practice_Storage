C++에서 **가상 상속(Virtual Inheritance)**은 무엇이며, 특히 다중 상속 환경에서 발생하는 "다이아몬드 문제(Diamond Problem)"를 해결하기 위해 어떻게 사용되는지 설명하시오. 간단한 코드 예시를 들어 설명하시오.
->
가상 상속이란 C++에서 다중 상속 시 발생하는 다이아몬드 문제를 해결하기 위해 사용되는 상속 매커니즘입니다. virtual 키워드를 사용하여 기반 클래스를 상속받을 때 해당 기반 클래스의 서브오브젝트가 파생 클래스 계층 구조에서 단 한번만 포함되도록 보장합니다.
다이아몬드 문제는 공통의 기반 클래스(A)를 두개의 파생 클래스(B,C)가 각각 상속받고 이 두 파생 클래스(B, C)를 다시 하나의 최종 파생 클래스(D)가 다중 상속받는 형태입니다. 이때 최종 파생 클래스 D는 공통 기반 클래스 A의 멤버(데이터나 함수)를 B를 통해 한번, C를 통해 또 한번 두개의 사본을 가지게 됩니다. 이로 인해 멤버 접근 시 모호성이 발생하고 메모리 낭비가 초래됩니다.
다이아몬드 구조에서 공통 기반 클래스 A를 상속받는 중간 파생 클래스(B와 C)가 A를 virtual 키워드를 사용하여 상속하면 됩니다.
class B : virtual public A {...};
class C : virtual public A {...};
이렇게 하면 최종 파생 클래스 D 내부에 A의 서브오브젝트가 단 하나만 존재하게 되어 모호성 문제를 해결하고 메모리를 절약할 수 있습니다. 가상 상속 시 기반 클래스의 생성자는 최종 파생 클래스에 의해서만 직접 호출되어야 합니다. 중간 클래스의 생성자에서는 가상 기반 클래스의 생성자를 호출할 수 있지만 이는 무시되고 최종 파생 클래스의 호출이 우선합니다.

dynamic_cast 연산자는 런타임에 타입 캐스팅을 수행합니다. dynamic_cast가 다형적(Polymorphic) 클래스에만 적용될 수 있는 이유, 즉 클래스에 적어도 하나의 가상 함수가 필요한 이유를 설명하시오.
->
dynamic_cast 연산자는 C++에서 런타임에 안전하게 다운캐스팅 또는 크로스캐스팅을 수행하는데 사용되는 타입 캐스팅 연산자입니다. 캐스팅이 유효하면 대상 타입의 포인터/참조를 반환하고 유효하지 않으면 nullptr 또는 std::bad_cast 예외를 발생시킵니다.
dynamic_cast는 런타임에 객체의 실제 타입 정보(RTTI, Run-Time Type Information)를 사용하여 캐스팅의 유효성을 검사합니다. 이 RTTI 정보는 클래스에 적어도 하나의 가상함수가 선언되어 있어야만 컴파일러에 의해 생성되고 객체 내부에 저장됩니다. 가상함수는 객체 내부에 가상함수 테이블 포인터(vptr)를 추가하며 이 vptr은 RTTI 시스템이 객체의 실제 타입을 식별하는데 필요한 정보를 가리킵니다. 가상함수가 없는 클래스는 컴파일 시점에 정적으로 타입이 결정되므로 런타임에 타입 정보를 조회할 필요도 없고 그런 정보도 제공되지 않습니다. 따라서 dynamic_cast는 이러한 클래스에 대해 런타임 타입 검사를 수행할 수 없습니다.

가상 함수에 **기본 인자(Default Arguments)**가 선언되어 있고 파생 클래스에서 이 함수를 재정의(override)했을 때 발생할 수 있는 잠재적인 문제점(예: 함수 호출 시 인자 해석의 모호성)을 설명하시오.
->
가상함수에 기본 인자가 선언되어 있고 파생 클래스에서 이 함수를 재정의했을 때 함수를 호출하는 포인터/참조의 타입에 따라 기본 인자의 해석이 달라지는 모호성이 발생할 수 있습니다. 가상함수는 런타임에 동적 바인딩을 통해 실제 호출될 함수 구현이 결정됩니다. 기본 인자는 컴파일러가 컴파일 시점에 함수 호출이 이루어지는 포인터/참조의 정적 타입을 기준으로 결정하고 삽입합니다.
#include <iostream>
class Base {
public:
    virtual void func(int x = 10) { std::cout << x << std::endl; }
}

class Derived : public Base {
public:
    void func(int x = 20) override { std::cout << x << std::endl; }
}

int main() {
    Derived d;
    Base* bPtr = &d;

    d.func();
    bPtr->func();
}
bPtr->func()를 호출하면 런타임 다형성에 의해 Derived::func가 실제로 호출됩니다. 하지만 기본 인자 x의 값은 컴파일 시점에 bPtr의 정적 타입인 Base*를 기준으로 결정된 10이 전달됩니다. 이는 개발자의 의도와 다를 수 있으며 디버깅하기 매우 어려운 논리적 오류를 초래합니다. 그래서 가상함수에는 기본 인자를 사용하지 않거나 파생 클래스에서 재정의 시 기본 인자를 변경하지 않도록 하는 것이 좋습니다.

가상 함수를 inline 키워드와 함께 선언할 수 있는지 설명하고, 만약 가능하다면 컴파일러의 인라인 최적화에 어떤 영향을 미치며, 런타임 가상 호출 메커니즘과 어떻게 상호작용하는지 설명하시오.
->
가상함수도 inline 키워드와 함께 선언할 수 있습니다.
inline 키워드는 컴파일러에게 함수를 호출 지점에 직접 삽입하도록 힌트를 주는 것입니다. 컴파일러는 이 힌트를 따를 수도 있고 따르지 않을 수도 있습니다.
정적 호출의 경우 만약 컴파일러가 함수 호출 시점의 객체 타입을 명확히 알 수 있다면 컴파일러는 가상함수라도 인라인 최적화를 시도할 수 있습니다. 이 경우 가상함수 호출 매커니즘을 우회하고 일반 함수처럼 인라인됩니다.
동적 호출의 경우 런타임에 객체 타입이 결정되는 다형적 호출의 경우 컴파일러는 어떤 함수가 호출될지 미리 알 수 없습니다. 이 경우 인라인 최적화는 불가능하며 가상함수 테이블을 통한 동적 디스패치 매커니즘을 따르게 됩니다.
inline 키워드는 최대한 인라인해달라는 요청일 뿐 무조건 인라인해야 된다는 명령이 아닙니다. 가상함수 호출의 본질적인 특성(런타임 다형성)으로 인해 대부분의 다형적 가상함수 호출은 인라인되지 않습니다. inline 키워드가 있더라도 런타임에 V-table 룩업을 통해 함수 주소를 찾아 호출하는 방식은 변하지 않습니다. 다만 컴파일러가 충분한 정보를 가지고 정적으로 호출할 함수를 결정할 수 있다면 이때 inline 키워드가 최적화에 도움이 될 수 있습니다.
가상 함수에 inline을 붙이는 것이 문법적으로는 유효하지만 대부분의 경우 런타임 다형성의 특성때문에 실제 성능 향상에 큰 영향을 미치지 않을 수 있습니다. 하지만 특정 정적 호출 시나리오에서는 유용할 수 있습니다.

다중 상속(Multiple Inheritance) 상황에서 가상 함수 테이블(V-Table)의 구조가 단일 상속에 비해 어떻게 더 복잡해질 수 있는지 간략하게 설명하시오.
->
단일 상속에서는 각 클래스가 하나의 V-Table을 가지며 파생 클래스는 부모의 V-Table을 복사하고 필요한 가상함수를 재정의하여 자신의 V-Table을 만듭니다. 객체는 하나의 vptr을 통해 이 V-Table을 가리킵니다. 다중 상속 시 최종 파생 클래스의 객체는 각각의 직접적인 기반 클래스마다 별도의 vptr을 가질 수 있습니다. 이는 각 기반 클래스의 관점에서 다형성을 올바르게 처리하기 위함입니다.
각 기반 클래스의 vptr은 해당 기반 클래스에 해당하는 V-Table을 가리킵니다. 이 V-Table에는 해당 기반 클래스의 가상함수와 파생 클래스에서 오버라이드된 함수들의 주소가 저장됩니다. 문제는 한 가상함수가 호출되었을 때 this 포인터가 해당 함수가 속한 서브오브젝트의 시작 주소를 가리키도록 this 포인터 조정이 필요할 수 있다는 것입니다. 컴파일러는 이러한 this 포인터 조정을 수행하는 작은 코드 조각(thunk)을 V-Table 엔트리에 삽입하거나 별도의 V-Table 그룹을 사용하여 복잡성을 관리합니다.
가상 상속까지 사용되면 공통의 가상 기반 클래스의 서브오브젝트가 하나만 존재하도록 해야하므로 V-Table과 vptr의 레이아웃이 더욱 복잡해집니다. 컴파일러는 가상 기반 클래스 서브오브젝트의 위치를 찾기 위한 오프셋 정보를 추가적으로 관리해야 합니다.
다중 상속은 컴파일러가 객체 메모리 레이아웃과 V-Table 구조를 설계하는데 훨씬 더 많은 정보를 필요로 하며 이로 인해 객체의 크기가 커지고 가상함수 호출의 간접성이 증가하여 미미하지만 성능 오버헤드가 발생할 수 있습니다. 상속보다 합성을 선호하라는 원칙이 강조되는 이유 중 하나입니다.

const 한정자(qualifier)는 가상 함수에 어떻게 적용될 수 있으며, 가상 함수가 const와 const가 아닌 오버로드(overload)를 가질 때 다형적 호출에서 어떤 규칙이 적용되는지 설명하시오.
->
가상함수에도 일반 멤버 함수와 동일하게 const 한정자를 적용할 수 있습니다. const 가상함수는 해당 함수가 객체의 상태를 변경하지 않음을 나타냅니다. 파생 클래스에서 가상함수를 재정의할 때 기반 클래스의 가상함수가 const면 파생 클래스의 재정의 함수도 반드시 const여야 합니다.
클래스는 동일한 이름을 가진 가상함수에 대해 const 버전과 const가 아닌 버전을 오버로드할 수 있습니다.
다형적 호출에서 규칙으로 const 객체 또는 const 포인터/참조를 통해 호출하는 경우 const 버전의 가상함수가 호출됩니다. 설령 파생 객체가 const가 아닐지라도 const 포인터/참조를 통해 접근하면 const 버전이 선택됩니다. const가 아닌 객체 또는 포인터/참조를 통해 호출하는 경우 항상 const가 아닌 버전의 가상함수가 호출됩니다. 이는 C++의 오버로드 결정 규칙과 다형적 디스패치 규칙이 결합된 결과입니다. 컴파일러는 먼저 호출 시점의 객체의 const 여부에 따라 적절한 오버로드를 선택하고 그 다음 런타임에 V-Table을 통해 실제 파생 클래스의 함수 구현을 찾습니다.

C++에서 일반 멤버 함수나 정적(Static) 멤버 함수를 virtual로 선언하는 것이 왜 문법적으로 허용되지 않는지 설명하시오.
->
virtual 키워드는 런타임 다형성을 가능하게 하기 위해 존재합니다. 런타임 다형성은 기반 클래스 포인터/참조를 통해 파생 클래스의 특정 오버라이드된 함수를 호출할 수 있도록 합니다. 일반 멤버 함수는 컴파일 시점에 정적으로 바인딩됩니다. 즉 함수 호출이 컴파일러에 의해 미리 결정됩니다. 따라서 이 함수들은 오버라이드의 개념이 없으며 virtual 키워드를 사용하더라도 런타임에 다형적으로 호출될 수 없습니다. virtual 키워드는 이러한 함수의 동작 방식과 충돌하므로 문법적으로 허용되지 않습니다.
정적 멤버 함수는 클래스의 인스턴스에 속하지 않고 클래스 자체에 속합니다. 즉 특정 객체를 통해 호출되는 것이 아니라 클래스 이름을 통해 직접 호출됩니다. 가상함수는 항상 특정 객체의 상태에 따라 동작하며 객체의 V-Table을 통해 호출됩니다. 정적 멤버 함수는 객체가 존재하지 않아도 호출될 수 있으므로 V-Table 매커니즘을 사용할 수 없습니다. 또한 정적 함수는 상속 계층에서 오버라이드될 수 없습니다. 파생 클래스에서 동일한 이름의 정적 함수를 정의하는 것은 단순히 새로운 정적 함수를 정의하는 것이지 기반 클래스의 정적 함수를 재정의하는 것이 아닙니다. 따라서 virtual 키워드는 객체 인스턴스와 다형성에 의존하므로 정적 멤버 함수에는 의미가 없으며 문법적으로 금지됩니다.

가상 함수 호출의 성능 오버헤드는 단순히 V-Table 룩업 이상의 요소를 가집니다. V-Table 룩업 외에 CPU 캐시(Cache) 효율성, 예측 불가능한 분기(Branch Prediction) 등 어떤 요소들이 가상 함수 호출의 성능에 영향을 미치는지 설명하시오.
->
V-Table 룩업은 가장 직접적인 오버헤드입니다. 함수 포인터를 직접 호출하는 대신 객체의 vptr을 통해 V-Table에 접근하고 거기서 해당 함수에 해당하는 주소를 찾아 다시 호출해야 합니다. 이는 최소한 한번의 추가적인 메모리 접근을 의미합니다.
가상함수 호출은 V-Table을 통해 메모리 어딘가에 있는 실제 함수 코드로 점프합니다. 이로 인해 명령어 캐시 미스가 발생할 가능성이 높아집니다. 인라인되지 않은 함수 호출은 항상 캐시 미스의 위험이 있지만 가상 호출은 호출 대상이 런타임에 결정되므로 캐시 프리페칭(Prefetching)이 어려워 더욱 취약합니다. 또한 객체 자체가 여러개의 V-Table 포인터를 가지거나 V-Table 자체가 크면 데이터 캐시에도 영향을 미칠 수 있습니다.
최신 CPU는 파이프라인 효율성을 위해 다음 실행될 명령어의 주소를 미리 예측합니다(분기 예측). 일반적인 함수 호출은 호출 대상이 고정적이므로 예측 성공률이 매우 높습니다. 하지만 가상함수 호출은 런타임에 어떤 파생 클래스의 함수가 호출될지 미리 알 수 없습니다. 호출 경로가 다양할수록 예측 성공률이 떨어지고 예측 실패 시 CPU는 파이프라인을 비우고 다시 채워야 하므로 상당한 성능 패널티가 발생합니다. 이는 V-Table 룩업 자체보다 더 큰 오버헤드를 유발할 수 있습니다.
런타임에 동적으로 결정되는 특성 때문에 컴파일러는 가상함수 호출에 대해 정적 분석 기반의 인라인화나 다른 강력한 최적화(Dead Code Elimination 등)를 적용하기 어렵습니다.

객체가 소멸될 때(특히 기본 클래스 포인터를 통해 소멸자를 호출할 때), 소멸자 내부에서 가상 함수를 호출하면 어떤 동작을 하며, 이때 다형적 호출이 예상대로 이루어지지 않는 이유를 설명하시오.
->
객체가 소멸될 때 가장 파생된 클래스의 소멸자부터 시작하여 기반 클래스의 소멸자로 역순으로 호출됩니다. 이 소멸자 체인 내에서 가상함수를 호출할 수 있습니다.
소멸자가 호출되는 시점부터 객체는 점진적으로 소멸되는 상태가 됩니다. 각 소멸자가 실행되는 시점에는 해당 소멸자가 속한 클래스의 멤버들만 유효하고 그 아래의 파생 클래스 부분은 이미 소멸되었거나 소멸중입니다.
특정 클래스의 소멸자가 실행될 때 해당 객체의 vptr은 더이상 가장 파생된 클래스의 V-Table을 가리키지 않고 현재 실행중인 클래스의 V-Table을 가리키도록 변경됩니다.
만약 기반 클래스 포인터를 통해 객체를 소멸시키는 경우 파생 클래스의 소멸자가 먼저 호출된 후 기반 클래스의 소멸자가 호출됩니다. 기반 클래스의 소멸자 내에서 가상함수를 호출하면 이때 vptr은 이미 기반 클래스의 V-Table을 가리키고 있으므로 기반 클래스에 정의된 가상함수 구현이 호출됩니다. 이때 파생된 클래스의 구현은 호출되지 않습니다. 이는 파생 클래스의 멤버가 이미 소멸된 상태에서 파생 클래스의 가상함수 구현을 호출하려고 하면 예외가 발생할 수 있기 때문에 C++ 표준에 의해 정의된 동작입니다.
소멸자 내부에서 가상함수를 호출하는 것은 기술적으로 가능하지만 다형적 동작을 기대할 수 없으며 이미 소멸된 파생 클래스 멤버에 접근하여 심각한 런타임 오류를 유발할 수 있으므로 신중하게 사용하거나 피하는 것이 좋습니다.

C++에서 다형성을 구현하는 두 가지 주요 방법인 **가상 함수(런타임 다형성)**와 **템플릿(컴파일 타임 다형성)**을 비교하고, 각각의 장단점 및 게임 개발 환경에서 어떤 상황에 더 적합한지 논하시오.
->
가상함수는 상속 관계에서 기반 클래스 포인터/참조를 통해 파생 클래스의 오버라이드된 함수를 런타임에 동적으로 호출하는 방식입니다. 새로운 파생 클래스가 추가되어도 기존 코드를 수정할 필요가 없고 특정 인터페이스(기반 클래스)만 알면 다양한 구현체를 다룰 수 있습니다. 템플릿처럼 타입별로 코드를 생성하지 않으므로 컴파일 시간이 비교적 짧습니다.
V-Table 룩업, 캐시 미스, 분기 예측 실패 등으로 인한 런타임 오버헤드가 있고 잘못된 캐스팅이나 널 포인터 접근 시 런타임 오류가 발생할 수 있습니다. 상속 계층을 기반으로 하므로 계층 구조가 변경되면 영향을 받습니다.
모든 AActor들이 Tick() 함수를 다형적으로 호출하는 것처럼 다양한 종류의 엔티티를 공통 인터페이스로 다룰 때, 게임 시스템의 핵심을 추상화할 때, 확장 가능한 모듈 시스템 등의 게임 개발 환경에 적합합니다.
템플릿은 타입 매개변수를 사용하여 제네릭 코드를 작성하고 컴파일 시점에 실제 타입에 따라 코드를 생성하는 방식이며 함수 오버로딩도 이에 해당합니다. 런타임 오버헤드가 거의 없고 컴파일러가 인라인화 및 기타 최적화를 적극적으로 적용할 수 있어 최고 성능을 제공합니다. 컴파일 시점에 모든 타입 검사가 이루어져 런타임 오류를 줄이고 상속 관계가 아닌 독립적인 타입에도 적용 가능합니다.
각 타입별로 코드가 생성되므로 실행 파일 크기가 커질 수 있고 복잡한 템플릿 사용 시 컴파일 시간이 길어질 수 있습니다. 템플릿 관련 컴파일 오류 메세지가 이해하기 어려울 수 있습니다. 런타임에 타입을 변경할 수 없습니다.
성능이 매우 중요한 제네릭 알고리즘(TArray, TMap 등의 컨테이너 클래스, 수학 라이브러리 함수 등), 타입에 따라 동작이 달라지지만 런타임에 변경될 필요가 없는 경우, 컴파일 타임에 결정되는 최적화가 필요한 경우(게임 내 오브젝트 풀링 시스템의 제네릭 구현) 등의 게임 개발 환경에 적합합니다.
게임 개발에서는 두가지 다형성 기법이 상호보완적으로 사용됩니다.
가상함수는 주로 엔티티 시스템, 컴포넌트 모델, 이벤트 핸들링 등 유연하고 확장 가능한 아키텍처를 구축하는데 사용됩니다. 런타임에 다양한 오브젝트를 공통 인터페이스로 다루어야 할 때 필수적입니다.
템플릿은 높은 성능이 요구되는 코어 로직, 제네릭 데이터 구조, 수학 연산 등에서 컴파일 타임 최적화를 통해 최대한의 효율을 끌어낼 때 사용됩니다. 게임 엔진에서는 이 두가지를 적절히 조합하여 성능과 유연성 사이의 균형을 맞춥니다.