C++에서 std::shared_ptr를 사용할 때 순환 참조(Circular Reference) 문제가 발생하는 원인과 std::weak_ptr를 사용하여 이를 어떻게 해결하는지 설명하시오.
->
std::shared_ptr은 참조 카운트 기반의 스마트 포인터입니다. 순환 참조는 두개 이상의 std::shared_ptr 객체가 서로를 std::shared_ptr로 가리킬 때 상호 간에 강력한 참조를 형성할 때 발생합니다. 각 객체의 참조 카운트가 항상 1 이상으로 유지되어 어느 객체도 참조 카운트가 0이 되지 않아 메모리에서 해제되지 않고 결과적으로 메모리 누수를 유발합니다.
std::weak_ptr은 std::shared_ptr이 관리하는 객체에 대한 약한 참조를 제공하는 스마트 포인터입니다. std::weak_ptr은 참조 카운트에 영향을 주지 않습니다. 순환 참조가 예상되는 한쪽 방향의 참조를 std::weak_ptr로 변경하여 순환 참조 문제를 해결할 수 있습니다.
std::weak_ptr은 가리키는 객체가 유효한지 확인하려면 반드시 lock() 메소드를 호출하여 std::shared_ptr을 얻어야 합니다. 만약 객체가 소멸되었다면 lock()은 nullptr을 반환합니다.

RAII(Resource Acquisition Is Initialization) 원칙은 무엇이며, C++에서 자원(메모리, 파일 핸들, 뮤텍스 등)을 안전하고 효율적으로 관리하는 데 어떻게 적용되는지 설명하시오.
->
RAII는 자원 획득은 초기화라는 의미로 자원의 생명주기를 객체의 생명주기와 일치시키는 프로그래밍 패러다임입니다. 자원은 객체의 생성자에서 획득되고 객체의 소멸자에서 해제됩니다.
std::unique_ptr이나 std::shared_ptr과 같은 스마트 포인터가 대표적인 RAII 적용 사례입니다. 힙 메모리에서 생성자를 할당하고 소멸자에서 delete를 호출하여 해제합니다. 이를 통해 개발자가 명시적으로 delete를 호출하지 않아도 메모리 누수를 방지(메모리 관리)합니다. 파일 객체의 생성자에서 파일을 열고 소멸자에서 파일을 닫도록 구현(파일 핸들 관리)하면 함수를 벗어나거나 예외가 발생하더라도 파일이 안전하게 닫힙니다. std::lock_guard나 std::unique_lock과 같은 락가드도 RAII가 적용되어 있습니다. 생성자에서 뮤텍스를 잠그고 소멸자에서 자동으로 잠금을 해제합니다. 이를 통해 교착 상태를 방지하고 예외 발생 시에도 뮤텍스가 항상 해제되도록 보장(뮤텍스 관리)합니다. 이 외에도 네트워크 소켓, 데이터베이스 연결 등 모든 종류의 시스템 자원에 적용될 수 있습니다.
RAII 원칙을 따르면 자원 누수를 방지하고 코드 안정성 향상, 가독성 및 유지보수에 용이합니다.

C++20에 도입된 [[no_unique_address]] 속성(attribute)은 무엇이며, 빈(empty) 클래스 타입의 멤버 변수가 메모리 레이아웃에 미치는 영향을 최적화하여 메모리 공간을 절약하는 데 어떻게 기여하는지 설명하시오.
->
[[no_unique_address]]는 클래스의 비정적 데이터 멤버에 적용됩니다. 이 속성이 지정된 멤버가 빈 클래스 타입일 경우 해당 멤버가 실제 메모리 공간을 차지하지 않도록 컴파일러에게 힌트를 줍니다.
C++ 표준은 빈 클래스조차도 1바이트 이상의 크기를 가지도록 요구(고유한 주소를 갖기 위해서)합니다. 이 때문에 구조체 내부에 빈 클래스 타입의 멤버가 여러개 있으면 각 멤버가 최소 1바이트씩 차지하여 불필요한 메모리 낭비가 발생할 수 있습니다.
[[no_unique_address]]는 컴파일러가 이러한 빈 클래스 멤버들을 Empty Base Optimization(EBO)과 유사하게 최적화할 수 있도록 합니다. 즉 빈 클래스 멤버가 다른 멤버나 구조체의 패딩 공간을 공유하여 메모리 오버헤드를 제거하고 공간을 절약합니다.
struct Empty {};
struct WithEmptyMember
{
    Empty e;  // 일반적으로 1바이트 차지
    int i;
};
struct WithNoUniqueAddress {
    [[no_unique_address]] Empty e;  // e가 0바이트를 차지할 수 있음
    int i;
};
// 컴파일러 최적화에 따라 다음과 같은 차이가 있을 수 있다.
// sizeof(WithEmptyMember)는 8 (1바이트 e + 3바이트 패딩 + 4바이트 i)
// sizeof(WithNoUniqueAddress)는 4 (0바이트 e + 4바이트 i)



3D 그래픽스 렌더링 파이프라인에서 "지연 렌더링(Deferred Rendering)"과 "전방 렌더링(Forward Rendering)" 방식의 주요 차이점과 각각의 장단점(예: 광원 처리 효율성, 투명도 처리)을 비교하시오.
->
포워드 렌더링(전방 렌더링)은 각 오브젝트를 렌더링할 때마다 해당 오브젝트에 영향을 미치는 모든 광원을 계산하여 즉시 픽셀 쉐이더에서 최종 색상을 결정합니다.
투명도 처리에 용이하고 각 픽셀에 대해 여러 샘플을 취하여 안티 에일리어싱(MSAA)을 쉽게 적용할 수 있습니다. 파이프라인 구조가 직관적이고 이해하기 쉽습니다. 오브젝트에 영향을 미치는 광원의 수에 비례하여 픽셀 쉐이더가 여러번 실행되므로 광원 수가 많아지면 성능이 급격하게 저하됩니다. 모든 광원 계산이 단일 쉐이더에서 이루어져 쉐이더 코드가 복잡해질 수 있습니다.
디퍼드 렌더링(지연 렌더링)은 렌더링 과정을 두개로 나눠 진행합니다. 장면의 모든 지오메트리 정보를 텍스처에 저장합니다. G-버퍼 패스라 부르며 이 단계에서는 광원 계산을 하지 않습니다. G-버퍼에 저장된 정보를 바탕으로 각 픽셀에 대해 광원 계산을 한번만 수행(라이팅 패스)하여 최종 색상을 결정합니다. 광원은 2D 이미지 공간에서 처리됩니다.
장면 내 광원 수가 많아져도 성능 저하가 적습니다. 광원 계산이 픽셀당 한번만 수행되므로 복잡한 라이팅 환경에서 효율적입니다. 많은 양의 동적 광원도 효율적으로 처리할 수 있습니다.
G-버퍼에는 하나의 깊이 정보만 저장되므로 투명한 오브젝트를 처리하기 어렵습니다. (별도의 포워드 렌더링 패스가 필요) G-버퍼 생성을 위해 많은 텍스처 메모리가 필요하고 MSAA를 직접 적용하기 어렵습니다.
광원 수가 적거나 투명도 처리가 중요한 경우 포워드 렌더링, 광원 수가 많고 복잡한 조명 환경이 필요한 경우 디퍼드 렌더링이 유리합니다. UE에서는 두 방식을 조합하여 사용합니다.

네트워크 게임에서 "네트워크 메시지 압축(Network Message Compression)"이 왜 중요하며, 어떤 기본적인 압축 알고리즘(예: Run-Length Encoding, Huffman Coding)이 게임에서 활용될 수 있는지 설명하시오.
->
게임 데이터를 압축하여 전송하면 네트워크 대역폭 사용량을 크게 줄일 수 있습니다. 전송해야 할 데이터의 양이 줄어들면 패킷 크기가 작아지므로 네트워크를 통한 전송 시간이 단축되어 전반적인 지연시간이 감소하고 반응성이 향상됩니다. 더 적은 수의 더 작은 패킷을 전송하므로 네트워크 혼잡 상황에서 패킷 손실률이 줄어들 수 있습니다.
Run-Length Encoding(RLE)는 연속적으로 반복되는 동일한 데이터를 반복횟수 + 데이터 형태로 압축합니다. 주로 연속된 동일 값이 많은 데이터에 유용합니다. 복잡한 게임 상태 데이터에는 비효율적일 수 있습니다.
허프만 코딩은 데이터 내에서 자주 나타나는 문자나 심볼에 더 짧은 비트 코드를 할당하고 드물게 나타나는 심볼에 더 긴 코드를 할당하여 전체 데이터의 길이를 줄이는 가변 길이 코딩 방식입니다. 로그 메세지, 문자열 데이터, 특정 이벤트 플래그 등 반복되는 패턴이 있는 데이터에 효과적입니다.
LZ 계열 압축(LZ77, LZ78, LZW 등)은 이전에 나타났던 데이터 시퀀스를 참조하여 반복되는 시퀀스를 압축합니다. 대부분의 게임 데이터에 광범위하게 사용됩니다. 뛰어난 압축률과 합리적인 압축/해제 속도를 제공합니다.

그래프 탐색 알고리즘인 다익스트라(Dijkstra)와 A*(A-star) 알고리즘의 주요 차이점은 무엇이며, A*가 휴리스틱(Heuristic)을 사용하여 다익스트라보다 특정 상황(예: 길 찾기)에서 더 효율적인 이유를 설명하시오.
->
다익스트라 알고리즘은 시작 노드에서부터 모든 도달 가능한 노드까지의 최단 경로를 찾는 알고리즘입니다. 각 노드에 대해 시작점에서 해당 노드까지의 최단 거리를 계속 업데이트하며 방문하지 않은 노드 중 가장 거리가 짧은 노드를 선택하여 탐색을 확장합니다. 음수 가중치 간선은 처리하지 못합니다. 시작점에서부터 모든 방향으로 균등하게 탐색을 확장합니다. 목표 노드가 어디에 있든 상관없이 모든 노드까지의 최단 거리를 찾으려고 시도합니다.
A-star 알고리즘은 다익스트라 알고리즘에 휴리스틱 함수를 추가하여 탐색 방향을 유도하는 알고리즘입니다. 노드 n을 탐색할 때 f(n) = g(n) + h(n) 값을 기준으로 우선순위를 정합니다.
g(n)은 시작점에서 노드 n까지의 실제 비용 (다익스트라와 동일)
h(n)은 노드 n에서 목표 노드까지의 추정 비용 (휴리스틱)
휴리스틱을 사용하여 목표 방향으로 탐색을 집중합니다.
다익스트라는 휴리스틱을 사용하지 않습니다. 따라서 목표가 어디에 있든 시작점에서부터 모든 가능한 경로를 탐색합니다. 반면 A-star는 휴리스틱을 사용하여 목표를 향해 탐색을 유도합니다.
다익스트라는 길 찾기 문제에서 목표 노드가 명확하더라도 불필요하게 넓은 영역을 탐색해야 합니다. A-star는 휴리스틱이 목표까지의 대략적인 거리를 알려주어 목표와 관련없는 노드들을 탐색하지 않도록 탐색 공간을 효율적으로 줄입니다. 따라서 대부분의 길 찾기 문제에서 다익스트라보다 훨씬 빠르게 최단 경로를 찾을 수 있습니다.
적절한 휴리스틱 함수(실제 비용보다 절대 과대평가하지 않는 허용 가능한 휴리스틱)를 사용한다면 A-star 알고리즘은 다익스트라와 마찬가지로 항상 최단 경로를 보장합니다.



언리얼 엔진 5(UE5)의 주요 렌더링 기술인 Lumen과 Nanite는 각각 어떤 기능을 제공하며, 어떤 종류의 씬(Scene) 구성(예: 동적 전역 조명, 고도로 상세한 지오메트리)에서 특히 강력한 이점을 가지는지 설명하시오.
->
루멘은 UE5의 완전 동적인 조명 및 반사 시스템입니다. 기존의 베이킹 방식이나 스크린 스페이스 기반 방식과 달리 씬에 있는 모든 광원의 상호작용을 실시간으로 계산하여 매우 사실적인 효과를 제공합니다. 빛의 바운스, 간접 그림자 등을 처리합니다.
실시간으로 움직이는 광원이나 변화하는 지오메트리에 의해 조명이 즉각적으로 업데이트되는 완전 동적인 씬에 강력합니다. 건축 시각화, 환경 변화가 많은 게임 씬에서 현실적인 조명 시뮬레이션을 가능하게 합니다. 작은 디테일이나 복잡한 표면에서도 정확한 간접 조명과 반사를 생성하여 영화 같은 품질의 렌더링을 가능하게 합니다.
나나이트는 UE5의 가상화된 지오메트리 시스템입니다. 수억, 수십억 개의 폴리곤으로 구성된 매우 상세한 고품질 에셋을 실시간으로 렌더링할 수 있도록 합니다. 카메라와의 거리에 따라 자동으로 LOD를 지능적으로 스트리밍하고 렌더링합니다. 영화나 CAD 모델처럼 매우 높은 폴리곤 수의 원본 에셋을 직접 임포트하여 사용할 수 있게 합니다. 수작업으로 LOD를 만들 필요가 없어 아티스트의 생산성을 극대화합니다. 수많은 고해상도 오브젝트로 구성된 방대한 오픈월드 씬에서 일관된 고품질을 유지하면서도 성능을 최적화하는데 필수적입니다. 에셋의 시각적 품질 손상 없이 엄청난 지오메트리 복잡성을 처리합니다.

언리얼 엔진에서 UPROPERTY, UFUNCTION, UCLASS 등에 사용되는 메타 데이터 지정자(Metadata Specifiers, 예: BlueprintCallable, BlueprintType, Config)는 어떤 역할을 하며, 엔진 리플렉션 시스템에서 어떻게 활용되어 에디터나 블루프린트에서 기능을 노출하는지 설명하시오.
->
메타데이터 지정자는 UPROPERTY, UFUNCTION, UCLASS, USTRUCT, UENUM 등 UE의 리플렉션 시스템이 인식하는 매크로에 사용되는 추가적인 속성 정보입니다. 이들은 컴파일러에게는 단순히 주석과 같은 역할을 하지만 UE의 UHT에 의해 파싱되어 리플렉션 데이터(메타데이터)로 변환됩니다.
EditAnywhere, VisibleAnywhere, BlueprintCallable, BlueprintType 등 에디터에서 기능 노출을 지원합니다. SaveGame, Transient 등 프로퍼티가 저장/로드될 때 어떻게 처리될지 지정하여 직렬화를 지원합니다. Replicated, ReplicatedUsing 등 프로퍼티가 네트워크를 통해 복제될지 여부를 지정합니다. 특정 프로퍼티에 대한 드롭다운 목록, 슬라이더 범위, 커스텀 위젯 등을 정의할 수 있습니다.
UHT는 C++ 소스 코드에서 메타데이터 지정자를 읽어들여 .generated.h 파일과 리플렉션 데이터베이스를 생성합니다. 런타임에 UE는 리플렉션 데이터베이스를 사용하여 UObject, UStruct, UFunction, UProperty 등의 정보를 동적으로 쿼리하고 조작할 수 있습니다. 이를 통해 에디터에서 프로퍼티 패널을 자동으로 구성하고 블루프린트는 C++ 함수와 변수에 접근할 수 있게 하며 직렬화, 네트워크 복제, GC 등 엔진의 핵심 기능들이 C++ 코드의 구조를 동적으로 이해하고 작동할 수 있게 됩니다.

언리얼 엔진의 Gameplay Ability System(GAS)에서 FGameplayEffectSpec은 무엇이며, 어빌리티가 적용될 때 실제로 발생할 효과(예: 스탯 변경, 태그 부여, 버프/디버프)를 어떻게 정의하고 전달하는지 설명하시오.
->
FGameplayEffectSpec은 UE의 Gameplay Ability System에서 GameplayEffect를 특정 대상에게 적용하기 위한 인스턴스화된 데이터를 나타내는 구조체입니다. UGameplayEffect는 템플릿(Blueprintable UObject)인 반면 FGameplayEffectSpec은 런타임에 이 템플릿을 기반으로 생성된 GameplayEffect 인스턴스입니다.
FGameplayEffectSpec은 어떤 UGameplayEffect 템플릿을 기반으로 하는지, Stack Count, Level, Duration, Modifiers, 1개 이상의 GameplayTag, 0개 이상의 GameplayAbility, 적용 대상 AttributeSet, PredictionHandle 등의 정보를 포함하여 어빌리티가 적용될 때 발생할 실제 효과를 정의하고 전달합니다.
AbilitySystemComponent를 가지고있는 Owner에 대해 공격이나 아이템 사용 등 상호작용이 발생하였을 때 일반적으로 상호작용을 일으킨 객체 내부의 코드나 블루프린트에서 정의된 행동 또는 효과를 Owner의 ASC에 등록하여 효과를 적용합니다.

언리얼 엔진 네트워크 복제에서 액터의 NetUpdateFrequency는 무엇이며, 이 값이 네트워크 대역폭 사용량과 CPU 오버헤드에 미치는 영향 및 AlwaysRelevant 설정과의 관계를 설명하시오.
->
NetUpdateFrequency는 AActor 클래스의 프로퍼티로 액터가 네트워크를 통해 복제될 최소 빈도를 정의합니다. 값이 2인 경우 이 액터의 복제된 프로퍼티는 서버에서 클라이언트로 최소 0.5초마다 한번씩 전송됩니다.
값을 높게 설정하면 더 자주 복제되므로 네트워크 대역폭 사용량이 증가하고 서버측 CPU 오버헤드도 증가합니다. 값을 낮게 설정하면 네트워크 대역폭 사용량과 서버측 CPU 오버헤드가 감소하지만 액터의 상태 변화가 덜 부드럽고 상태 불일치가 자주 발생할 수 있습니다.
AlwaysRelevant는 AActor의 또 다른 복제 관련 프로퍼티로 액터가 플레이어의 시야나 거리에 관계없이 항상 모든 클라이언트에게 복제되어야 하는지 여부를 결정합니다. bAlwaysRelevant가 true로 설정되면 액터는 항상 복제 대상이 됩니다. AlwaysRelevant는 액터의 복제 여부를 NetUpdateFrequency는 액터의 복제 주기를 담당합니다.