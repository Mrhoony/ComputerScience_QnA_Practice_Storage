네트워크 롤(Network Role)의 기본 개념: 언리얼 엔진에서 액터(Actor)가 가질 수 있는 주요 네트워크 롤(예: ROLE_Authority, ROLE_SimulatedProxy, ROLE_AutonomousProxy, ROLE_None)은 무엇이며, 각각의 롤이 클라이언트와 서버 환경에서 액터의 동작 및 권한에 어떤 영향을 미치는지 설명하시오.
->
UE에서 액터의 네트워크 롤은 해당 액터가 네트워크 게임 세션 내에서 어떤 권한과 책임을 가지는지를 나타내는 중요한 속성입니다. 각 액터 인스턴스는 클라이언트와 서버 환경에서 다른 롤을 가질 수 있으며 이는 액터의 동작 및 데이터 동기화 방식에 큰 영향을 미칩니다.
ROLE_Authority에 대해서 액터의 서버측 인스턴스는 항상 ROLE_Authority를 가집니다. 일반적으로 클라이언트는 ROLE_Authority 액터를 가지지 않습니다. 예외적으로 로컬 플레이어가 서버 겸 클라이언트인 경우(Listen Server) 자신의 액터는 ROLE_Authority를 가집니다. 해당 액터의 모든 게임 로직의 최종적인 권한과 결정권을 가집니다. 변경된 상태는 다른 클라이언트로 복제됩니다.
ROLE_SimulatedProxy에 대해서 다른 플레이어가 제어하는 캐릭터나 서버에 의해 제어되는 AI 캐릭터 또는 서버에 의해 복제되는 환경 액터의 클라이언트 측 인스턴스가 이 롤을 가집니다. 서버로부터 복제된 데이터를 수신하여 자신의 상태를 업데이트하고 받은 데이터를 기반으로 시각적/청각적 표현을 수행합니다. 스스로 게임 로직을 결정하거나 상태를 변경할 권한은 없습니다.
ROLE_AutonomousProxy에 대해서 현재 클라이언트를 조작하는 로컬 플레이어의 캐릭터 액터 인스턴스가 이 롤을 가집니다. ROLE_SimulatedProxy와 유사하게 서버로부터 복제된 데이터를 받지만 추가적으로 로컬 플레이어의 입력을 처리하고 서버에 자신의 행동을 Server RPC로 전송하며 클라이언트 측 예측을 수행하여 네트워크 지연을 보상할 수 있는 권한을 가집니다. 스스로 게임 상태를 변경하는 최종 권한은 없으나 로컬 입력을 통해 서버에 상태 변경을 요청할 수 있습니다.
ROLE_None에 대해서 액터가 복제 대상이 아니거나 아직 네트워크 롤이 할당되지 않은 초기 상태일 때 가집니다. 해당 액터는 네트워크 상호작용을 수행하지 않습니다. 주로 UI 관련 액터나 임시적인 로컬 이펙트 액터 등이 이 롤을 가질 수 있습니다.

ROLE_Authority의 의미와 중요성: ROLE_Authority 롤이 왜 중요한지 설명하고, 이 롤을 가진 액터가 게임 상태를 변경하고 다른 클라이언트들에게 복제(Replication)하는 데 어떤 역할을 하는지 설명하시오.
->
ROLE_Authority 롤은 특정 액터 인스턴스에 대한 궁극적인 네트워크 권한을 의미합니다. 해당 액터의 상태와 행동에 대한 최종적인 결정권을 가지는 주체입니다.
멀티플레이어 게임에서 모든 플레이어 간의 게임 상태 일관성을 유지하고 치트를 방지하며 게임 규칙의 공정성을 확보하는데 필수적입니다. 서버가 ROLE_Authority를 가짐으로서 클라이언트의 조작된 입력이나 임의적인 상태 변경 시도를 통제할 수 있습니다. 서버의 ROLE_Authority 액터가 게임의 모든 로직을 실행하고 최종 상태를 결정함으로서 모든 클라이언트가 진실된 상태를 복제 받아 일관된 게임 월드를 경험하게 됩니다.
ROLE_Authority를 가진 액터는 자신의 내부 프로퍼티 값을 변경하고 복제된 함수를 호출하는 등 액터의 상태를 자유롭게 변경할 수 있습니다. 이 액터가 UPROPRETY(Replicated)로 선언된 프로퍼티의 값을 변경하면 UE의 복제 시스템은 자동으로 해당 변경을 감지하여 ROLE_SimulatedProxy나 ROLE_AutonomousProxy 롤을 가진 관련 클라이언트 액터 인스턴스로 복제합니다. 이를 통해 서버의 Authority 액터가 게임의 모든 상태 변화를 주도하고 클라이언트 액터들은 이를 따라가는 방식으로 동기화가 이루어집니다.

ROLE_AutonomousProxy와 ROLE_SimulatedProxy의 차이: ROLE_AutonomousProxy와 ROLE_SimulatedProxy 롤의 주된 차이점을 설명하고, 플레이어가 직접 제어하는 캐릭터(로컬 플레이어)와 다른 플레이어의 캐릭터가 각각 어떤 롤을 가지며 왜 그렇게 되는지 설명하시오.
->
ROLE_AutonomousProxy는 현재 클라이언트를 조작하는 로컬 플레이어의 캐릭터가 가집니다. 서버로부터 상태를 복제받고 로컬 플레이어의 사용자 입력을 직접 처리하고 이를 Server RPC를 통해 서버에 전달합니다. 클라이언트 예측 로직을 실행할 수 있습니다. 이동 입력이 들어오면 서버 응답을 기다리지 않고 로컬에서 즉시 캐릭터를 움직여 네트워크 지연을 보상하고 부드러운 플레이 경험을 제공합니다. 나중에 서버의 실제 위치를 받아 클라이언트 예측을 보정합니다. APlayerController에 의해 소유됩니다.
ROLE_SimulatedProxy는 다른 클라이언트의 플레이어가 조작하는 캐릭터 또는 서버에 의해 제어되는 AI 캐릭터의 클라이언트 측 인스턴스가 가집니다. 오직 서버로부터 복제된 데이터만을 수신하여 자신의 상태를 업데이트하고 시각적/청각적 표현을 수행합니다. 스스로 입력을 처리하거나 서버에 행동을 요청하거나 클라이언트 예측을 수행할 권한이 없습니다. 수동적으로 서버의 상태를 시뮬레이션(흉내)합니다. AAIController에 의해 소유되거나 컨트롤러에 소유되지 않을 수 있습니다.
ROLE_AutonomousProxy는 내가 조종하는 액터로서 입력 처리와 클라이언트 예측 능력을 가지는 반면 ROLE_SimulatedProxy는 다른 누군가가 조종하는 액터로서 오직 서버의 복제 데이터에 의존하여 시뮬레이션만 수행한다는 것이 핵심 차이입니다.

네트워크 권한(Network Authority)의 위임: 언리얼 엔진에서 액터의 네트워크 권한이 서버로부터 클라이언트로 위임(Possess)될 때 어떤 일이 발생하며, 이 과정에서 액터의 롤(Role)이 어떻게 변경되는지 설명하시오.
->
UE에서 액터의 네트워크 권한은 기본적으로 서버가 가집니다. 그러나 플레이어가 APawn을 소유할 때 해당 Pawn에 대한 특정 종류의 권한 위임이 발생하며 이 과정에서 액터의 롤이 변경됩니다. APlayerController가 APawn을 소유(빙의, Possess)할 때 발생하는 일은 서버는 특정 플레이어의 APlayerController가 새로 스폰된 APawn을 Possess()하도록 지시하고 서버는 APawn의 클라이언트 측 인스턴스에 대한 RemoteRole을 ROLE_AutonomousProxy로 설정하도록 지시합니다. 이 APawn의 롤 정보는 해당 클라이언트로 복제됩니다. 자신의 APlayerController가 소유한 APawn의 Role은 ROLE_AutonomousProxy로 변경됩니다. 이 클라이언트에서 이제 이 Pawn에 대해 사용자 입력을 처리하고 서버에 전송하며 클라이언트 예측을 수행할 수 있는 자율적인 대리인의 권한을 얻습니다. 다른 플레이어의 APawn에 대한 클라이언트 측 인스턴스는 ROLE_SimulatedProxy 롤을 유지하거나 변경됩니다. 이들은 해당 Pawn에 대한 입력 처리 권한이 없으므로 오직 서버로부터 복제된 상태만을 시뮬레이션합니다.
Possess 과정은 액터의 Role 변수를 변경하여 액터가 네트워크 상에서 어떤 역할을 수행할지에 대한 권한을 부여하거나 제한하는 핵심적인 매커니즘입니다. 서버는 여전히 최종적인 Authority를 가지지만 AutonomousProxy에게는 특정 행동(입력 처리, 예측)에 대한 로컬 권한을 위임합니다.

RPC(Remote Procedure Call)와 네트워크 롤: Server RPC, Client RPC, NetMulticast RPC가 각각 어떤 네트워크 롤을 가진 액터에서 호출되고 실행될 수 있는지 설명하고, 각 RPC가 호출될 때 액터의 네트워크 롤이 어떻게 영향을 미치는지 설명하시오.
->
RPC는 액터의 네트워크 롤에 따라 호출 및 실행 가능 여부가 결정됩니다.
Server RPC는 ROLE_AutonomousProxy 롤을 가진 액터에서만 호출할 수 있습니다. 항상 ROLE_Authority 롤을 가진 액터에서 실행됩니다. 클라이언트의 AutonomousProxy가 플레이어 입력을 받아 서버의 Authority 액터에게 해당 행동을 요청합니다. ROLE_SimulatedProxy나 ROLE_None 액터는 Server RPC를 호출할 수 없습니다.
Client RPC는 ROLE_Authority 롤을 가진 액터에서 호출합니다. 호출된 특정 클라이언트 액터에서 실행됩니다. 서버의 Authority 액터가 특정 클라이언트의 액터에게 특정 로직을 실행하도록 지시합니다.
NetMulticast RPC는 항상 ROLE_Authority 롤을 가진 액터에서 호출합니다. 서버 자신과 연결된 모든 클라이언트의 해당 액터에서 동시에 실행됩니다. 서버의 Authority 액터가 모든 클라이언트에게 동일한 이벤트를 전파하여 모두가 같은 시각적/청각적 효과를 보거나 동일한 로컬 로직을 실행하도록 동기화합니다.

GetLocalRole()과 GetRemoteRole(): 액터에서 GetLocalRole()과 GetRemoteRole() 함수를 사용하여 현재 액터의 네트워크 롤과 원격 액터의 롤을 확인하는 목적은 무엇이며, 이 정보가 게임 로직(예: 입력 처리, 상태 변경)을 분기하는 데 어떻게 활용되는지 설명하시오.
->
GetLocalRole()은 현재 코드가 실행되고 있는 액터 인스턴스 자신의 네트워크 롤을 반환합니다. 이 액터가 지금 서버에서 ROLE_Authority로 실행되는지 아니면 클라이언트에서 ROLE_AutonomousProxy나 ROLE_SimulatedProxy로 실행되는지 확인합니다.
GetRemoteRole()은 현재 코드가 실행되고 있는 액터 인스턴스와 네트워크 상에서 통신하는 상대방 액터 인스턴스의 네트워크 롤을 반환합니다. 서버에서 GetRemoteRole()을 호출하면 클라이언트 측 해당 액터 인스턴스의 롤을 알 수 있습니다. 클라이언트에서 GetRemoteRole()을 호출하면 서버측 해당 액터 인스턴스의 롤을 알 수 있습니다.
이 두 함수는 멀티플레이어 환경에서 액터의 책임과 실행 컨텍스트에 따라 게임 로직을 정확하게 분기하는 데 필수적으로 사용됩니다. 이 함수들을 통해 개발자는 각 네트워크 롤의 책임을 명확히 구분하고 불필요한 로직 실행을 막아 네트워크 대역폭을 절약하고 보안 취약점을 방지하며 게임의 일관된 동작을 보장할 수 있습니다.

네트워크 롤에 따른 로직 분기: 멀티플레이어 게임에서 특정 게임 로직(예: 물리 시뮬레이션, AI 행동, UI 업데이트)을 구현할 때, 액터의 네트워크 롤에 따라 코드를 다르게 실행해야 하는 이유와 구체적인 C++ 코드 예시를 들어 설명하시오.
->
각 네트워크 롤은 게임 내에서 다른 권한과 책임을 가집니다. 서버는 게임 로직의 최종 결정권을 클라이언트는 시각적 표현 및 로컬 입력 처리 권한을 가집니다. 이들을 분리하지 않으면 보안 문제(치트), 비일관적인 게임 상태, 비효율적인 네트워크 사용, 복잡한 코드 유지보수 등의 문제가 발생합니다. 서버만이 게임의 핵심 상태를 변경할 수 있도록 하여 클라이언트 조작을 방지합니다. 클라이언트는 서버의 상태를 신뢰하고 반영하기만 해야 합니다. 모든 로직을 모든 머신에서 실행할 필요가 없습니다. AI 로직은 서버에서만 실행하고 클라이언트는 AI의 위치와 애니메이션만 복제하면 됩니다. 이를 통해 불필요한 연산을 줄이고 네트워크 트래픽을 절약할 수 있습니다. ROLE_AutonomousProxy는 클라이언트 예측을 통해 지연을 보상할 수 있는 특별한 로직을 가집니다.

액터의 bReplicates 속성: 액터의 bReplicates 속성이 true로 설정되어야 하는 주된 이유와, 이 속성이 false일 경우 액터의 네트워크 롤 및 복제 동작에 어떤 영향을 미치는지 설명하시오.
->
액터가 멀티플레이어 환경에서 네트워크를 통해 클라이언트와 서버 간에 상태가 동기화되어야 할 필요가 있을 때 bReplicates를 true로 설정해야 합니다. 이 액터가 서버에서 스폰되어 클라이언트들에게도 존재하고 서버의 상태 변경이 클라이언트에 반영되어야 할 때 필수적입니다. 이 속성이 true여야만 해당 액터의 UPROPRETY(Replicated) 프로퍼티들이 복제되고 UFUNCTION(Server/Client/NetMulticast) RPC들이 정상적으로 작동할 수 있습니다.
만약 이 속성이 false라면 액터는 항상 ROLE_None 롤을 가지게 되고 해당 액터는 네트워크를 통해 어떤 데이터도 복제되지 않습니다. 서버에서 스폰된 액터는 클라이언트에 존재하지 않거나 존재하더라도 독립적인 인스턴스로 존재하며 서버의 영향을 받지 않습니다. 복제를 선언한 프로퍼티, RPC로 지정한 함수 역시 복제되거나 동작하지 않습니다. 이런 경우는 싱글 플레이어 게임의 모든 액터 또는 멀티플레이어 게임에서 오직 로컬 클라이언트에서만 존재하는 액터(위젯, 파티클, 디버깅용 등) 등에 사용됩니다. 이러한 액터들은 네트워크 대역폭을 소모하지 않으므로 효율적입니다.

SetReplicates(true)와 SetReplicates(false)의 런타임 동작: 런타임에 액터의 SetReplicates() 함수를 호출하여 복제 상태를 변경할 때, 해당 액터의 네트워크 롤과 기존에 복제되던 프로퍼티들에 어떤 변화가 발생하는지 설명하시오.
->
SetReplicates(true) 호출 시 해당 액터가 서버에서 스폰된 후 이 함수가 호출되면 액터는 복제 가능한 액터로 등록됩니다. 서버의 해당 액터는 ROLE_Authority를 가지게 됩니다. 만약 클라이언트에게 이 액터가 관련성이 있다면 서버로부터 프로퍼티 복제를 시작합니다. UPROPERTY(Replicated)로 선언된 모든 프로퍼티는 초기값으로 클라이언트에 복제되기 시작합니다. 이후 서버에서 변경되는 값들도 정상적으로 복제됩니다. RPC도 정상적으로 작동할 수 있게 됩니다.
SetReplicates(false) 호출 시 해당 액터가 현재 복제 중인 상태에서 이 함수가 호출되면 액터는 더 이상 네트워크 복제 대상이 아니게 됩니다. 서버의 해당 액터는 여전히 ROLE_Authority를 가지지만 클라이언트에서는 해당 액터가 복제를 중단하거나 클라이언트에서 액터 인스턴스가 파괴될 수도 있습니다. 일반적으로 클라이언트 액터의 롤은 ROLE_None으로 변경되거나 액터 자체가 소멸됩니다. 프로퍼티는 복제되지 않고 RPC 역시 동작하지 않습니다.

네트워크 롤과 상태 동기화의 복잡성: 복잡한 게임 시스템(예: 인벤토리, 스킬 쿨다운, 버프/디버프)을 구현할 때, 액터의 네트워크 롤과 권한을 고려하여 클라이언트와 서버 간에 상태를 어떻게 효율적이고 안전하게 동기화할 수 있는지 설계 원칙을 제시하시오.
->
복잡한 게임 시스템을 구현할 때 액터의 네트워크 롤과 권한을 고려하여 클라이언트와 서버 간에 상태를 효율적이고 안전하게 동기화하는 것은 매우 중요합니다. 다음 설계 원칙을 따르는 것이 좋습니다.
모든 중요한 게임 상태는 반드시 서버의 ROLE_Authority 액터에서 관리하고 변경되어야 합니다. 클라이언트는 이 상태를 직접 변경할 수 없으며 오직 서버로부터 복제된 값을 신뢰해야 합니다.
지속적으로 동기화되어야 하는 데이터는 UPROPERTY(Replicated)를 사용합니다.
클라이언트의 사용자 입력이나 특정 행동 요청은 ROLE_AutonomousProxy에서 UFUNCTION(Server, Reliable) RPC를 통해 서버에 전달합니다.
모든 클라이언트에게 동시에 보여져야 할 시각적/청각적 효과나 동기화된 애니메이션은 ROLE_Authority에서 UFUNCTION(NetMulticast, Unreliable/Reliable) RPC를 통해 전파합니다.
특정 플레이어에게만 필요한 UI 업데이트, 개인 메세지, 특정 플레이어에게만 적용되는 로컬 상태는 UFUNCTIOn(Client, Reliable) RPC를 사용합니다.
플레이어의 즉각적인 반응이 중요한 로직의 경우 ROLE_AutonomousProxy에서 서버 응답을 기다리지 않고 로컬에서 먼저 결과를 예측하여 실행하고 나중에 서버의 실제 값과 동기화하여 보정합니다.
모든 복제된 프로퍼티가 항상 모든 클라이언트에 필요하지 않으므로 DOREPLIFETIME_COND 등을 사용하여 특정 조건에서만 복제되도록 제한합니다.
이러한 원칙들을 조합하여 각 데이터의 중요도, 빈도, 보안 요구사항, 지연 민감도에 따라 적절한 동기화 매커니즘과 네트워크 롤을 활용함으로서 복잡한 게임 시스템을 효율적이고 안전하며 안정적으로 멀티플레이어 환경에서 구현할 수 있습니다.