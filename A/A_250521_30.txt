C++11에 도입된 static_assert는 무엇이며, 컴파일 타임에 어떤 종류의 오류를 검사하는 데 사용되는지 설명하시오.
->
런타임에 조건을 검사하는 assert와 달리 static_assert는 컴파일러가 코드를 컴파일하는 시점에 주어진 조건식이 false인지 여부를 평가합니다.
타입의 크기, 특성, 데이터 정렬, 열거형의 범위와 값 등 정적인 제약 조건이나 불변성을 검사합니다.

C++에서 커스텀 할당자(Custom Allocator)를 사용하는 주된 목적은 무엇이며, 어떤 경우에 고려할 수 있는지 설명하시오.
->
애플리케이션의 특정 요구사항에 맞춰 메모리 할당/해제 전략을 최적화하는 것입니다. 성증 향상, 메모리 단편화 감소, 특정 하드웨어 제약 조건 충족, 디버깅 및 프로파일링을 위해 사용됩니다.

람다 표현식에서 [this] 캡처와 [*this] 캡처의 차이점을 설명하시오.
->
[this]는 this 포인터를 값으로 복사하여 캡처합니다. 포인터의 값은 주소이므로 원본 객체의 멤버 변수와 함수에 접근할 수 있고 람다 내에서 수정이 이루어지면 원본 객체도 영향을 받습니다. 댕글링 포인터의 위험이 있습니다.
[*this]는 객체 자체를 복사하여 캡처하여 람다 내부에 독립된 원본 객체의 복사본이 생성되고 원본에 영향을 주지 않습니다. 댕글링 포인터의 위험이 없습니다.

C++17의 구조적 바인딩(Structured Bindings)이 std::tuple이나 std::pair와 함께 사용될 때 코드를 어떻게 간결하게 만드는지 간단한 예시를 드시오.
->
구조적 바인딩을 사용하지 않을 경우 std::pair<std::string, int> data = getdata()와 같이 받아와야 하고 data.first, data.second로 사용합니다.
구조적 바인딩의 경우 auto [text, index] = getdata()와 같이 사용하며 변수도 first, second가 아닌 text, index를 사용하여 코드를 간결하게 만들 수 있습니다.

C++11에 도입된 사용자 정의 리터럴(User-defined Literals)은 무엇이며, 어떤 용도로 사용될 수 있는지 간단한 예시를 드시오.
->
프로그래머가 자신만의 접미사를 사용하여 기존의 리터럴을 확장하고 커스텀 타입의 객체를 생성할 수 있도록 해줍니다. 접미사는 항상 언더바(_)로 시작해야 합니다.
class Distance
{
public:
    double meters;
    explicit Distance(double inmeters) : meters(inmeters) {}
};

Distance operator""_km(long double km)
{
    return Distance(static_cast<double>(km * 1000.0));
}

int main()
{
    Distance d = 10.0_km;
    std::cout << "d :" << d1.meters << std::endl;
}

Windows 환경에서 DLL(Dynamic Link Library)을 사용하여 C++ 코드를 모듈화할 때, __declspec(dllexport)와 __declspec(dllimport)의 역할을 설명하시오.
->
dll을 만들고 사용할 때 심볼(클래스, 함수, 변수)의 내보내기/가져오기를 명시적으로 제어하는데 사용됩니다.
__declspec(dllexport)는 dll 밖으로 내보내 다른 실행 파일이나 다른 dll에서 사용할 수 있도록 합니다.
__declspec(dllimport)는 dll을 사용하는 실행 파일이나 다른 dll을 빌드할 때 사용됩니다.

C++11에 도입된 =default 및 =delete 함수 선언의 의미와 사용 목적을 설명하시오.
->
클래스의 특수 멤버 함수의 동작을 명시적으로 제어하기 위해 도입된 키워드입니다. (생성자, 소멸자, 복사 생성자, 복사 대입 연산자, 이동 생성자, 이동 대입 연산자)
=default는 기본으로 생성되는 버전을 사용하도록 지시하는 것입니다.
=delete는 해당 함수를 사용할 수 없도록 지시하는 것입니다.

C++의 union 자료구조는 무엇이며, 어떤 경우에 유용하게 사용될 수 있는지 설명하시오.
->
모든 멤버가 같은 메모리 공간을 공유하는 클래스 타입입니다. 메모리는 멤버들 중 가장 큰 멤버의 크기로 결정되며 하나의 멤버만이 유효한 값을 가질 수 있습니다. 메모리 절약, 타입 오버레이 등에 사용될 수 있습니다.

C++에서 포인터 연산(Pointer Arithmetic)이 가능한 타입과 불가능한 타입을 설명하고, 그 이유를 설명하시오.
->
배열 요소의 포인터, 기본 타입의 포인터, 클래스/구조체 타입의 포인터는 포인터 연산이 가능합니다. 함수 포인터, 널포인터, 클래스 멤버 포인터, 일반적인 단일 객체 포인터는 포인터 연산이 불가합니다. 포인터 연산은 메모리 상에 연속적으로 배치된 동일한 데이터 블록의 요소들에 효율적으로 접근하기 위해 만들어졌기 때문에 연속적이지 않은 경우의 포인터 연산은 문법적으로 가능하더라도 에러가 날 가능성이 높습니다.

가상 함수(Virtual Function) 호출 시 내부적으로 가상 함수 테이블(V-Table)이 어떻게 작동하는지 간략히 설명하시오.
->
가상 함수를 하나 이상 가진 클래스에 대해 컴파일러는 클래스별로 가상함수 테이블(vftable)을 생성합니다. 이 테이블은 클래스가 정의하거나 오버라이딩한 모든 가상 함수의 실제 주소를 배열 형태로 저장하고 있습니다.
가상 함수를 하나 이상 가진 클래스의 객체가 생성될 때마다 해당 객체는 가상함수 포인터(vfptr)를 가지게 됩니다.
가상함수가 호출되면 객체의 숨겨진 vfptr에 접근하고 vfptr이 가리키는 해당 객체의 실제 클래스의 vftable을 찾습니다. vftable에서 호출하려는 가상 함수에 해당하는 인덱스를 사용하여 실제로 호출되어야 할 함수의 주소를 찾습니다. 찾아낸 함수 주소를 통해 해당 함수를 간접적으로 호출합니다.

3D 그래픽스에서 깊이 테스트(Depth Testing)가 필요한 이유와 Z-fighting 현상에 대해 설명하시오.
->
카메라로부터 가까이 있는 오브젝트는 보이고 멀리 있는 오브젝트는 가까운 오브젝트에 가려져 보여서는 안됩니다. 깊이 테스트는 이러한 가시성 문제를 해결하여 3D 공간의 올바른 원근감을 표현하는데 필요한 기법입니다.
깊이 테스트를 수행할 때 두개 이상의 오브젝트가 동일한 깊이값을 가질 때 발생하는 시각적 아티팩트입니다. GPU가 어느 오브젝트가 더 가까운지 판단하지 못하고 렌더링될때 마다 두 오브젝트가 번갈아가며 그려져 반짝이거나 깜빡이는 현상으로 나타납니다.

3D 그래픽스에서 컬링(Culling) 기법 중 후면 컬링(Backface Culling)의 원리와 목적을 설명하시오.
->
컬링 기법은 렌더링할 필요가 없는 오브젝트나 폴리곤을 미리 제거하여 불필요한 렌더링 연산을 줄여 성능을 최적화하는 기법들을 총칭합니다.
후면 컬링은 3D 모델의 특정 폴리곤의 노멀벡터가 카메라를 바라보는 방향과 반대일 경우 해당 폴리곤을 뒷면으로 간주하고 렌더링 파이프라인에서 제거하는 기법입니다.

텍스처 매핑(Texture Mapping)에서 텍스처 필터링(예: Bilinear, Trilinear)과 텍스처 래핑(Wrapping) 모드(예: Clamp, Repeat)의 목적을 설명하시오.
-> 텍스처 필터링은 3D 오브젝트에 텍스처를 입힐 때 텍셀이 화면의 한 픽셀에 정확히 1:1로 매핑되지 않을 때 시각적 문제를 해결하고 텍스처의 품질을 향상시키는 기법입니다.
택스처 래핑은 텍스처의 UV 좌표가 0과 1의 범위를 벗어났을 때 텍스처가 오브젝트 표면에 어떻게 반복되거나 확장될지 결정하는 기법입니다. 가장자리 텍셀의 색상 값을 반복하는 클램프나 텍스처를 계속 반복하는 리핏이 설정될 수 있습니다.

네트워크 환경에서 로드 밸런싱(Load Balancing)의 개념과 게임 서버에 적용될 수 있는 기본적인 아이디어를 설명하시오.
->
로드 밸런싱은 네트워크 환경에서 여러 대의 서버나 리소스에 걸쳐 네트워크 트래픽이나 작업 부하를 균등하게 분산시키는 기술입니다.
게임 서버에서는 접속 서버나 인증 서버의 로드 밸런싱을 적용하여 플레이어의 게임 접속을 지원하고 대규모 월드나 여러개의 지역으로 나뉘는 게임에서 게임월드/영역 서버의 로드 밸런싱을 적용하여 각 지역들을 분산하여 처리합니다.

TCP(Transmission Control Protocol)의 혼잡 제어(Congestion Control) 메커니즘이 필요한 이유와 기본적인 작동 원리를 설명하시오.
->
네트워크 상의 라우터나 링크에 처리할 수 있는 데이터량보다 더 많은 트래픽이 몰릴 때 혼잡이 발생합니다. TCP는 혼잡 제어 매커니즘을 사용하여 네트워크가 과부하되는 것을 방지하고 네트워크 자원을 공정하게 사용하여 전체 네트워크의 효율성을 높입니다.
혼잡 윈도우(Congestion WIndow, cwnd)라는 변수를 조절하여 송신자가 한번에 네트워크로 전송할 수 있는 데이터의 양을 제한하는 방식으로 작동합니다. 수신자가 ACK 패킷을 잘 보내주면 cwnd를 늘리고 패킷 손실의 징후가 발생하면 cwnd를 줄입니다. 

운영체제에서 뮤텍스(Mutex)와 세마포어(Semaphore)의 차이점을 설명하고, 각각 어떤 상황에 주로 사용되는지 설명하시오.
->
뮤텍스와 세마포어는 멀티스레딩/멀티프로세스 환경에서 공유 자원에 대한 동시 접근을 제어하여 데이터 불일치 문제를 방지하고 동기화를 달성하기 위한 동기화 기본 요소입니다.
뮤텍스는 상호 배제(Mutual Exclusion)의 약자로 단 하나의 스레드/프로세스만이 특정 공유 자원(임계 영역, Critical Section)에 접근하도록 허용하는 동기화 매커니즘입니다.
세마포어는 공유 자원에 동시에 접근할 수 있는 스레드/프로세스의 개수를 제어하는 동기화 매커니즘입니다. 세마포어는 정수 값(카운터)를 가지며 wait 연산으로 감소하고 signal 연산으로 증가합니다. 카운터가 0이면 wait 연산은 블록됩니다.

프로세스 간 통신(IPC: Inter-Process Communication) 방법 중 공유 메모리(Shared Memory)와 파이프(Pipe)의 차이점을 설명하시오.
->
공유 메모리는 여러 프로세스가 동일한 물리적 메모리 영역에 접근할 수 있도록 허용하는 IPC 방법입니다. 데이터 전송속도가 빠르지만 동기화가 필요하며 구조화된 데이터에 적합합니다.
파이프는 한 프로세스의 출력을 다른 프로세스의 입력으로 연결하는 단방향 또는 양방향 통신 채널입니다. 데이터를 바이트 스트림 형태로 전송하고 동기화가 내장되어있으며 전송속도가 느려서 단순한 데이터에 적합합니다.

게임의 물리 시뮬레이션에서 충돌 감지(Collision Detection)에 사용되는 기본 기법(예: AABB, Sphere)의 개념을 설명하시오.
->
AABB는 3D 오브젝트를 완전히 감싸는 축에 평행항 직육면체 형태의 경계 볼륨입니다. 두 상자의 범위가 겹치는지 여부를 확인하여 충돌을 감지합니다. 계산이 간단하고 빠르며 구현이 쉽지만 회전에 따른 충돌 오차가 발생할 수 있습니다.
Sphere는 구 형태의 경계 볼륨입니다. 두 구의 중심점 간 거리가 두 구의 반지름의 합보다 작으면 충돌을 감지합니다. 회전에 독립적이나 복잡한 형태의 오브젝트를 감싸면 AABB보다 훨씬 더 많은 오차를 가질 수 있습니다.

공간 데이터 구조 중 K-d 트리(K-d Tree)의 기본적인 구성 원리와 어떤 종류의 공간 쿼리(Query)에 적합한지 설명하시오.
->
kd트리는 k차원 공간에 있는 점들을 효율적으로 저장하고 검색하기 위한 이진 탐색 트리 기반의 공간 분할 자료구조입니다. 최근접 이웃 탐색, 범위 커리에 매우 효율적이며 지리정보 시스템, 데이터 마이닝 등에서 효율적인 공간 검색이 필요할 때 사용됩니다.

블룸 필터(Bloom Filter)의 개념과 어떤 종류의 '빠른 존재 확인' 문제에 활용될 수 있는지 설명하시오. (단, 오탐(false positive) 가능성 언급)
->
블룸 필터는 어떤 원소가 집합에 포함되어 있는지 여부를 빠르게 확인할 수 있도록 해주느 확률적인 자료구조입니다. 블룸 필터는 오탐은 허용하지만 미탐은 허용하지 않는 상황에서의 빠른 존재 확인에 활용됩니다. 웹 브라우저의 악성 URL 필터링, 데이터베이스 쿼리 최적화, 네트워크 패킷 필터링, 캐시 관리 등에서 활용됩니다.

언리얼 엔진에서 렌더 타겟(Render Target)은 무엇이며, 어떤 목적으로 사용되는지 (예: 미니맵, 반사, 동적 텍스처 생성) 설명하시오.
->
3D 씬을 직접 스크린이 아닌 메모리에 있는 텍스처에 렌더링하도록 지시하는 특별한 종류의 텍스처 에셋입니다. 미니맵, 반사, 동적 텍스처 생성, 후처리 효과의 중간 단계, 스크린샷, 녹화 등에 활용됩니다.

언리얼 엔진의 포스트 프로세스 머티리얼(Post Process Material)은 무엇이며, 화면에 어떤 시각적 효과를 적용하는 데 사용되는지 설명하시오.
->
최종 렌더링된 화면을 입력받아 픽셀 단위의 커스텀 셰이딩 연산을 수행하여 다양한 시각적 효과를 적용하는 데 사용되는 특별한 종류의 머터리얼입니다. 카툰 쉐이딩, 아웃라인, 블러/디스토션, 렌즈왜곡, 화면전환, 렌더패스 시각화, 색상보정 등의 효과를 제공합니다.

언리얼 엔진 네트워크 프로그래밍에서 서버 트래블(Server Travel)은 무엇이며, 멀티플레이어 게임에서 레벨 전환 시 어떻게 작동하는지 설명하시오.
->
멀티플레이어 게임의 모든 클라이언트를 특정 새로운 레벨로 동시에 이동시키는 매커니즘입니다. 서버에서 서버트래블 함수가 호출되면 모든 클라이언트에게 새로운 레벨로 이동하는 내부 RPC 명령이 전송됩니다. 서버는 새로운 레벨을 로딩하고 로딩이 완료되면 클라이언트들은 레벨 로딩 및 접속을 진행한 뒤 최종적으로 동기화하여 게임이 진행됩니다.

언리얼 엔진의 네트워크 디버깅을 위해 사용할 수 있는 콘솔 명령(예: Net 관련 명령)이나 프로파일러 도구(예: Session Frontend의 Network Profiler)에 대해 아는 대로 설명하시오.
->
net stat: 네트워크 통계 정보 표시
showdebug net: 네트워크 관련 디버그 정보 표시
Session Frontend의 Network Profiler에서는 시간대별 네트워크 트래픽 시각화, 액터/속성별 복제량 분석, RPC 호출 통계, 네트워크 관련성 및 컬링 시각화, 지터/패킷손실/지연 시뮬레이션을 확인할 수 있습니다.

언리얼 엔진 AI 시스템에서 행동 트리(Behavior Tree)의 데코레이터(Decorator)와 서비스(Service)의 역할을 설명하고, 각각 어떤 상황에 사용되는지 예시를 드시오.
->
데코레이터는 트리 내에서 태스크 노드에 부착되어 노드의 실행 여부를 결정하는 조건을 정의합니다. 부착된 노드의 실행 전 평가됩니다.
서비스는 트리 내에서 노드에 부착되며 해당 노드와 그 하위 트리가 활성화되어 있는 동안 주기적으로 특정 작업을 수행하는 데 사용됩니다.

언리얼 엔진에서 TArray를 사용할 때 ShrinkToFit() 함수와 Reserve() 함수의 목적과 사용 시점을 설명하시오.
->
Reserve() 함수는 TArray의 내부 배열이 할당할 수 있는 최대 요소 개수(capacity)를 미리 설정합니다. TArray에 많은 수의 요소를 추가할 것이 예상될 때 미리 충분한 capacity를 확보하기 위해 사용합니다.
ShrinkToFit() 함수는 현재 요소 개수에 맞게 내부 할당된 메모리를 줄여서 불필요하게 낭비되는 메모리 공간을 회수합니다. TArray에서 많은 수의 요소를 제거한 경우 낭비되는 메모리를 줄이기 위해 사용합니다.

언리얼 엔진에서 에셋 리디렉터(Asset Redirector)는 무엇이며, 어떤 경우에 생성되고 어떻게 관리해야 하는지 설명하시오.
->
에셋이 이름이 변경되거나 다른 폴더로 이동했을 때 리디렉션 정보를 저장하는 특수한 종류의 에셋입니다. 에셋의 이동, 이름 변경, 복사/붙여넣기 후 원본 삭제, 외부 파일 이동/삭제 시 리디렉터가 생성됩니다.
주기적으로 콘텐츠 브라우저에서 관리가 필요한 에셋이 들어있는 폴더를 선택하여 Fix Up Redirectors in Folder 기능을 실행하여 리디렉터 에셋을 주기적으로 갱신 및 관리해줍니다.

언리얼 엔진의 Slate UI 시스템은 무엇이며, UMG(Unreal Motion Graphics)와 비교했을 때 어떤 특징(주로 C++ 기반)을 가지는지 설명하시오.
->
언리얼 엔진의 로우레벨 UI 프레임워크입니다. 언리얼 에디터 자체의 UI도 Slate로 만들어져 있습니다.
UMG는 Slate위에 구축된 상위 레벨의 비주얼 스크립팀 기반 UI 시스템입니다. 일반적인 게임 개발에서는 UMG를 주로 사용하고 UMG로 구현이 어렵거나 성능 병목이 있는 특수한 경우에만 Slate를 직접 활용합니다.

언리얼 엔진 개발 과정에서 소스 컨트롤(예: Perforce, Git)을 에디터 내에서 연동하여 사용하는 기본적인 방법과 장점을 설명하시오.
->
에디터 우하단의 소스 컨트롤 버튼을 눌러서 사용할 소스 컨트롤 프로그램에 맞춰 연동합니다.
체크아웃/체크인 기능을 통해 파일이 여러 작업자를 통해 작업되고 충돌이 발생하는 현상을 방지하며 에셋 관리의 편의 및 워크플로우 효율을 제공합니다.

언리얼 엔진의 애셋 쿡(Cook) 과정은 무엇이며, 패키징된 게임에서 애셋이 어떻게 로드되는지 간략히 설명하시오.
->
개발 환경의 에셋을 최종 빌드된 게임이 사용할 수 있는 최적화된 형식으로 변환하는 과정입니다.
개발 환경에서는 .uasset의 파일로 존재하지만 패키징된 게임에서는 .pak 파일이라는 압축된 아카이브 파일 내부에 저장됩니다. 게임이 실행되면 pak 파일을 찾아 로드합니다. 특정 에셋을 참조하려고 할 때 그 에셋의 경로를 pak 파일 내부의 메타데이터를 포함하는 디렉터리 테이블을 조회하여 해당 에셋의 위치와 크기를 파악합니다. 이후 pak 파일 내에서 찾아서 메모리에 로드하고 역직렬화하여 게임에서 사용됩니다.