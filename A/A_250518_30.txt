C++에서 constexpr 키워드와 #define 매크로의 차이점 및 각각의 장단점을 설명하시오.
-> 
#define: 전처리기 매크로로 컴파일 전 단순히 텍스트를 치환하는 방식입니다. 타입 체크가 없고 스코프를 따르지 않으며 디버깅이 어렵습니다. 장점으로 단순한 텍스트 치환에 유용하고 컴파일 타임 오버헤드가 거의 없습니다. 단점으로 타입 안정성이 없어 오류 발생 가능성이 높고 스코프가 없어 이름 충돌 위험이 있습니다. 디버거로 추적하기 어렵습니다.
constexpr: 변수나 함수의 결과가 컴파일 타임 상수가 될 수 있음을 나타냅니다. 컴파일 시점에서 평가될 수 있으면 컴파일 타임 상수로 아니면 런타임 상수로 작동합니다. 타입이 안전하며 스코프를 따르고 디버깅이 가능합니다. 장점으로 타입 안전성이 보장되어 #define보다 안전하고 스코프를 따르며 디버깅이 용이합니다. 단점으로 컴파일 타임 평가를 위해 특정 규칙을 따라야 하고 컴파일 시간이 약간 증가할 수 있습니다.

람다 함수(Lambda Function)란 무엇이며, 어떤 경우에 유용하게 사용될 수 있는지 설명하고 간단한 문법을 제시하시오.
->
익명 함수 객체를 인라인으로 정의할 수 있는 기능입니다. 이름 없이 즉석에서 함수를 정의하고 호출할 때 사용합니다.
[캡처](매개변수) -> 반환타입 { 함수본문 }
캡처: 외부 스코프의 변수를 람다 함수 내에서 사용할 수 있도록 캡처하는 부분입니다.
STL 알고리즘에서 비교함수나 조건자, 작업함수 등 간단하게 인라인 정의할 때, 비동기 작업/콜백 함수를 정의할 때, 짧고 로컬한 함수를 생성할 때 사용됩니다.

C++에서 복사 생성자(Copy Constructor), 복사 대입 연산자(Copy Assignment Operator), 이동 생성자(Move Constructor), 이동 대입 연산자(Move Assignment Operator)의 역할과 Rule of Three/Five/Zero에 대해 설명하시오.
->
복사 생성자: 이미 존재하는 객체와 동일한 새로운 객체를 생성할 때 사용
복사 대입 연산자: 이미 존재하는 다른 객체의 값을 현재 객체에 대입할 때 사용
이동 생성자: 임시 객체나 곧 소멸될 rvalue 객체로부터 새로운 객체 생성할 때 사용
이동 대입 연산자: 임시 객체나 곧 소멸될 rvalue 객체의 값을 이미 존재하는 현재 객체에 대입할 때 사용
rule of three: 소멸자, 복사 생성자, 복사 대입 연산자 중 하나라도 사용자 정의 시 나머지 2개도 명시적으로 정의
rule of five: rule of three에 추가로 이동 생성자, 이동 대입 연산자도 포함하여 명시적으로 정의
rule of zero: 자원 관리를 대리하는 표준 라이브러리 클래스를 사용할 경우 rule of five를 정의하지 않아도 됨

std::shared_ptr과 std::weak_ptr의 차이점을 설명하고, std::weak_ptr이 필요한 상황(예: 순환 참조 방지)을 설명하시오.
->
std::shared_ptr: 여러 shared_ptr 인스턴스가 하나의 객체를 공유하며 관리합니다. 객체에 대한 강한 참조 역할을 하여 shared_ptr 중 하나라도 존재하는 한 객체는 소멸되지 않습니다. 객체의 소유권을 공유하며 참조 카운트를 통해 객체의 수명을 관리합니다.
std::weak_ptr: shared_ptr에 의해 관리되는 객체에 대한 약한 참조를 저장합니다. 객체의 소유권을 주장하지 않으며 객체의 강한 참조 카운트에 영향을 미치지 않습니다.
두개 이상의 객체가 서로를 shared_ptr로 강하게 참조하는 경우 순환 참조가 발생할 수 있습니다. 이 경우 서로의 참조 카운트가 0이 되지 않아 객체가 소멸되지 않고 메모리 누수를 일으킵니다. weak_ptr은 이러한 순환 참조를 끊기 위해 사용됩니다. 약한 참조는 강한 참조 카운트에 영향을 주지 않기 때문에 각 객체의 참조 카운트가 증가하지 않은 채로 약한 연결을 유지하여 순환 참조가 발생하지 않습니다.

C++의 타입 캐스팅 연산자(static_cast, dynamic_cast, reinterpret_cast, const_cast) 중 static_cast와 dynamic_cast의 차이점을 설명하시오.
->
static_cast: 컴파일 시점에 타입 변환을 수행합니다. 논리적으로 관련된 타입 간 변환에 사용됩니다.
dynamic_cast: 런타임 시점에 타입 변환을 수행합니다. 다형적 클래스 계층 구조에서 안전한 다운캐스팅에 사용됩니다.

기반 클래스 포인터를 통해 파생 클래스 객체를 삭제할 때 가상 소멸자(Virtual Destructor)가 필요한 이유를 설명하시오.
->
기반 클래스 포인터를 통해 파생 클래스 객체를 delete 연산자로 삭제할 때 소멸자가 가상 함수로 선언되어 있지 않으면 컴파일러는 포인터 타입에 해당하는 소멸자만 호출합니다. 파생 클래스의 소멸자는 호출되지 않습니다. 기반 클래스의 소멸자를 virtual로 선언하면 기반 클래스 포인터를 통해 파생 클래스 객체를 delete할 때 런타임 다형성이 적용되어 실제 객체의 타입에 해당하는 소멸자가 먼저 호출됩니다. 파생 클래스의 자원 누수를 방지하기 위해 소멸자를 virtual로 선언해야 합니다.

C++에서 override와 final 키워드의 사용 목적을 설명하시오.
->
override: 기반 클래스의 가상함수를 파생 클래스에서 재정의하여 사용하기 위함
final: 더이상 오버라이딩 되는 것을 막음

explicit 키워드가 생성자에 사용될 때 어떤 역할을 하는지 설명하시오.
->
단일 매개변수를 받는 생성자 앞에 붙이며 이 키워드를 사용하면 해당 생성자를 암시적 타입 변환을 못하도록 막는 역할을 합니다.

C++에서 lvalue와 rvalue의 개념을 간단히 설명하시오. 이동 의미론과 어떤 관련이 있나요?
->
lvalue: 계산식이 종료된 후 주소에 접근이 가능한 값
rvalue: 계산식이 종료되면 이후 주소에 접근이 불가능한 값, 일시적인 값
이동 의미론은 복사를 줄이는 데 의의를 두는데 lvalue를 rvalue로 초기화할 때 임시 변수를 만들어서 복사하지 않고 어차피 rvalue는 해당 계산식에서 사용이 끝나므로 rvalue의 주소를 lvalue로 초기화하는 것
lvalue: locator value, 메모리에 고정적인 위치를 가지고 이름이 있으며 여러 표현식에 걸쳐 지속되는 객체를 나타냅니다. 주소 연산자를 사용하여 주소를 얻을 수 있습니다. 할당 연산자의 좌측에 올 수 있어 좌측값이라고도 합니다.
rvalue: read value, 표현식이 평가되는 동안에만 임시적으로 존재하는 값입니다. 이름이 없고 메모리 위치가 고정적이지 않으며 표현식이 끝나면 소멸됩니다. 주소 연산자를 사용할 수 없고(임시 객체 rvalue 제외) 할당 연산자의 좌측에 올 수 없어 우측값이라고도 합니다.
이동 의미론은 우측값이 곧 소멸할 것이라는 점을 활용하여 자원을 복사하는 대신 이동시켜 성능을 최적화하는 개념입니다. 우측값 참조(&&)는 이러한 rvalue에 바인딩될 수 있도록 도입되었습니다. 불필요한 깊은 복사를 방지하고 자원 소유권만 효율적으로 이전할 수 있어 이동 의미론은 rvalue의 수명과 특성을 이용하여 구현되는 성능 최적화 기술입니다.

STL 알고리즘(예: std::sort, std::find, std::for_each) 중 하나를 예로 들어, 해당 알고리즘의 목적과 사용법, 그리고 대략적인 시간 복잡도를 설명하시오.
->
std::sort: 주어진 범위 내의 요소들을 오름차순 또는 사용자가 정의한 비교 기준에 따라 정렬합니다. 컨테이너의 시작과 끝에 해당하는 이터레이터를 필수로 받으며 람다함수를 이용한 추가 판별식을 입력할 수 있습니다. 내부는 퀵정렬로 구현되어 있으며 시간 복잡도는 O(N logN)입니다.

(Optional) C++ 표준 라이브러리의 <algorithm> 헤더에 포함된 유용한 함수들을 3가지 이상 예시로 들고 각 함수의 역할을 설명하시오.
->
std::find: 주어진 범위 내에서 특정 값과 일치하는 첫번째 요소를 찾습니다. 찾으면 해당 요소의 이터레이터를 반환하고 없으면 범위의 끝 이터레이터를 반환합니다. 시간 복잡도는 O(N)입니다.
std::for_each: 주어진 범위의 각 요소에 대해 지정된 함수 객체를 한번씩 적용합니다.
std::copy: 한 범위의 요소들을 다른 위치로 복사합니다. 대상 범위의 시작 이터레이터를 인자로 받습니다.

(Optional) C++에서 네임스페이스(Namespace)를 사용하는 주된 목적은 무엇인가요?
->
프로그램 내에서 사용되는 변수, 함수, 클래스 등의 이름들이 충돌하는 것을 방지하고 코드를 논리적으로 그룹화하여 관리하기 위함입니다.



큐(Queue)와 스택(Stack) 자료구조의 차이점을 설명하고, 각각 어떤 상황에 적용될 수 있는지 간단한 예시를 드시오. (LIFO/FIFO 언급)
->
큐: FIFO 구조를 따르는 자료구조입니다. 먼저 삽입된 데이터가 먼저 삭제됩니다. 삽입은 후면에서 삭제는 전면에서 이루어집니다. 작업 대기열, 메세지 처리, BFS 등에 적용될 수 있습니다.
스택: LIFO 구조를 따르는 자료구조입니다. 가장 나중에 삽입된 데이터가 먼저 삭제됩니다. 삽입과 삭제 모두 최상단에서 이루어집니다. 함수 호출 스택, 괄호 짝 맞추기, DFS 등에 적용될 수 있습니다.

힙(Heap) 자료구조(최대 힙 또는 최소 힙)의 개념과 우선순위 큐(Priority Queue) 구현에 어떻게 사용될 수 있는지 설명하시오.
->
힙은 완전 이진 트리 형태를 가지며 힙 속성을 만족하는 트리기반 자료구조입니다. 최대힙은 부모노드의 값이 자식노드의 값보다 항상 크거나 같고 최상단노드에 가장 큰 값이 저장되며 최소힙은 부모노드의 값이 자식노드의 값보다 항상 작거나 같고 최상단노드에 가장 작은 값이 저장됩니다.
우선순위큐는 데이터가 삽입된 순서와 상관없이 우선순위가 가장 높은 데이터가 먼저 나오는 추상적인 자료구조입니다. 힙은 이러한 우선순위큐를 효율적으로 구현하는데 사용되는 가장 일반적인 방법입니다.데이터가 삽입되면 힙 속성을 유지하도록 O(logN)의 힙 재구성이 일어납니다. 가장 우선순위가 높은 데이터를 가져올 때 힙의 루트노드를 제거하고 O(logN)으로 힙을 재구성합니다. 이를 통해 우선순위에 따라 효율적으로 데이터를 관리하고 접근할 수 있습니다.

검색 알고리즘 중 이진 탐색(Binary Search)이 가능한 전제 조건과 시간 복잡도를 설명하고, 순차 탐색(Linear Search)과 비교하시오.
->
이진탐색: 데이터를 담은 컨테이너가 반드시 정렬되어있어야 합니다. 검색의 범위를 절반씩 줄여나가며 원하는 값을 찾는 방식입니다. 시간 복잡도는 O(logN)입니다.
순차탐색: 데이터 정렬이 필요없고 어떤 컨테이너든 가능한 방법입니다. 처음부터 끝까지 순서대로 요소를 확인하며 원하는 값을 찾습니다. 시간 복잡도는 O(N)입니다.
이진탐색은 정렬되어있어야 하는 조건이 있지만 순차탐색보다 훨씬 빠릅니다. 정렬상태를 유지하기 어렵다면 순차탐색이 적합할 수 있습니다.

대표적인 정렬 알고리즘(예: 퀵 정렬, 병합 정렬)의 평균 시간 복잡도 O(N log N)과 버블 정렬/선택 정렬의 평균 시간 복잡도 O(N^2)의 차이를 설명하시오.
->
O(NlogN) 정렬(퀵, 병합, 힙): 정렬 알고리즘 중 이론적으로 최적의 평균 시간 복잡도입니다. 분할 정복 및 힙 구조를 활용합니다.
O(N^2) 정렬(버블, 선택, 삽입): 데이터 크기 N이 커질수록 시간이 N의 제곱에 비례하여 증가합니다. 주로 중첩된 두개의 루프 구조에서 나타납니다.

경로 탐색 알고리즘 중 A*(A-Star) 알고리즘의 기본적인 아이디어(휴리스틱 사용)를 설명하시오.
->
기본적인 아이이더: A* 알고리즘은 최단 경로를 찾는 그래프 탐색 알고리즘입니다. 다익스트라 알고리즘을 확장한 것으로 각 노드를 평가할 때 시작 노드로부터 현재 노드까지의 실제 비용과 현재 노드로부터 목표 노드까지의 예상 비용을 합산한 값을 사용하여 탐색 방향을 결정합니다.
휴리스틱 사용: A* 알고리즘의 핵심은 휴리스틱 함수 h(n)의 사용입니다. 휴리스틱은 목표 노드까지 남은 거리에 대한 추정치 또는 경험적인 지식입니다. A*은 f(n)값이 가장 낮은 노드를 우선적으로 탐색 큐(우선순위 큐)에 넣어 탐색을 진행합니다. 휴리스틱이 목표 방향으로 탐색을 효율적으로 유도하기 때문에 다익스트라 알고리즘처럼 모든 가능한 경로를 탐색하지 않고도 많은 경우에 더 빠르게 최단 경로를 찾을 수 있습니다.

그래픽스에서 Z-버퍼링(Z-Buffering)이 필요한 이유와 역할에 대해 설명하시오.
->
3D 그래픽스에서 여러 객체가 카메라로부터의 거리가 다를 때 어떤 객체가 다른 객체를 가리는지 올바르게 처리하여 정확한 깊이 순서대로 화면에 그려지도록 해야 합니다. Z-버퍼링은 이러한 가시성 문제를 해결하기 위한 기술로 각 픽셀에 대해 깊이 값을 저장하는 Z-버퍼(Depth Buffer)라는 별도의 버퍼를 사용합니다. 프래그먼트의 깊이값을 대조하여 카메라에 가장 가까운 객체가 픽셀에 표현되도록 결정합니다.

쉐이더(Shader)의 종류(예: Vertex Shader, Pixel/Fragment Shader)와 각각의 기본적인 역할을 설명하시오.
->
VS: 각 정점마다 한번씩 실행됩니다. 입력된 정점의 위치를 3D 공간에서 2D 화면 공간으로 변환하는 것입니다.
PS: 각 픽셀에 해당되는 프래그먼트마다 한번씩 실행됩니다. 해당 픽셀에 표현될 최종 색상값을 계산하는 것입니다.

네트워크 게임에서 지연(Latency)과 지터(Jitter)가 게임 플레이에 미치는 영향에 대해 설명하시오.
->
지연은 클라이언트에서 보낸 데이터가 서버에 도착하여 처리된 후 다시 클라이언트로 돌아오기까지 걸리는 시간입니다. 지연이 높으면 플레이어의 입력에 대한 반응이 느려지고 다른 플레이어나 게임 세계의 변화를 늦게 보게 됩니다.
지터는 패킷 지연시간의 변동성입니다. 패킷이 도착하는 간격이 일정하지 않고 불규칙한 현상입니다. 지터가 높으면 게임의 상태 업데이트가 불규칙해져 움직임이나 상태 변화, 보간 및 예측이 불명확해지는 문제가 발생합니다.

네트워크 통신 시 데이터 직렬화(Serialization)와 역직렬화(Deserialization) 과정이 왜 필요한지 설명하시오.
->
네트워크를 통해 데이터를 전송하거나 파일에 저장하려면 메모리 내의 복잡한 구조를 바이트의 연속적인 스트림 형태로 변환해야 합니다. 또한 전송받거나 저장된 바이트 스트림을 다시 원래 메모리 내 객체나 자료구조 형태로 변환해야 하는데 이를 직렬화/역직렬화라고 합니다. 네트워크 통신이 필요한 멀티플레이 게임에서 서버와 클라이언트 간에 데이터를 주고받기 위해 필요하고 게임의 저장과 로딩에도 사용됩니다. JSON등의 개방형 데이터 포맷을 이용하여 데이터 호환성을 확보할 수도 있습니다.

클라이언트-서버 모델에서 게임 상태 동기화 시 발생할 수 있는 문제점(예: 클라이언트 예측, 보간)과 이를 해결하기 위한 접근 방식에 대해 간략히 설명하시오.
->
네트워크 환경에 따라 지연과 불일치 문제가 발생할 수 있습니다. 이를 해결하기 위해 클라이언트 예측, 서버 조정, 보간, 추정 등의 방식으로 접근하여 문제를 해결할 수 있습니다.



언리얼 엔진의 멀티플레이어 환경에서 GameMode, GameState, PlayerController, PlayerState는 각각 어떤 역할을 담당하나요?
->
GameMode: 서버에만 존재하는 클래스로 게임의 규칙과 흐름을 정의합니다. 플레이어 접속 처리, 폰 및 플레이어 컨트롤러 스폰, 게임 시작/종료 관리, 점수 관리, 게임 상태 변경등의 역할을 합니다.
GameState: 서버에서 관리되며 모든 클라이언트로 복제되는 클래스입니다. 게임의 전체적인 상태 중 모든 플레이어가 알아야 하는 정보를 동기화하는데 사용됩니다. 게임 시간, 현재 맵 이름, 팀 점수, 모든 플레이어의 PlayerState 목록 등이 관리됩니다.
PlayerController: 플레이어의 입력을 받고 해당 플레이어의 폰을 제어하는 역할을 합니다. 서버와 클라이언트 모두에 해당 플레이어의 PlayerController 인스턴스가 존재합니다.
PlayerState: 서버에서 관리되며 해당 플레이어의 PlayerController 및 모든 클라이언트로 복제되는 클래스입니다. 특정 플레이어와 관련된 상태 중 다른 모든 플레이어가 알아야 하는 정보를 동기화하는 데 사용됩니다. 플레이어 이름, 현재 점수, 킬/데스 카운트, 핑 값 등이 관리될 수 있습니다.

UMG(Unreal Motion Graphics)의 기본적인 사용 목적과 UI 구현 시 C++ 코드와 어떻게 연동하는지 설명하시오.
->
언리얼 엔진에서 게임 내 사용자 인터페이스 요소를 시각적으로 디자인하고 구현히가 위한 시스템입니다. 다양한 UI 위젯을 만들 수 있습니다. UUserWidget 클래스를 상속받아 C++ 기반의 커스텀 위젯 클래스를 생성할 수 있습니다. CreateWidget 함수를 이용해서 BP 클래스를 기반으로 위젯 인스턴스를 생성하고 화면에 추가하거나 제거하는 등 관리를 수행합니다. UPROPERTY, UFUNCTION 매크로를 활용하여 위젯 내 요소에 접근하거나 위젯 디테일 패널에 변수와 함수를 노출시킬 수 있습니다.

애니메이션 시스템에서 스켈레탈 메시(Skeletal Mesh)와 애니메이션 블루프린트(Animation Blueprint)의 기본적인 역할을 설명하시오.
->
스켈레탈 메시: 애니메이션을 적용할 수 있는 3D 모델의 타입입니다. 모델 자체의 지오메트리와 함께 모델을 변형시키기 위한 뼈대 구조(Skeleton) 정보를 포함하고 있습니다.
애니메이션 블루프린트: 스켈레탈 메시의 애니메이션을 제어하는데 사용되는 특별한 유형의 블루프린트입니다. 스켈레탈 메시에 어떤 애니메이션 클립을 어떻게 재생하고 블렌딩할지 캐릭터의 움직임 상태에 따라 애니메이션을 어떻게 전환할 지 등의 로직을 정의합니다.

언리얼 엔진의 피직스(Physics) 엔진에서 콜리전(Collision) 설정 시 사용되는 다양한 충돌 타입(예: Block, Overlap, Ignore) 및 채널(Channel) 개념에 대해 설명하시오.
->
콜리전: 게임 내 객체들이 서로 물리적으로 상호작용하거나 접촉을 감지하는 시스템입니다. 피직스 엔진을 사용하여 콜리전을 처리합니다.
충돌 타입: 특정 충돌 이벤트가 발생했을 때 해당 객체가 어떻게 반응할지를 정의합니다.
Block: 충돌이 발생하면 객체의 움직임을 멈추고 물리적인 힘을 적용하는 가장 기본적인 반응입니다.
Overlap: 충돌이 발생하더라도 객체의 움직임을 막지 않고 통과시키지만 충돌 감지 이벤트를 발생시킵니다.
Ignore: 충돌을 완전히 무시하고 어떤 반응도 하지 않습니다.
채널: 콜리전 시스템에서 객체의 타입을 분류하기 위한 카테고리입니다. 엔진 기본 채널과 사용자 정의 채널이 있습니다. 각 객체는 어떤 채널에 속할 지 정할 수 있고 각각의 채널의 충돌 시 어떻게 반응할 지 설정할 수 있습니다.

언리얼 엔진 빌드 과정에서 UBT(Unreal Build Tool)와 UHT(Unreal Header Tool)는 각각 어떤 역할을 담당하나요?
->
UBT는 언리얼 엔진의 C# 기반의 빌드시스템입니다. .uproject 파일과 각 모듈의 .build.cs 파일을 읽어 프로젝트 설정을 파악하고 이를 토대로 빌드를 수행합니다.

언리얼 엔진에서 비동기 로딩(Asynchronous Loading)이 필요한 이유와 AssetManager를 활용한 에셋 로딩 방식에 대해 간략히 설명하시오.
->
비동기 로딩은 로딩 작업을 별도의 스레드에서 백그라운드로 수행하여 메인 스레드인 게임스레드가 멈추지않고 계속 실행되도록 합니다. 로딩 중에도 UI를 표시하거나 제한적인 게임 플레이를 가능하게 하여 끊김 없는 게임플레이 경험을 제공합니다.
AssetManager는 에셋을 Primary Asset Type과 Secondary Asset으로 분류하고 각 에셋의 의존성을 파악합니다. 이 정보를 바탕으로 에셋을 효율적으로 로딩하고 관리합니다. RequestAsyncLoad 함수를 통해 비동기 로딩에 대한 요청을 할 수 있으며 함수를 호출한 후 전달받은 핸들을 통해 비동기 로딩의 진행상황 및 결과에 대한 예외를 추가할 수 있습니다.

언리얼 엔진에서 성능 프로파일링 시 CPU 바틀넥과 GPU 바틀넥을 구분하고 진단하는 기본적인 방법에 대해 설명하시오.
->
성능 문제를 해결하려면 병목 지점이 CPU에 있는지 GPU에 있는지 먼저 파악하는 것이 중요합니다. 일반적으로 stat unit 콘솔 명령을 이용해서 시간값을 대조하여 Frame 시간의 점유율에 따라 어느 지점에 있는지 파악합니다. 확실한 확인을 위해 Session Frontend를 사용하여 각 스레드를 보며 Sleep, Wait 여부를 체크하여 병목 지점을 찾습니다.

언리얼 엔진의 플러그인(Plugin)과 모듈(Module) 시스템의 차이점 및 활용 목적에 대해 설명하시오.
->
모듈은 코드 그룹화 및 빌드 시스템의 단위이며 플러그인은 기능 패키징 및 배포/확장의 단위입니다. 플러그인은 하나 이상의 모듈을 포함할 수 있습니다. 모듈을 대규모 코드 베이스를 가능한 작은 단위로 분할하여 관리 편의를 제공하는 데 있고 플러그인은 재사용 가능한 기능 단위의 그룹화를 주 목적으로 모듈보다 상위 개념이며 모듈의 묶음과 기타 리소스를 포함하여 배포 가능한 형태로 만듭니다.

레벨 스트리밍(Level Streaming) 기능이 필요한 이유와 사용 시 장점에 대해 설명하시오.
->
매우 넓거나 복잡한 게임 월드를 만들 때 전체 레벨을 한번에 메모리에 로딩하고 관리하는 것이 현실적으로 불가능하거나 비효율적입니다. 레벨 스트리밍은 이러한 문제를 해결하기 위해 필요합니다. 하나의 거대한 레벨을 여러개의 작은 하위 레벨로 분할하고 플레이어의 위치나 게임 상태에 따라 필요한 하위 레벨만 메모리에 로딩하고 불필요해진 하위 레벨은 언로딩하는 기능입니다. 영구 레벨(Persistent Level)은 항상 로드되어 있으며 다른 스트리밍 레벨들을 관리하는 역할을 합니다.
레벨 스트리밍 기능을 이용하면 필요한 레벨만 로드하여 메모리 사용량을 감소시킬 수 있고 로딩 시간이 개선되며 로딩 화면 없이 자연스러운 월드 이동을 가능하게 합니다. 개발 측면에서 하위 레벨 단위의 개발이 가능해지므로 협업의 효율성이 증가하는 것을 기대할 수 있습니다.

언리얼 엔진 C++ 코드 작성 시 일반적으로 고려할 수 있는 성능 최적화 팁(예: Tick 함수 최적화, 반복문 최적화, 객체 생성 최소화 등)을 3가지 이상 제시하시오.
->
Tick: 매프레임 실행될 필요가 있는 함수인지 판별이 중요하며 그럴 필요가 없는 함수는 제거 후 다른 방식으로 구현합니다.
loop: 어떤 컨테이너가 반복에서 효율적일지 고려하여 선택해 사용하고 continue, break를 잘 활용해서 더이상 반복이 필요없는 경우 건너뛰거나 종료하도록 합니다.
객체 생성/소멸: 게임 플레이 중 빈번하게 생성되고 파괴되는 객체(주로 Projectile)는 생성과 소멸에 대한 오버헤드가 크므로 이러한 객체들은 미리 일정 개수를 생성해두고 재활용하는 오브젝트 풀링 기법을 사용하여 성능을 최적화할 수 있습니다. 특정 지역에서 몬스터의 스폰 등이 이에 해당될 수 있습니다.

(Optional) 특정 타입의 액터를 월드에서 찾는 방법(UGameplayStatics::GetAllActorsOfClass, GetWorld()->GetIterator)과 차이점에 대해 설명하시오.
->
GetAllActorsOfClass 함수는 UGameplayStatics 헬퍼 클래스의 스태틱 함수입니다. 찾고자 하는 액터 클래스를 인자로 넘기면 해당 클래스 또는 파생 클래스의 모든 액터를 찾아서 TArray로 넘겨줍니다. 사용이 간편하지만 월드 내 모든 액터를 순회하며 검사하므로 사용량에 따라 성능 저하가 발생할 수 있습니다.
GetActorIterator 함수는 월드 내 모든 액터를 순회할 수 있는 이터레이터를 얻습니다. 반복문과 함께 사용하여 모든 액터를 순회하고 Cast<>를 통해 원하는 타입의 액터를 필터링할 수 있습니다. 이터레이터를 통해 접근하므로 메모리 오버헤드가 적기에 GetAllActorsOfClass 보다 성능상 유리할 수 있습니다.

(Optional) 언리얼 엔진 로깅 시스템(UE_LOG)의 사용법과 로그 카테고리, 중요도 레벨에 대해 설명하시오.
->
UE_LOG(LogCategory, LogLevel, FormatString, ...) 의 형식으로 사용합니다. LogCategory는 로그가 속할 카테고리를 지정하고 LogLevel은 로그의 중요도 레벨을 지정합니다. FormatString은 로그의 메세지의 내용과 형식을 지정하는 FString 또는 TCHAR 문자열입니다. 로그카테고리는 임시테스트용으로 LogTemp가 자주 사용되며 중요도 레벨은 Verbose, Display, Log, Warning, Error, Fatal 등이 있습니다.