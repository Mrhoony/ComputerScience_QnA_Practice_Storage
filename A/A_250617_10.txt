핵심 클래스 계층 및 역할: 언리얼 엔진의 Gameplay Framework를 구성하는 핵심 클래스들(예: UObject, AActor, UActorComponent, APawn, ACharacter, AController, AGameModeBase, AGameStateBase 등) 간의 상속 계층과 각각의 주요 역할에 대해 설명하시오.
->
UObject는 UE의 모든 객체의 최상위 기반 클래스입니다. 리플렉션, 가비지컬렉션, 시리얼라이제이션, 리플리케이션, 프로퍼티 시스템 등 UE의 핵심 기능을 제공하는 최소 단위입니다. 게임 플레이와 직접 관련 없는 데이터나 유틸리티 클래스도 UObject를 상속합니다.
AActor는 UObject를 상속받는 클래스로 게임 월드 내 배치되거나 스폰될 수 있는 모든 객체의 기반입니다. 위치, 회전, 스케일 정보를 가지며 컴포넌트를 소유할 수 있습니다. 플레이어 캐릭터, NPC, 투사체, 아이템, 건물 등이 모두 액터입니다.
UActorComponent는 UObject를 상속받는 클래스로 액터에 특정 기능과 행동을 추가하는 모듈화된 블록입니다. 자체적으로 위치를 가지지 않고 항상 액터에 부착되어 액터의 기능을 확장합니다. (USkeletalMeshComponent, UCharacterMovementComponent, UCameraComponent 등)
APawn은 AActor를 상속받는 클래스로 컨트롤러에 의해 소유될 수 있는 액터의 기반입니다. 플레이어나 AI가 조작할 수 있는 게임 내 객체입니다. 기본적인 움직임 입력 처리 매커니즘을 가집니다.
ACharacter는 APawn을 상속받는 클래스로 인간형 캐릭터와 같이 복잡한 움직임을 필요로 하는 Pawn의 기반입니다. UCharacterMovementComponent와 UCapsuleComponent를 내장하여 복잡한 캐릭터 움직임과 충돌 처리를 쉽게 구현할 수 있도록 돕습니다.
AController는 AActor를 상속받는 클래스로 Pawn을 소유하고 조종하는 논리적 엔티티입니다. 사용자 입력이나 AI 로직을 받아 Pawn에게 행동을 지시합니다. 직접적으로 물리적 표현은 없습니다.
APlayerController는 AController를 상속받아 플레이어의 입력을 받아 Pawn을 제어하는 역할을 합니다. UI 상호작용, 카메라 제어 등 플레이어별 고유 로직을 처리합니다.
AAIController는 AController를 상속받아 AI 로직에 따라 Pawn을 제어하는 역할을 합니다. 행동트리(Behavior Tree), 감각 시스템(PerceptionComponent) 등 AI 관련 기능을 담당합니다.
AGameModeBase는 AInfo를 상속받는 클래스로 게임의 규칙, 승리 조건, 스폰 로직 등 게임 전반의 규칙을 정의하고 관리합니다. 서버에서만 존재하고 실행되며 클라이언트에는 복제되지 않습니다.
AGameStateBase는 AInfo를 상속받는 클래스로 게임의 전반적인 상태 정보(스코어, 게임 시간, 게임 단계 등)를 저장하고 관리합니다. 서버에서 생성되어 모든 클라이언트에 복제되므로 클라이언트들은 현재 게임 상태를 알 수 있습니다.
APlayerState는 AInfo를 상속받는 클래스로 각 특정 플레이어와 관련된 상태 정보(이름, 점수, 팀, 인벤토리 등)를 저장하고 관리합니다. 서버에서 생성되어 해당 플레이어를 포함한 모든 클라이언트에 복제됩니다.

AActor와 UActorComponent: AActor와 UActorComponent의 주된 차이점은 무엇이며, 언리얼 엔진이 컴포넌트 기반 아키텍처를 채택함으로써 게임 객체 구성 및 재사용성 측면에서 얻는 이점은 무엇인지 설명하시오.
->
AActor는 게임 세계에 독립적으로 존재하고 스폰될 수 있는 객체이며 고유한 트랜스폼을 가집니다. 반면 UActorComponent는 자체적으로 존재할 수 없으며 항상 AActor에 부착되어 액터의 기능을 확장하는 기능 블록입니다.
AActor는 UWorld에 직접 스폰되지만 UActorComponent는 액터의 내부 멤버로서 존재합니다.
AActor는 액터 간의 부착을 통해 계층 구조를 형성할 수 있지만 UActorComponent는 액터의 자식으로서만 존재하며 컴포넌트 간에도 부착을 통해 계층을 형성할 수 있습니다.
컴포넌트 기반 아키텍처를 채택하는 경우 상속 계층의 제약 없이 액터에 필요한 기능을 동적으로 추가, 제거, 교체할 수 있습니다. 각 컴포넌트는 독립적인 기능을 캡슐화하므로 특정 기능을 여러 종류의 액터에서 중복 없이 재사용할 수 있습니다. 게임 객체의 기능이 독립적인 컴포넌트로 분리되므로 각 컴포넌트의 개발, 테스트, 유지보수가 용이합니다. 프로그래머가 컴포넌트를 개발하면 디자이너나 아티스트는 코드 수정 없이 에디터에서 컴포넌트를 조합하여 다양한 게임 객체를 만들 수 있습니다. 액터는 컴포넌트의 구체적인 구현에 의존하기보다 특정 인터페이스를 가진 컴포넌트를 사용하는 방식으로 느슨하게 결합됩니다.

AGameModeBase와 AGameStateBase: AGameModeBase와 AGameStateBase는 각각 게임의 어떤 정보를 담당하며, 이 두 클래스가 멀티플레이어 환경에서 게임 규칙 및 게임 전반의 상태를 어떻게 관리하고 클라이언트와 서버 간에 어떻게 동기화되는지 설명하시오.
->
AGameModeBase는 게임의 규칙 및 로직(승리/패배 조건, 스폰 지점 및 플레이어 스폰 로직, 라운드 관리, 게임 상태 전환(시작, 진행중, 중료 등), 데미지 계산 규칙 등)을 정의합니다. 기본값으로 사용할 DefaultPawnClass, PlayerControllerClass, HUDClass, PlayerStateClass, GameStateClass 등을 설정합니다. AGameModeBase는 서버에서만 존재하고 실행됩니다. 클라이언트에는 존재하지 않으며 복제되지 않습니다. 이는 게임의 중요한 규칙과 권한이 서버에만 존재하여 치트 방지 및 게임의 일관성을 유지하는데 필수적입니다. 클라이언트가 게임 규칙을 변경하는 것을 막고 멀티플레이어를 관리합니다.
AGameStateBase는 게임의 전반적인 현재 상태(현재 스코어, 남은 게임 시간, 현재 게임 단계, 월드에서 파괴된 오브젝트 수 등)와 같이 게임 플레이와 관련된 모든 클라이언트가 알아야하는 동기화된 정보를 저장합니다. AGameStateBase는 서버에서 생성된 후 모든 연결된 클라이언트에 자동으로 복제됩니다. 이를 통해 클라이언트는 서버의 권한 아래에서 최신 게임 상태 정보를 실시간으로 받아보고 UI 업데이트, 로컬 예측 등에 활용할 수 있습니다. 클라이언트는 AGameStateBase의 상태를 변경할 수 없으며 오직 서버만이 AGameStateBase의 상태를 변경하고 이를 클라이언트들에게 전파합니다.

AController 계층: AController는 무엇이며, APlayerController와 AAIController로 나뉘는 주된 이유와 각각의 역할을 설명하시오. 또한, AController가 APawn (또는 ACharacter)을 소유(Possess)하고 제어하는 메커니즘을 설명하시오.
->
AController는 AActor를 상속받는 클래스로 게임 월드 내의 Pawn 객체를 소유하고 조종하는 논리적 존재입니다. 직접적인 물리적 표현이나 3D 모델을 가지지 않습니다. APawn과 AController는 분리되어 있어 APawn은 조종 가능한 몸체, AController는 두뇌 역할을 합니다.
APlayerController는 사용자 입력(키보드, 마우스, 게임패드 등) 처리와 UI 상호작용 등 플레이어에게 고유한 기능을 담당하기 위함입니다. 클라이언트의 입력을 받아 자신이 소유한 Pawn에게 움직임이나 행동 명령을 내립니다. 게임 메뉴, HUD, 카메라 제어, 인벤토리 관리 등 플레이어별 인터페이스와 로직을 처리합니다. 멀티플레이어 환경에서는 각 클라이언트마다 하나의 APlayerController가 존재합니다.
AAIController는 인공지능(AI) 로직에 따라 Pawn을 자율적으로 조종하는 기능을 담당하기 위함입니다. 행동 트리(Behavior Tree), EQS(Environment Query System), 네비게이션 시스템 등을 사용하여 AI Pawn이 게임 세계에서 길을 찾고 목표를 추적하고 의사결정을 내리는 등 자율적인 행동을 수행하도록 지시합니다.
AController가 APawn을 소유(Possess)한다는 것은 AController가 특정 APawn을 자신의 것으로 지정하여 제어 권한을 얻는 과정입니다. AController의 Possess(APawn* InPawn) 함수를 호출하여 이루어집니다. 이 함수가 호출되면 AController는 InPawn의 Controller 변수에 자신을 설정하고 InPawn의 OnPossess() 함수가 호출됩니다.
제어 매커니즘의 단계는 우선 AController는 플레이어 입력 또는 AI 로직을 받습니다. 이 입력/로직을 기반으로 AController는 자신이 소유한 APawn의 공개된 함수를 호출하거나 Pawn 내부에 있는 UCharacterMovementComponent와 같은 컴포넌트의 함수를 호출하여 Pawn에게 실제적인 행동을 지시합니다. APawn 또는 ACharacter는 이 명령을 받아 실제로 움직이거나 공격하거나 다른 행동을 수행합니다.
컨트롤러와 Pawn이 분리되어 있어 동일한 Pawn을 다른 종류의 컨트롤러가 조종할 수 있습니다. 예를 들어 게임 중 플레이어가 캐릭터에게 내려서 다른 캐릭터에 빙의(Possess)할 수 있습니다. 또한 동일한 AI 로직을 여러 종류의 AI Pawn에 적용할 수 있습니다.

APawn과 ACharacter: APawn과 ACharacter의 차이점을 설명하고, ACharacter가 APawn을 상속받으면서 추가적으로 제공하는 주요 기능(예: CharacterMovementComponent, CapsuleComponent)은 무엇인지, 그리고 어떤 상황에 APawn 대신 ACharacter를 사용하는 것이 적합한지 설명하시오.
->
APawn은 AController에 의해 소요될 수 있는 가장 기본적인 몸체 액터입니다. 기본적인 입력 처리 매커니즘만 제공하며 자체적으로 복잡한 움직임이나 충돌 처리 로직은 없습니다.
ACharacter는 APawn을 상속받는 클래스로 인간형 캐릭터와 같이 복잡한 걷기, 뛰기, 점프 등의 움직임이 예상되는 Pawn을 위해 특별히 설계된 클래스입니다.
ACharacter가 APawn을 상속받으면서 추가적으로 제공하는 주요 기능으로는 UCharacterMovementComponent, UCapsuleComponent, USkeletalMeshComponent로 이를 이용해 인간형 캐릭터의 복잡한 움직임을 처리하는 모든 로직과 주요 충돌 영역을 정의, 스켈레탈 메쉬를 위한 슬롯을 제공합니다.
인강형 캐릭터 또는 복잡한 이동이 필요한 캐릭터는 ACharacter를 사용하고 간단한 이동 로직의 비인간형 객체의 경우 APawn을 이동이 없는 경우라면 AActor를 사용하는 것이 적합할 수 있습니다.

AActor의 수명 주기: 언리얼 엔진 Gameplay Framework에서 AActor의 주요 수명 주기 함수들(예: BeginPlay(), Tick(), EndPlay(), OnDestroyed())과 그 호출 순서에 대해 설명하시오. 각 함수에서 주로 어떤 로직을 처리해야 하는지 예시를 드시오.
->
AActor는 게임 월드에 스폰되고 소멸될 때까지 일련의 정해진 수명 주기를 가집니다. 주요 함수는 다음과 같습니다.
생성자(Constructor)는 액터 클래스의 기본 객체가 생성될 때와 실제 월드에 액터 인스턴스가 스폰될 때 호출됩니다. 컴포넌트 생성 및 부착, 기본 프로퍼티 값 설정, 초기화 등 매우 가벼운 초기화만 수행되어야 합니다. 아직 다른 액터나 월드 상태에 접근할 수 없습니다.
PostInitializeComponents()는 모든 컴포넌트가 생성되고 부착된 후 호출됩니다. 컴포넌트 간의 상호 참조 설정, 컴포넌트의 초기 상태 설정 등 컴포넌트 초기화 완료 후 액터 자체의 추가 초기화를 수행합니다.
BeginPlay()는 액터가 게임 월드에 성공적으로 배치되거나 스폰된 후 처음으로 게임 플레이가 시작될 때 한번만 호출됩니다. 게임 플레이에 필요한 모든 초기화 작업, 다른 액터와의 상호작용 시작, 타이머 설정, 이벤트 바인딩, 초기 UI 생성, 사운드 재생 등 게임 로직의 시작점이 됩니다.
Tick(float DeltaTime)은 액터의 Tick함수가 활성화되어 있다면 매 프레임마다 호출됩니다. 시간에 따라 연속적으로 업데이트되어야 하는 로직, 움직임, 애니메이션 업데이트, 상태 체크, 물리 상호작용, AI 의사 결정, 입력 처리 등 게임의 핵심 업데이트 로직을 처리합니다.
EndPlay(const EEndPlayReason::Type EndPlayReason)은 액터가 월드에서 제거되거나 레벨이 전환되거나 게임이 종료될 때 호출됩니다. 리소스 해제, 이벤트 언바인딩, 타이머 해제, 다른 액터에게 소멸 알림 등 액터가 소멸되기 전에 필요한 정리 작업을 수행합니다.
OnDestroyed()는 액터가 엔진의 GC에 의해 메모리에서 완전히 제거되기 직전에 호출됩니다. (에디터에서는 바로 삭제) 주로 내부적인 정리 작업에 사용되며 일반적인 게임 로직에서는 EndPlay가 더 자주 사용됩니다.

입력 처리 흐름: 언리얼 엔진에서 사용자 입력(Input)이 발생했을 때, APlayerController, APawn(또는 ACharacter), UActorComponent 등 어떤 클래스들을 거쳐 입력 이벤트가 처리되는지 그 기본적인 흐름과 우선순위를 설명하시오.
->
엔진은 키보드, 마우스, 게임패드 등 하드웨어로부터 원시 입력 이벤트를 받습니다.
APlayerController 내부에 있는 UPlayerInput 클래스가 원시 입력을 받아 InputActions 및 InputAxes에 따라 입력 이벤트를 매핑합니다. 이 매핑은 프로젝트 설정에서 정의됩니다.
매핑된 입력 이벤트는 가장 먼저 해당 APlayerController 인스턴스로 전달됩니다. APlayerController는 자신의 InputComponent에 바인딩된 입력 이벤트를 처리할 우선순위 1위를 가집니다. (UI 상호작용, 메뉴 열기, 카메라 제어 등 플레이어 자체에 관련된 입력을 처리)
APlayerController가 특정 APawn을 소유하고 있다면 처리되지 않은 입력 이벤트는 해당 APawn으로 전달됩니다. APawn은 PlayerController 다음으로 높은 우선순위를 가집니다. (캐릭터 이동, 점프, 공격, 상호작용 등 캐릭터의 행동에 직접 관련된 입력을 처리)
APawn이 처리하지 않은 입력 이벤트는 해당 액터에 부착된 UActorComponent들로 순차적으로 전달됩니다. 컴포넌트는 일반적으로 액터보다 낮은 우선순위를 가집니다. (특정 컴포넌트의 기능과 관련된 입력을 처리)
요약하면 PlayerController -> Pawn -> Actor(Root Component) -> ActorComponent 순으로 입력이 처리됩니다.

APlayerState의 역할: APlayerState는 무엇이며, 멀티플레이어 게임에서 특정 플레이어와 관련된 고유 데이터(예: 점수, 이름, 체력, 인벤토리 상태 등)를 어떻게 관리하고 서버에서 클라이언트들에게 효율적으로 복제하는 데 사용되는지 설명하시오.
->
APlayerState는 AInfo를 상속받는 클래스로 멀티플레이어 게임에서 각 특정 플레이어와 관련된 고유하고 영구적인 상태 데이터를 저장하고 관리하는 액터입니다. 게임 월드 내의 물리적인 표현은 없지만 논리적으로 게임 플레이 동안 플레이어와 연결되어 있습니다.
플레이어 이름, 점수, 킬/데스 비율, 팀 정보, 핑 정보, 현재 체력, 탄약, 인벤토리 상태, 레벨, 경험치, 커스터마이징 정보 등의 플레이어 고유 정보를 담당합니다.
APlayerState는 서버에서 생성되고 관리됩니다. 각 연결된 플레이어마다 서버에 해당 플레이어의 APlayerState 인스턴스가 존재합니다. 서버의 APlayerState 인스턴스에 저장된 모든 복제로 지정된 프로퍼티는 자동으로 모든 클라이언트에 복제됩니다. 각 클라이언트는 서버에서 받은 APlayerState 정보를 자신의 PlayerState 객체에 미러링하여 가집니다. APlayerState에 플레이어 고유 데이터를 저장하고 복제하면 APawn이 소멸되거나 플레이어가 다른 Pawn에 빙의하더라도 플레이어의 데이터가 보존됩니다. 또한 모든 클라이언트가 이 정보를 가지므로 각 클라이언트에서 다른 플레이어의 이름, 점수 등을 효율적으로 표시할 수 있습니다. 서버에서 APlayerState의 복제된 프로퍼티를 변경하면 그 변경 사항은 자동으로 모든 클라이언트에 동기화됩니다. 클라이언트는 이 복제된 데이터를 읽을 수는 있지만 직접 수정할 수는 없습니다.

게임플레이 프레임워크의 확장성 및 유연성: 언리얼 엔진의 Gameplay Framework가 게임 개발자에게 제공하는 확장성과 유연성(예: GameMode 교체, Controller 타입 변경, 커스텀 컴포넌트 추가)은 어떤 상황에서 유용하게 활용될 수 있는지 구체적인 예시와 함께 설명하시오.
->
GameMode 교체는 싱글 플레이, 팀 데스매치, 깃발 뺏기, 배틀로얄 등 다양한 게임모드를 구현할 때 유용합니다. (게임 내 다양한 모드 교체) Controller의 타입 변경은 플레이어가 조종하는 객체를 변경하거나 AI 행동 방식에 따라 다른 AI 로직을 적용할 때 유용합니다. (GTA 탈것 교체) 커스텀 컴포넌트 추가는 액터와 컴포넌트는 has-a 합성 관계이기 때문에 기존 액터에 새로운 기능을 추가하거나 특정 기능을 모듈화하여 재사용성을 높일 때 유용합니다.

UWorld의 역할: UWorld는 언리얼 엔진 Gameplay Framework에서 어떤 핵심적인 역할을 하며, AActor들이 존재하는 공간으로서 어떻게 관리되고 게임의 전반적인 상태(예: 레벨 전환, 시간 관리, 게임 객체 등록/삭제)를 제어하는지 설명하시오.
->
UWorld는 UE Gameplay Framework에서 모든 AActor들이 존재하는 물리적이고 논리적인 게임 공간을 나타내는 핵심 객체입니다. 게임 내 모든 레벨, 액터, 컴포넌트, 물리 시뮬레이션, 게임 시간, 게임 인스턴스 정보 등이 이 UWorld 객체 내에 관리됩니다. 하나의 게임 인스턴스에는 하나의 UWorld 객체가 존재합니다.
AActor들이 스폰되고 소멸되는 주된 환경으로 UWorld는 SpawnActor, DestroyActor 같은 함수를 제공하여 액터의 생성과 제거를 관리합니다. 월드 내의 모든 액터에 대한 목록을 유지하고 FActorIterator와 같은 이터레이터를 통해 액터에 접근할 수 있도록 합니다.
UWorld는 여러개의 레벨을 로드하고 언로드하여 대규모 오픈월드를 효율적으로 관리할 수 있도록 합니다. 플레이어가 특정 영역에 진입하면 해당 영역의 레벨을 로드하고 벗어나면 언로드하는 방식으로 메모리를 최적화합니다. UWorld는 ServerTravel과 같은 함수를 통해 현재 레벨에서 다른 레벨로의 전환을 제어합니다.
DeltaTime 및 GameTime을 추적하고 Tick 함수를 호출할 때 이 시간 정보를 액터와 컴포넌트에 전달합니다. 타이머 시스템을 관리하여 특정 시간 간격으로 함수가 호출되도록 스케줄링합니다.
GameMode, GameState, PlayerController, PlayerState 등 게임의 핵심 논리 및 상태를 담당하는 프레임워크 클래스 인스턴스들을 소유하고 관리합니다. 물리 시뮬레이션, 충돌 감지, 네비게이션 메시, 사운드 엔진 등 게임의 다양한 서브 시스템들을 초기화하고 통합하는 역할을 합니다. 리플리케이션 시스템과 연동하여 월드 내의 액터와 컴포넌트 상태가 서버와 클라이언트 간에 올바르게 동기화되도록 돕습니다.
UWorld는 UE 게임의 심장부로 게임의 모든 존재와 상호작용이 이 UWorld의 컨텐스트 내에서 이루어지며 엔진이 게임을 실행하고 관리하는데 필요한 모든 핵심 서비스를 통합 제공합니다.