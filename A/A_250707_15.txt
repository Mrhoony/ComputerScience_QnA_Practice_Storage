팩토리 패턴이란?
->
팩토리 패턴은 객체 지향 프로그래밍에서 객체 생성을 캡슐화하는 디자인 패턴입니다. 어떤 객체를 만들지를 결정하는 로직을 별도의 팩토리 클래스에 위임하여 객체를 사용하는 클라이언트 코드가 특정 클래스에 직접 의존하는 것을 방지합니다.

객체를 생성하는 코드를 직접 작성하는 대신 객체를 대신 만들어주는 공장같은 역할을 하는 팩토리에게 생성을 요청하는 방식입니다.

일반적으로 객체를 생성할 때는 new 키워드를 사용합니다. 하지만 new를 직접 사용하면 다음과 같은 문제가 발생할 수 있습니다.
높은 결합도: 클라이언트 코드가 특정 구현 클래스에 직접적으로 의존하게 됩니다. 만약 생성 방식이 변경되거나 다른 종류의 객체를 생성해야 할 경우 new 키워드가 사용된 모든 클라이언트 코드를 수정해야 합니다.
유연성 부족: 새로운 객체 종류가 추가되면 클라이언트 코드 또한 변경되어야 합니다.

팩토리 패턴의 장점.
결합도 감소: 클라이언트 코드는 구체적인 클래스에 직접 의존하지 않고 팩토리 인터페이스나 추상 클래스에만 의존합니다. 이는 클라이언트 코드와 생성될 객체 간의 결합도를 낮춥니다.
유연성 및 확장성: 새로운 종류의 객체가 추가되거나 기존 객체의 생성 방식이 변경되어도 클라이언트 코드는 수정할 필요가 없습니다. 오직 팩토리 코드만 수정하거나 새로운 팩토리 구현체를 추가하면 됩니다.
객체 생성 로직의 캡슐화: 객체 생성에 필요한 복잡한 로직을 팩토리 내부에 캡슐화하여 클라이언트 코드의 복잡성을 줄입니다.
단일 책임 원칙(SRP) 준수: 객체 생성이라는 책임을 팩토리 클래스에 분리함으로서 객체를 사용하는 클래스는 자신의 주된 책임에만 집중할 수 있게 됩니다.
개방-폐쇄 원칙(OCP) 준수: 확장에 열려있고 변경에 닫혀있는 구조를 만듭니다. 새로운 제품을 추가할때 기존 코드를 수정할 필요 없이 팩토리만 확장하면 됩니다.

팩토리 패턴의 종류.
팩토리 메서드 패턴: 객체를 생성하는 인터페이스는 정의하되 어떤 클래스의 인스턴스를 생성할지는 서브클래스가 결정, 부모 클래스는 객체를 생성하는 추상 메서드를 정의하고 자식 클래스들이 이 메서드를 오버라이드하여 구체적인 객체를 생성
추상 팩토리 패턴: 서로 관련되거나 의존적인 객체들의 군집을 형성하기 위한 인터페이스를 제공하되 구체적인 클래스를 지정하지 않고 객체를 생성, 여러 종류의 제품을 한번에 생성하는 패밀리 팩토리 개념, 각 팩토리는 특정 테마에 맞는 여러 제품을 생성


델타 직렬화란?
->
UE에서 객체의 데이터를 효율적으로 저장(직렬화)하고 로드(역직렬화)하는 방법 중 하나입니다. CDO와 함께 작동하여 메모리 사용량을 최적화하고 로딩 성능을 향상시킵니다.

기본 원리: 기본값과 달라진 속성들만 저장하고 로드
기본값의 기준: UE의 모든 UObject 기반 클래스는 CDO라는 고유한 기본 객체를 가짐 CDO는 해당 클래스의 모든 UPROPERTY 변수들의 초기 기본값을 저장함
인스턴스 생성: 런타임에 어떤 클래스의 새로운 객체가 생성될 때 인스턴스의 모든 속성은 해당 클래스의 CDO에 저장된 기본값으로 초기화
데이터 변경(오버라이드): 게임 플레이 중이나 에디터에서 사용자가 특정 인스턴스의 속성 값을 CDO의 기본값과 다르게 변경할 수 있음
저장(직렬화): UE는 인스턴스를 파일에 저장할때 모든 속성을 다 저장하는 것이 아님, CDO에 저장된 기본값과 비교하여 값이 달라진 속성들만 파일에 기록
로드(역직렬화): 저장된 인스턴스를 다시 로드할 때 해당 클래스의 CDO로부터 모든 속성의 기본값을 가져와 인스턴스를 초기화한 뒤 저장된 오버라이드된 값들을 읽어와 기본값을 덮어씌움


리플렉션 시스템이란?
->
UE의 리플렉션 시스템은 C++ 언어에서는 일반적으로 지원하지 않는 런타임 시점의 타입 정보 접근 및 조작을 가능하게 해주는 매커니즘, 이를 통해 UE는 C++ 코드와 엔진 프레임워크 간의 통합을 구현

일반적인 C++은 컴파일 시점에 모든 타입 정보가 사라지므로 런타임 리플렉션을 기본적으로 지원하지 않음, UE는 자체적인 매크로와 전처리기를 사용하여 C++ 코드로부터 메타데이터를 추출하고 이를 런타임에 활용할 수 있도록 변환

작동 원리.
매크로 사용: 클래스, 속성, 함수에 UCLASS, UPROPERTY, UFUNCTION과 같은 엔진의 매크로를 붙여서 리플렉션 시스템에 노출시킬 대상을 지정
Unreal Header Tool(UHT): 컴파일 과정의 일부로 UHT라는 특수 전처리기가 소스 코드를 스캔, UHT는 U매크로를 찾고 이를 기반으로 메타데이터가 포함된 추가적인 C++ 코드를 자동 생성, 생성된 코드에는 UCLASS, UPROPERTY, UFUNCTION에 대한 런타임 타입 정보(클래스 이름, 속성 이름, 타입, 오프셋, 기본값, 접근 지정자 등)가 정의됨
메타데이터 객체 생성: 엔진이 시작되거나 모듈이 로드될 때 UHT가 생성한 코드 덕분에 각 UCLASS에 해당하는 UClass 객체, 각 UPROPERTY에 해당하는 FProperty 객체, 각 UFUNCTION에 해당하는 UFunction 객체 등의 런타임 메타데이터 객체들이 생성되어 메모리에 로드됨
런타임 활용: 엔진은 메타데이터 객체들을 통해 인스턴스의 클래스 타입 조회, UPROPERTY 접근, UFUNCTION 호출 등의 작업을 런타임에 수행할 수 있음

주요 기능 및 역할.
C++ 코드와 블루프린트 통합: UPROPERTY, UFUNCTION을 블루프린트에서 노출시켜 사용 가능
직렬화 및 역직렬화: 어떤 속성들을 저장하고 로드해야 하는지 확인
가비지 컬렉션: 리플렉션 시스템을 통해 참조 관계를 파악
네트워킹: 복제와 RPC 호출에서 리플렉션 시스템을 통해 해당 속성이나 함수를 확인

장점.
생산성 향상
유연성 및 확장성
자동화된 관리


언리얼 엔진의 리플렉션 시스템이란 무엇이며, 이것이 왜 필요한가요? 일반적인 C++ 리플렉션과의 차이점은 무엇인가요?
->
UE의 리플렉션 시스템은 C++ 언어에는 기본적으로 없는 런타임 시점의 타입 정보 접근 및 조작 기능을 엔진 자체적으로 구현한 것입니다. 프로그램이 실행되는 도중에 클래스의 이름, 멤버 변수, 함수 정보 등을 알아내고 동적으로 값을 읽거나 설정하고 함수를 호출할 수 있게 해주는 매커니즘입니다.

리플렉션은 UE의 핵심 기능(블루프린트 스크립팅, 에디터 디테일 패널, 직렬화, 가비지 컬렉션, 네트워킹 등)들을 가능하게 하는 기반 기술입니다. 개발자가 이러한 복잡한 시스템들을 수동으로 구현할 필요 없이 리플렉션 시스템이 C++ 코드의 정보를 활용하여 자동화해줍니다.

일반 C++ 리플렉션과의 차이점: 표준 C++은 컴파일 시점에 대부분의 타입 정보가 사라지기 때문에 런타임 리플렉션을 직접 지원하지 않습니다. UE는 이 한계를 극복하기 위해 UCLASS, UPROPERTY, UFUNCTION같은 특별한 매크로와 UHT라는 전처리기를 사용합니다. UHT가 컴파일 전에 이 매크로들을 파싱하여 런타임 리플렉션을 위한 메타데이터 코드와 객체들을 자동으로 생성해주는 방식입니다. 이는 런타임에 클래스 정보를 풍부하게 제공하고 표준 C++만으로는 불가능한 엔진의 강력한 기능들을 구현할 수 있게 합니다.


언리얼 엔진에서 리플렉션 시스템을 사용하기 위해 C++ 코드에 어떤 특별한 문법(매크로)을 사용해야 하나요? 각 매크로의 역할은 무엇입니까?
->
UCLASS: C++ 클래스를 UE의 리플렉션 시스템에 등록하고 UObject 계층 구조의 일부로 만듭니다. 이 매크로가 붙은 클래스만이 CDO 생성, 가비지 컬렉션, 직렬화, 블루프린트 노출 등의 UE 기능을 활용할 수 있습니다.
UPROPERTY: 클래스 내의 멤버 변수를 리플렉션 시스템에 등록합니다. 이를 통해 해당 변수는 에디터의 디테일 패널에 노출되거나 블루프린트에서 접근/수정되거나 직렬화 및 네트워킹 복제의 대상이 될 수 있습니다.
UFUNCTION: 클래스 내의 함수를 리플렉션 시스템에 등록합니다. 이를 통해 해당 함수는 블루프린트에서 호출되거나 네트워킹의 RPC 대상이 될 수 있습니다.
USTRUCT: C++ 구조체를 리플렉션 시스템에 등록합니다. 구조체 내의 UPROPERTY들도 리플렉션의 대상이 되어 직렬화되거나 에디터에 노출될 수 있습니다.
UENUM: C++ 열거형을 리플렉션 시스템에 등록합니다. 블루프린트에서 사용하거나 직렬화할 수 있습니다.


Unreal Header Tool (UHT)은 리플렉션 시스템에서 어떤 역할을 수행하나요?
->
UHT는 UE의 빌드 시스템에서 핵심적인 전처리기 도구입니다.

소스 코드 스캔: UHT는 컴파일 과정이 시작되기 전에 UE 프로젝트의 모든 C++ 헤더 파일을 스캔합니다.
매크로 파싱: 스캔 과정에서 UHT는 UCLASS, UPROPERTY, UFUNCTION 등 UE의 리플렉션 매크로가 붙은 부분을 식별합니다.
메타데이터 코드 생성: UHT는 식별된 매크로와 그 매크로에 포함된 지정자를 기반으로 리플렉션 메타데이터를 담은 추가적인 C++ 코드를 자동 생성합니다. 이 생성된 코드에는 각 클래스, 속성, 함수의 런타임 타입 정보를 담는 객체들이 정의됩니다.
빌드 연동: UHT가 생성한 C++ 코드는 나머지 프로젝트의 C++ 코드와 함께 컴파일되어 최종 실행 파일에 포함됩니다.


리플렉션 시스템 덕분에 언리얼 에디터에서 개발자들이 얻는 가장 큰 이점은 무엇이라고 생각하나요?
->
C++코드와 에디터 간의 끊김 없는 통합과 높은 생산성입니다.

시각적인 속성 편집(에디터의 디테일 패널): C++ 코드에서 UPROPERTY 매크로와 적절한 지정자를 이용하여 에디터의 디테일 패널에서 해당 속성을 시각적으로 확인하고 직접 값을 변경할 수 있습니다.
블루프린트 스크립팅 통합: BlueprintCallable, BlueprintReadOnly 같은 지정자를 통해 C++ 함수나 변수를 블루프린트 그래프에서 노드 형태로 직접 노출할 수 있습니다.
CDO를 통한 기본값 관리: 에디터에서 클래스의 기본값을 설정하고 저장하는 것이 가능합니다.


리플렉션 시스템이 언리얼 엔진의 런타임 객체 생성/소멸 관리(가비지 컬렉션)와 어떻게 연관되어 있는지 설명해주세요.
->
리플렉션 시스템은 GC 작동에 필수적인 정보를 제공합니다.

UE의 GC는 참조 기반으로 동작합니다. 어떤 UObject가 다른 UObject에 의해 참조되고 있는지를 추적하여 더 이상 아무도 참조하지 않는 객체를 메모리에서 해제합니다.

UPROPERTY 매크로를 사용하여 UObject 포인터를 선언하면 리플렉션 시스템은 UHT를 통해 이 포인터가 어떤 객체를 참조하고 있다는 메타데이터를 생성합니다.
GC는 리플렉션 정보를 활용하여 메모리상의 모든 UObject를 스캔하고 UPROPERTY로 선언된 포인터들을 따라가며 어떤 객체가 다른 객체를 참조하고 있는지를 파악합니다.
만약 어떤 UObject가 GC 루트로부터 연결된 UPROPERTY 체인을 통해 도달할 수 없다면 해당 객체는 더 이상 사용되지 않는 것으로 간주되어 GC에 의해 메모리에서 해제됩니다.

리플렉션 시스템은 GC가 객체 간의 참조 관계를 런타임에 동적으로 파악할 수 있게 해줍니다.


CDO(Class Default Object)가 리플렉션 시스템과 어떤 관계를 가지는지 설명해주세요.
->
CDO는 리플렉션 시스템의 결과물로 리플렉션 정보의 핵심 사용자 중 하나입니다.
리플렉션에 의해 생성 및 초기화: UE는 특정 UCLASS를 로드할 때 리플렉션 시스템이 UHT가 생성한 메타데이터를 기반으로 해당 클래스의 CDO를 생성합니다. CDO의 모든 UPROPERTY 속성들은 리플렉션 정보를 따라 적절한 타입으로 초기화되고 클래스에 정의된 기본값으로 채워집니다.
리플렉션 정보의 저장소: CDO 자체가 해당 클래스의 모든 UPROPERTY 값들의 기본 상태를 나타내는 UObject 인스턴스입니다. CDO는 리플렉션 시스템이 제공하는 모든 속성 메타데이터와 그에 해당하는 기본 값들을 실제 메모리 상에 가지고 있는 유일한 인스턴스입니다.
런타임 접근 통로: UClass::GetDefaultObject()와 같은 함수를 통해 런타임에 CDO에 접근할 수 있는 것은 리플렉션 시스템 덕분입니다. 리플렉션 시스템은 UClass 객체를 통해 해당 클래스의 CDO에 대한 참조를 제공합니다.

리플렉션 시스템은 CDO를 생성하고 관리하며 CDO는 리플렉션 시스템이 제공하는 클래스의 구조와 속성 정보를 실제 값으로 구현하여 저장하는 인스턴스입니다.


언리얼 엔진에서 UPROPERTY() 매크로를 사용하여 속성을 선언할 때, 다양한 메타데이터 지정자(예: EditAnywhere, BlueprintReadWrite, Category)를 붙일 수 있습니다. 이 메타데이터 지정자들이 리플렉션 시스템과 어떻게 상호작용하여 작동하는지 설명해주세요.
->
UPROPERTY 매크로에 붙는 EditAnywhere, BlueprintReadWrite, Category와 같은 메타데이터 지정자(Specifiers)는 리플렉션 시스템에 의해 처리되어 런타임에 활용 가능한 부가 정보를 제공합니다.
UHT에 의한 파싱: 개발자가 C++ 코드에 UPROPERTY(EditAnywhere)와 같은 지정자를 붙이면 UHT는 이 코드를 스캔하고 해당 지정자들을 파싱합니다.
메타데이터 저장: UHT는 파싱한 지정자들을 리플렉션 시스템이 생성하는 FProperty 객체 내부에 메타데이터로 저장합니다. EditAnywhere는 이 속성이 에디터의 모든 인스턴스에서 편집 가능하다는 플래그로 저장됩니다.
런타임/에디터 활용: 엔진이나 에디터는 저장된 메타데이터를 런타임에 조회하여 에디터의 디테일 패널, 블루프린트, 직렬화, 네트워킹 등에서 사용할 수 있습니다.

메타데이터 지정자들은 개발자가 C++ 코드에 선언만으로 해당 속성이나 함수가 UE의 다른 시스템과 어떻게 상호작용해야 하는지를 리플렉션 시스템을 통해 지시하는 수단입니다.


언리얼 엔진의 직렬화(Serialization) 시스템이 리플렉션 시스템을 어떻게 활용하는지 구체적으로 설명해주세요.
->
UE의 직렬화 시스템은 리플렉션 시스템에 전적으로 의존하여 UObject의 데이터를 효율적으로 저장하고 로드합니다.
어떤 속성을 저장할 것인가: UObject를 파일에 저장할 때 UE는 해당 객체의 UClass 리플렉션 정보를 조회합니다. 정보에는 어떤 멤버 변수가 UPROPERTY 매크로로 선언되었는지 해당 UPROPERTY에 Savegame, Transient 등의 직렬화 관련 지정자가 붙어있는지에 대한 메타데이터가 포함되어 있습니다. 직렬화 시스템은 이 정보를 바탕으로 직렬화 대상이 되는 속성들만을 식별합니다.
속성 값 접근: 리플렉션 시스템은 각 UPROPERTY의 메모리 오프셋 정보를 제공합니다. 직렬화 시스템은 이 오프셋을 사용하여 UObject 인스턴스의 메모리에서 해당 속성의 실제 값을 직접 읽어와 파일에 기록할 수 있습니다.

델타 직렬화와 리플렉션의 관계.
기준점 제공: 델타 직렬화는 CDO의 값을 기본값으로 사용합니다.
값 비교 및 차이점 식별: 직렬화 시스템은 UObject 인스턴스의 각 UPROPERTY 값을 리플렉션 정보를 통해 읽어온 후 동일한 UPROPERTY에 해당하는 CDO의 값과 비교합니다.
차이점만 기록: 만약 인스턴스의 속성 값이 CDO의 기본값과 다르다면 리플렉션 시스템이 제공하는 속성 이름과 타입 정보를 활용하여 해당 변경된 값만 파일에 기록합니다.
로드 시 재구성: CDO의 기본값으로 인스턴스를 초기화한 후 파일에 저장된 오버라이드된 속성들의 이름과 타입을 기반으로 해당 속성들의 메모리 위치에 새로운 값을 덮어씌웁니다.


특정 컴포넌트(예: UStaticMeshComponent)를 C++ 클래스의 생성자에서 CreateDefaultSubobject를 통해 생성하고 기본 설정을 해주는 것이 CDO와 어떤 관련이 있나요?
->
CreateDefaultSubobject 함수는 UE에서 CDO의 일부분으로 서브 객체(주로 컴포넌트)를 생성하고 설정하는데 사용되는 특별한 함수입니다.
CDO의 멤버, 기본 컴포넌트 설정, 인스턴스 생성 시 복사, 블루프린트 오버라이드 등 개발자가 코드를 통해 클래스 레벨의 기본 컴포넌트 구성을 정의하고 이것이 CDO를 통해 모든 인스턴스의 기본값으로 활용되도록 하는 매커니즘입니다.


리플렉션 시스템을 사용할 때 발생할 수 있는 잠재적인 단점이나 오버헤드는 무엇이라고 생각하나요?
->
컴파일 시간 증가, 메모리 사용량 증가, 런타임 성능 오버헤드가 발생할 수 있으며 주관적인 생각으로 이 중에서 런타임 성능 오버헤드가 가장 치명적인 문제가 될 수 있음

블루프린트는 흑마술과 같으며 블루프린트에서 사용 가능한 C++ 코드에 중단점을 걸어 함수 호출 스택을 확인해보면 단순히 블루프린트 -> C++의 투스텝이 아님을 확인할 수 있음, 이 부분은 코드의 실행 속도에 있어서 네이티브한 C++ 코드를 호출했을 때 보다 확연한 성능 차이를 보여줌, 이러한 이유 때문에 컨텐츠 코드의 최적화가 필요함


C++도 런타임에 타입 정보를 RTTI로 알 수 있는데 리플렉션 시스템하고 어떤 차이가 있는지?
->
기본적으로 C++에서는 런타임에 타입 정보를 알 수 없음, RTTI를 사용하면 가능하나 UE의 리플렉션 시스템과 비교했을때 기능이 매우 제한적이며 객체의 실제 타입에 대한 확인만 가능, RTTI의 목적은 다형적인 객체의 실제 타입을 확인하고 안전한 다운캐스팅이 가능하도록 하는 것이며 UE의 리플렉션 시스템의 목적과 상이함


UE의 GC가 프로그램 실행 중에 CDO를 해제할 수 있는지?
->
CDO는 GC에 의해 해제되지 않음
GC 루트의 역할: UE의 GC는 도달 가능성과 참조를 기반으로 동작하는데 GC가 루트라고 간주하는 지점으로부터 참조 사슬을 따라 도달할 수 있는 모든 객체는 해제되지 않음, CDO는 GC에서 항상 참조하는 GC 루트 중 하나로 간주되어 해제되지 않음
클래스의 템플릿: CDO는 클래스 기반의 인스턴스를 생성할 때 기본값을 참조하는 템플릿 역할을 함, 논리적으로 CDO가 없으면 UE의 시스템 내에서 객체 생성 시 문제가 발생
예외: 클래스 자체가 메모리에서 언로드되는 경우라면 CDO가 해제될 수 있음, 이 부분에 의해 이론상 가능하다고 표현할 수 있음, 게임 피처가 런타임에 동적으로 해제될 때 CDO가 어떻게 처리되는지 확인 필요