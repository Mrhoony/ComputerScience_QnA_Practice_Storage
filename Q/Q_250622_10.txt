메모리 누수(Memory Leak)와 댕글링 포인터(Dangling Pointer): 메모리 누수와 댕글링 포인터가 발생하는 주된 원인은 무엇이며, 이들이 프로그램의 안정성과 성능에 미치는 치명적인 영향을 설명하시오. C++에서 이들을 방지하기 위한 일반적인 프로그래밍 기법(예: RAII, 스마트 포인터)을 제시하시오.

CPU 캐시 메모리의 중요성: CPU 캐시 메모리(L1, L2, L3)의 역할은 무엇이며, 프로그램의 데이터 접근 패턴(예: 순차 접근 vs 무작위 접근)이 캐시 히트(Cache Hit)와 캐시 미스(Cache Miss)에 어떻게 영향을 미쳐 전반적인 성능을 좌우하는지 설명하시오.

메모리 단편화(Fragmentation) 심화: 힙(Heap) 메모리에서 외부 단편화(External Fragmentation)와 내부 단편화(Internal Fragmentation)가 발생하는 원인을 각각 설명하고, 이들이 프로그램의 메모리 사용 효율성 및 새로운 메모리 할당 실패에 미치는 영향을 논하시오.

메모리 정렬(Memory Alignment)의 필요성: 메모리 정렬이 왜 중요한지 (예: CPU의 데이터 접근 효율성, SIMD 명령어 사용, 특정 하드웨어 요구사항) 설명하고, C++에서 alignas 키워드나 컴파일러 특정 지시자를 사용하여 메모리 정렬을 명시적으로 제어하는 방법을 제시하시오.

객체 풀링(Object Pooling): 객체 풀링 기법은 무엇이며, 게임 개발에서 (특히 빈번하게 생성/파괴되는 총알, 이펙트 등) 힙 할당 및 해제로 인한 성능 오버헤드와 메모리 단편화를 줄이는 데 어떻게 기여하는지 설명하시오.

C++ 커스텀 할당자(Custom Allocator): C++ 표준 라이브러리 컨테이너(예: std::vector, std::map)에 커스텀 할당자를 사용하는 주된 이유는 무엇이며, 어떤 상황(예: 특정 메모리 영역 사용, 고성능/저단편화 요구)에서 커스텀 할당자 구현을 고려할 수 있는지 설명하시오.

언리얼 엔진의 가비지 컬렉션(Garbage Collection): 언리얼 엔진의 가비지 컬렉션 시스템이 어떤 방식으로 UObject 기반 메모리를 관리하는지 설명하시오. UPROPERTY(), AddReferencedObjects(), MarkAsGarbage()와 같은 메커니즘이 어떻게 작동하는지 간략히 설명하시오.

언리얼 엔진 컨테이너의 메모리 동작: TArray와 TMap (또는 TSet) 같은 언리얼 엔진의 컨테이너들이 내부적으로 메모리를 어떻게 관리하는지 (예: TArray의 용량 확장 정책, TMap의 해시 테이블 충돌 처리) 설명하고, 이들이 성능과 메모리 사용량에 미치는 영향을 논하시오.

메모리 프로파일링 도구 활용: 언리얼 엔진에서 제공하는 메모리 프로파일링 도구(예: Unreal Insights의 Memory Tracker, stat memory 명령어)를 사용하여 메모리 누수, 과도한 메모리 사용량, 그리고 불필요한 메모리 할당/해제를 어떻게 진단하고 최적화할 수 있는지 설명하시오.

데이터 지향 설계(Data-Oriented Design)와 메모리: 데이터 지향 설계(DOD)가 메모리 접근 패턴(특히 캐시 효율성)을 최적화하여 성능을 향상시키는 데 어떻게 기여하는지 설명하고, 객체 지향 설계(OOD)와 비교하여 메모리 관리 및 성능 관점에서의 장단점을 논하시오.