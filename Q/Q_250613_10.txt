C++에서 std::async, std::future, std::promise는 무엇이며, 다중 스레드 환경에서 비동기적으로 작업을 실행하고 결과를 안전하게 주고받는 데 어떻게 활용되는지 설명하시오.

std::atomic 변수 사용 시 std::memory_order_seq_cst는 어떤 메모리 순서 보장을 제공하며, 이것이 가장 강력한 순서 보장인 이유와 다른 메모리 순서(relaxed, acquire, release)와의 차이점을 설명하시오.

C++의 **가변 템플릿(Variadic Templates)**은 무엇이며, **매개변수 팩(parameter pack)**을 사용하여 타입 안전하게 임의 개수의 인자를 처리하는 방법을 간단한 예시와 함께 설명하시오.



3D 그래픽스에서 렌더 패스(Render Pass) 개념은 무엇이며, 다중 패스 렌더링(Multi-pass Rendering)이 어떤 상황(예: 후처리 효과, 그림자)에서 사용되는지 설명하시오.

네트워크 게임에서 **패킷 손실(Packet Loss)**이 발생했을 때, 이를 감지하고 복구하기 위한 두 가지 주요 메커니즘(예: ARQ - 재전송 요청, FEC - 전방 오류 수정)에 대해 설명하시오.

운영체제에서 데드락(Deadlock) 발생을 위한 네 가지 필요조건(상호 배제, 점유와 대기, 비선점, 순환 대기)을 설명하고, 각각을 방지하기 위한 방법을 간략히 제시하시오.



언리얼 엔진 5(UE5)의 Lumen과 Nanite 기술이 기존 렌더링 파이프라인의 어떤 한계를 극복하고, 각각 어떤 종류의 씬(Scene) 구성에서 혁신적인 이점을 제공하는지 설명하시오.

언리얼 엔진에서 **블루프린트 인터페이스(Blueprint Interface)**는 무엇이며, C++ 클래스에 어떻게 구현하고, 이를 통해 서로 다른 C++ 또는 블루프린트 클래스 간에 느슨하게 결합된 통신을 어떻게 달성할 수 있는지 설명하시오.

언리얼 엔진의 UFUNCTION에 사용되는 BlueprintCallable, BlueprintPure, Server, Client, NetMulticast와 같은 함수 지정자(Function Specifiers)들의 역할과 각각의 사용 목적을 설명하시오.

언리얼 엔진에서 **애셋 참조(Asset Reference)**를 **하드 참조(Hard Reference)**와 **소프트 참조(Soft Reference)**로 구분하는 주된 이유는 무엇이며, 각각의 장단점과 어떤 상황에 적합한지 설명하시오.