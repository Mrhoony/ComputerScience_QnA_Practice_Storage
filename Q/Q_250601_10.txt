C++에서 가상 함수(Virtual Function)는 무엇이며, 객체 지향 프로그래밍의 어떤 핵심 원리(예: 다형성)를 구현하는 데 사용되는지 설명하시오.

C++ 컴파일러는 가상 함수를 내부적으로 어떻게 구현하는지, 특히 가상 함수 테이블(V-Table)과 가상 함수 포인터(V-Ptr)의 역할을 중심으로 설명하시오.

파생 클래스에서 기본 클래스의 가상 함수를 재정의(Override)할 때 override 키워드를 사용하는 주된 목적은 무엇이며, 이 키워드를 생략했을 때 발생할 수 있는 잠재적인 문제점을 설명하시오.

순수 가상 함수(Pure Virtual Function)는 무엇이며, 이러한 함수를 포함하는 추상 클래스(Abstract Class)의 특징과 인스턴스화 가능 여부에 대해 설명하시오.

다형적(Polymorphic) 클래스 계층 구조에서 기본 클래스의 소멸자(Destructor)를 virtual로 선언하는 것이 왜 매우 중요한지 설명하고, 만약 virtual로 선언하지 않았을 때 발생할 수 있는 문제를 코드 예시와 함께 설명하시오.

생성자(Constructor)와 소멸자(Destructor) 내에서 가상 함수를 호출할 수 있는지 설명하고, 만약 가능하다면 어떤 동작을 하며, 그 결과가 다형성과 관련하여 왜 주의해야 하는지 설명하시오.

가상 함수의 공변 반환 타입(Covariant Return Types)은 무엇이며, C++에서 기본 클래스의 가상 함수를 재정의할 때 어떤 조건 하에서만 허용되는지 간단한 예시와 함께 설명하시오.

가상 함수 호출은 비가상 함수(non-virtual function) 호출에 비해 어떤 성능적 오버헤드를 가지는지 설명하고, 이러한 오버헤드가 발생하는 주된 원인을 (예: V-Table 룩업, 캐시 효율성) 설명하시오.

기본 클래스 포인터를 통해 파생 클래스 객체를 참조할 때, 가상 함수가 아닌 비가상 함수(non-virtual function)를 호출하면 어떤 일이 발생하는지 ("함수 숨김" 개념과 함께) 설명하시오.

final 키워드는 가상 함수와 클래스에 각각 어떤 용도로 사용되며, 상속 계층 구조에서 특정 함수의 재정의 또는 클래스의 상속을 제한하는 데 어떻게 활용되는지 설명하시오.
