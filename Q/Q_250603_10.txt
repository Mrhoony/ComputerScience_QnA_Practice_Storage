C++에서 컴파일 타임 다형성(Compile-time Polymorphism)과 런타임 다형성(Runtime Polymorphism)의 차이점을 설명하고, 각각 템플릿(Templates)과 가상 함수(Virtual Functions)를 사용하여 구현되는 방식과 어떤 상황에 더 적합한지 비교하시오.

std::any (C++17)는 무엇이며, 타입이 다른 여러 종류의 데이터를 동일한 컨테이너에 저장하거나 함수 인자로 전달해야 할 때 어떻게 사용될 수 있는지 설명하시오.

C++에서 "Copy-and-Swap" idiom은 무엇이며, 이 관용구를 사용하여 클래스의 할당 연산자(Assignment Operator)를 구현할 때 어떤 방식으로 예외 안전성(Exception Safety)이 보장되는지 설명하시오.



3D 그래픽스에서 드로우 콜(Draw Call) 배칭(Batching)이란 무엇이며, 왜 성능 최적화에 중요한지 설명하고, 스태틱(Static) 배칭과 다이내믹(Dynamic) 배칭의 기본적인 개념을 설명하시오.

온라인 게임에서 네트워크 지연(Latency)에 의한 상태 불일치(State Mismatch)를 해결하기 위한 "데드 레코닝(Dead Reckoning)"과 "풀 상태 동기화(Full State Synchronization)"의 개념을 설명하고, 각각의 장단점을 비교하시오.

컴퓨터 캐시 메모리 시스템에서 LRU(Least Recently Used) 알고리즘은 무엇이며, 어떤 상황에서 이 알고리즘이 효율적인 캐시 관리 전략으로 사용되는지 설명하시오.



언리얼 엔진 5(UE5)에 도입된 "머티리얼 레이어링(Material Layering)" 시스템의 기본적인 개념과 복잡한 머티리얼을 모듈화하고 재사용하는 데 어떤 이점을 제공하는지 설명하시오.

언리얼 엔진에서 TUniquePtr, TSharedPtr와 같은 C++ 표준 스마트 포인터 대신 언리얼 엔진 자체의 스마트 포인터(TUniquePtr<UObject>, TSharedPtr<FObject>)를 사용하는 주된 이유를 설명하시오.

언리얼 엔진의 "Replication Graph(복제 그래프)"는 무엇이며, 복잡한 대규모 멀티플레이어 게임에서 액터 복제 성능을 최적화하고 네트워크 대역폭을 효율적으로 관리하는 데 어떤 이점을 제공하는지 설명하시오.

언리얼 엔진의 성능 프로파일링 도구인 "Unreal Insights"의 기본적인 사용 흐름과 주요 기능(예: CPU/GPU 프레임 분석, 메모리 트래킹)에 대해 간략히 설명하시오.