객체 지향 프로그래밍(OOP)의 네 가지 핵심 기둥(Pillars)은 무엇인지 각각의 개념을 간략하게 설명하시오.

**캡슐화(Encapsulation)**란 무엇이며, 객체 지향 설계에서 캡슐화가 코드의 유지보수성, 안정성 및 재사용성을 어떻게 향상시키는지 설명하시오. C++에서 캡슐화를 구현하는 주요 방법(예: 접근 제어자)을 제시하시오.

**상속(Inheritance)**과 **합성(Composition)**은 객체 간의 관계를 모델링하는 두 가지 주요 방법입니다. "상속보다는 합성을 선호하라(Prefer composition over inheritance)"는 원칙의 의미를 설명하고, 각각 어떤 상황에 더 적합한지 장단점을 비교하시오.

**다형성(Polymorphism)**은 객체 지향의 중요한 특징입니다. C++에서 런타임 다형성(예: 가상 함수) 외에 컴파일 타임 다형성(예: 템플릿, 함수 오버로딩)은 어떻게 구현되는지 설명하고, 이들의 차이점을 설명하시오.

**추상화(Abstraction)**란 무엇이며, C++에서 추상 클래스(Abstract Class)와 순수 추상 클래스(Pure Abstract Class, 즉 인터페이스 역할)를 통해 어떻게 추상화를 달성할 수 있는지 설명하시오. 둘의 주요 차이점은 무엇인가요?

SOLID 원칙은 객체 지향 설계의 핵심 원칙입니다. 이 중 세 가지 이상의 원칙(예: 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존성 역전 원칙)을 선택하여 간략히 설명하고, 이들이 유연하고 확장 가능한 시스템을 만드는 데 어떻게 기여하는지 설명하시오.

객체 지향 설계에서 **결합도(Coupling)**와 **응집도(Cohesion)**는 무엇이며, 좋은 설계가 높은 응집도와 낮은 결합도를 지향해야 하는 이유를 설명하시오.

객체 지향 패러다임을 사용하여 대규모 소프트웨어(예: 게임 엔진)를 개발할 때 얻을 수 있는 주요 이점(예: 모듈성, 재사용성, 확장성)은 무엇이며, 반대로 잠재적인 단점(예: 성능 오버헤드, 복잡성)은 무엇이 있을 수 있는지 설명하시오.

C++에서 **추상 클래스(Abstract Class)**와 인터페이스(Interface) 역할을 하는 순수 추상 클래스를 설계할 때의 주요 고려 사항과 각각의 전형적인 사용 시나리오를 설명하시오.

언리얼 엔진의 액터(Actor)-컴포넌트(Component) 모델에서 객체 지향의 주요 원리(예: 합성, 다형성)가 어떻게 적용되어 게임 로직을 구성하고 확장하는 데 활용되는지 구체적인 예시와 함께 설명하시오.