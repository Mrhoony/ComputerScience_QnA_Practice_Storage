C++17에 도입된 **std::apply**는 무엇이며, 튜플(Tuple)의 요소들을 함수 인자로 언팩(unpack)하여 호출하는 데 어떻게 사용될 수 있는지 설명하시오.

**CRTP (Curiously Recurring Template Pattern)**는 무엇이며, C++에서 정적 다형성(Static Polymorphism)을 구현하거나 컴파일 타임에 특정 기능을 클래스에 주입(inject)하는 데 어떻게 활용될 수 있는지 설명하시오.

C++에서 volatile 키워드는 무엇이며, 최적화 컴파일러가 특정 변수에 대한 접근을 최적화하지 않도록 강제하여 다중 스레드 환경이나 하드웨어 레지스터 접근 시 어떤 문제를 방지하는 데 사용되는지 설명하시오.



**싱글톤 패턴(Singleton Pattern)**은 무엇이며, 게임 개발에서 전역적으로 유일한 인스턴스를 관리해야 하는 시스템(예: 오디오 매니저, 게임 설정)에 어떻게 적용될 수 있는지 설명하고, 이 패턴의 장단점을 논하시오.

**명령 패턴(Command Pattern)**은 무엇이며, 게임에서 실행 취소/다시 실행 기능, 매크로 기록, 또는 네트워크를 통한 플레이어 액션 동기화와 같은 시스템을 구현하는 데 어떻게 활용될 수 있는지 설명하시오.

**데이터 지향 설계(Data-Oriented Design, DOD)**의 핵심 원칙은 무엇이며, 메모리 접근 패턴(특히 캐시 효율성)을 최적화하여 고성능 게임을 개발하는 데 어떻게 기여하는지 설명하시오. 객체 지향 설계(OOD)와 비교하여 설명하시오.



언리얼 엔진에서 **FSoftObjectPath**와 **FSoftClassPath**는 무엇이며, 에셋을 하드 참조(Hard Reference)하지 않고도 런타임에 필요할 때 동적으로 로드(Load)하여 메모리 사용량과 로딩 시간을 최적화하는 데 어떻게 사용되는지 설명하시오.

언리얼 엔진의 **TSharedPtr**와 **TWeakPtr**는 C++ 표준의 std::shared_ptr, std::weak_ptr와 유사하지만 언리얼 엔진의 가비지 컬렉션(GC) 시스템과 어떻게 상호작용하며, UObject가 아닌 일반 C++ 객체의 생명 주기를 관리하는 데 어떤 차이점이 있는지 설명하시오.

언리얼 엔진에서 **GameplayAbilitySystem (GAS)**의 주요 구성 요소(예: UGameplayAbility, UGameplayEffect, UAttributeSet)는 무엇이며, 복잡한 스킬, 버프/디버프, 캐릭터 스탯 시스템을 유연하고 확장 가능하게 구현하는 데 어떻게 활용되는지 설명하시오.

언리얼 엔진에서 stat 명령어 외에 Unreal Insights와 같은 고급 프로파일링 도구를 사용하여 게임의 CPU, GPU, 메모리, 네트워크 성능 병목 현상을 어떻게 진단하고 분석할 수 있는지 구체적인 사용 사례와 함께 설명하시오.