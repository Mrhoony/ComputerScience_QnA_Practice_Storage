객체 지향 프로그래밍(OOP)에서 "객체 관계(Object Relationship)"란 무엇이며, 왜 좋은 소프트웨어 설계를 위해 객체 관계를 이해하는 것이 중요한지 설명하시오.

연관(Association) 관계와 의존(Dependency) 관계의 차이점을 설명하고, 각각 게임 개발 컨텍스트에서 간단한 C++ 코드 예시를 들어 설명하시오.

집약(Aggregation) 관계와 합성(Composition) 관계의 핵심적인 차이점을 설명하시오. 특히, 객체의 생명 주기(Lifetime)와 소유권(Ownership) 관점에서 차이점을 명확히 하시오.

C++에서 집약 관계와 합성 관계는 일반적으로 어떻게 구현되는지 (예: 원시 포인터/참조, 임베디드 객체, 스마트 포인터 사용) 각각의 구현 방식을 설명하시오.

상속(Inheritance)은 객체 간의 "Is-A(이다)" 관계를 나타냅니다. 상속을 통한 객체 관계의 주요 이점(코드 재사용, 다형성)과 잠재적인 단점(강한 결합, 상속 계층의 복잡성)을 설명하시오.

**위임(Delegation)**은 객체 관계의 한 형태로, 코드 재사용을 위해 상속 대신 사용될 수 있습니다. 위임이란 무엇이며, 어떤 상황에서 상속보다 위임이 더 나은 설계 대안이 될 수 있는지 설명하시오.

인터페이스(Interface) 구현은 객체 관계의 한 측면을 나타냅니다. C++의 순수 추상 클래스(Pure Abstract Class)나 언리얼 엔진의 UInterface를 구현하는 것이 "Has-A(가진다)" 또는 "Is-A" 관계 중 어느 쪽에 더 가깝다고 볼 수 있는지, 그리고 행동 공유 관점에서 인터페이스 사용의 이점을 설명하시오.

C++에서 객체 관계(합성, 집약, 연관)가 메모리 관리 및 객체 생명 주기에 어떻게 영향을 미치는지 설명하시오. 특히 스마트 포인터(예: std::unique_ptr, std::shared_ptr)가 이러한 관계에서 어떤 역할을 하는지 포함하여 설명하시오.

언리얼 엔진의 액터(Actor)와 컴포넌트(Component) 모델은 객체 관계의 좋은 예시입니다. 액터가 컴포넌트를 소유하는 관계는 합성(Composition)에 가깝다고 볼 수 있습니다. 이 관계에서 언리얼 엔진의 가비지 컬렉션(Garbage Collection) 시스템이 컴포넌트의 생명 주기를 어떻게 관리하는지 설명하시오.

게임 프로젝트에서 객체 관계를 설계할 때 **느슨한 결합(Loose Coupling)**을 달성하는 것이 왜 중요한지 설명하시오. 또한, 이를 위해 적용할 수 있는 설계 원칙이나 디자인 패턴(예: 의존성 주입, 옵저버 패턴)에는 어떤 것들이 있는지 간략히 제시하시오.
