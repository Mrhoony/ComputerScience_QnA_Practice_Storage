C++에서 **가상 상속(Virtual Inheritance)**은 무엇이며, 특히 다중 상속 환경에서 발생하는 "다이아몬드 문제(Diamond Problem)"를 해결하기 위해 어떻게 사용되는지 설명하시오. 간단한 코드 예시를 들어 설명하시오.

dynamic_cast 연산자는 런타임에 타입 캐스팅을 수행합니다. dynamic_cast가 다형적(Polymorphic) 클래스에만 적용될 수 있는 이유, 즉 클래스에 적어도 하나의 가상 함수가 필요한 이유를 설명하시오.

가상 함수에 **기본 인자(Default Arguments)**가 선언되어 있고 파생 클래스에서 이 함수를 재정의(override)했을 때 발생할 수 있는 잠재적인 문제점(예: 함수 호출 시 인자 해석의 모호성)을 설명하시오.

가상 함수를 inline 키워드와 함께 선언할 수 있는지 설명하고, 만약 가능하다면 컴파일러의 인라인 최적화에 어떤 영향을 미치며, 런타임 가상 호출 메커니즘과 어떻게 상호작용하는지 설명하시오.

다중 상속(Multiple Inheritance) 상황에서 가상 함수 테이블(V-Table)의 구조가 단일 상속에 비해 어떻게 더 복잡해질 수 있는지 간략하게 설명하시오.

const 한정자(qualifier)는 가상 함수에 어떻게 적용될 수 있으며, 가상 함수가 const와 const가 아닌 오버로드(overload)를 가질 때 다형적 호출에서 어떤 규칙이 적용되는지 설명하시오.

C++에서 일반 멤버 함수나 정적(Static) 멤버 함수를 virtual로 선언하는 것이 왜 문법적으로 허용되지 않는지 설명하시오.

가상 함수 호출의 성능 오버헤드는 단순히 V-Table 룩업 이상의 요소를 가집니다. V-Table 룩업 외에 CPU 캐시(Cache) 효율성, 예측 불가능한 분기(Branch Prediction) 등 어떤 요소들이 가상 함수 호출의 성능에 영향을 미치는지 설명하시오.

객체가 소멸될 때(특히 기본 클래스 포인터를 통해 소멸자를 호출할 때), 소멸자 내부에서 가상 함수를 호출하면 어떤 동작을 하며, 이때 다형적 호출이 예상대로 이루어지지 않는 이유를 설명하시오.

C++에서 다형성을 구현하는 두 가지 주요 방법인 **가상 함수(런타임 다형성)**와 **템플릿(컴파일 타임 다형성)**을 비교하고, 각각의 장단점 및 게임 개발 환경에서 어떤 상황에 더 적합한지 논하시오.